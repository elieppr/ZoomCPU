"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeadsAWS = void 0;
const typescript_cubic_spline_1 = require("typescript-cubic-spline");
const zod_1 = require("zod");
const common_1 = require("../../types/common");
const helpers_1 = require("../../util/helpers");
const validations_1 = require("../../util/validations");
const errors_1 = require("../../util/errors");
const AWS_INSTANCES = require("./aws-instances.json");
const AWS_EMBODIED = require("./aws-embodied.json");
const { InputValidationError, UnsupportedValueError } = errors_1.ERRORS;
const TeadsAWS = (globalConfig) => {
    const metadata = { kind: 'execute' };
    const computeInstances = {};
    const expectedLifespan = 4 * 365 * 24 * 3600;
    const interpolation = globalConfig.interpolation || common_1.Interpolation.LINEAR;
    const errorBuilder = (0, helpers_1.buildErrorMessage)(exports.TeadsAWS.name);
    /**
     * Calculate the total emissions for a list of inputs.
     */
    const execute = async (inputs) => {
        standardizeInstanceMetrics();
        return inputs.map(input => {
            const safeInput = Object.assign({}, input, validateInput(input));
            const instanceType = safeInput['cloud/instance-type'];
            const validExpectedLifespan = input['cpu/expected-lifespan'] ?? expectedLifespan;
            return {
                ...input,
                energy: calculateEnergy(safeInput, instanceType),
                'carbon-embodied': embodiedEmissions(safeInput, instanceType, validExpectedLifespan),
            };
        });
    };
    /**
     * Standardize the instance metrics for all the vendors.
     * Maps the instance metrics to a standard format (min, max, idle, 10%, 50%, 100%) for all the vendors.
     */
    const standardizeInstanceMetrics = () => {
        AWS_INSTANCES.forEach((instance) => {
            const cpus = parseInt(instance['Instance vCPU'], 10);
            const consumption = parseConsumptionValues(instance);
            computeInstances[instance['Instance type']] = {
                consumption,
                vCPUs: cpus,
                maxvCPUs: parseInt(instance['Platform Total Number of vCPU'], 10),
                name: instance['Instance type'],
            };
        });
        AWS_EMBODIED.forEach((instance) => {
            computeInstances[instance['type']].embodiedEmission = instance['total'];
        });
    };
    /**
     * Calculates the consumption metrics (idle, 10%, 50%, 100%) for a given compute instance.
     */
    const parseConsumptionValues = (instance) => {
        return {
            idle: getParsedInstanceMetric(instance['Instance @ Idle']),
            tenPercent: getParsedInstanceMetric(instance['Instance @ 10%']),
            fiftyPercent: getParsedInstanceMetric(instance['Instance @ 50%']),
            hundredPercent: getParsedInstanceMetric(instance['Instance @ 100%']),
        };
    };
    /**
     * Parses a metric value to a floating-point number.
     */
    const getParsedInstanceMetric = (metric) => {
        return parseFloat(metric.replace(',', '.'));
    };
    /**
     * Calculates the energy consumption for a single input
     * Uses a spline method for AWS and linear interpolation for GCP and Azure
     *
     * wattage is in watts
     * eg: 30W x 300s = 9000 J
     * 1 Wh = 3600 J
     * 9000 J / 3600 = 2.5 Wh
     * J / 3600 = Wh
     * 2.5 Wh / 1000 = 0.0025 kWh
     * Wh / 1000 = kWh
     * (wattage * duration) / (seconds in an hour) / 1000 = kWh
     */
    const calculateEnergy = (input, instanceType) => {
        if (!('cpu/utilization' in input)) {
            throw new InputValidationError(errorBuilder({
                message: "Required parameters 'cpu/utilization' is not provided",
            }));
        }
        const { duration, 'cpu/utilization': cpu } = input;
        const wattage = calculateWattage(cpu, instanceType);
        return (wattage * duration) / 3600 / 1000;
    };
    const calculateWattage = (cpu, instanceType) => {
        const consumption = computeInstances[instanceType].consumption;
        const x = [0, 10, 50, 100]; // Get the wattage for the instance type.
        const y = [
            consumption.idle,
            consumption.tenPercent,
            consumption.fiftyPercent,
            consumption.hundredPercent,
        ];
        const spline = new typescript_cubic_spline_1.default(x, y);
        if (interpolation === common_1.Interpolation.SPLINE) {
            return spline.at(cpu);
        }
        return calculateLinearInterpolationWattage(cpu, x, y);
    };
    /**
     * Calculates the linear interpolation wattage.
     */
    const calculateLinearInterpolationWattage = (cpu, points, curve) => {
        const result = points.reduce((acc, point, i) => {
            if (cpu === point) {
                acc.baseRate = curve[i];
                acc.baseCpu = point;
            }
            else if (cpu > point && cpu < points[i + 1]) {
                acc.baseRate = curve[i];
                acc.baseCpu = point;
                acc.ratio = (curve[i + 1] - curve[i]) / (points[i + 1] - point);
            }
            return acc;
        }, { baseRate: 0, baseCpu: 0, ratio: 0 });
        return result.baseRate + (cpu - result.baseCpu) * result.ratio;
    };
    /**
     * Calculates the embodied emissions for a given input.
     *
     *  M = TE * (TR/EL) * (RR/TR)
     *  Where:
     *  TE = Total Embodied Emissions, the sum of Life Cycle Assessment(LCA) emissions for all hardware components
     *  TR = Time Reserved, the length of time the hardware is reserved for use by the software
     *  EL = Expected Lifespan, the anticipated time that the equipment will be installed
     *  RR = Resources Reserved, the number of resources reserved for use by the software.
     *  TR = Total Resources, the total number of resources available.
     */
    const embodiedEmissions = (input, instanceType, expectedLifespan) => {
        const instance = computeInstances[instanceType];
        const totalEmissions = instance.embodiedEmission;
        const timeReserved = input['duration'] / 3600;
        const expectedLifespanInSeconds = expectedLifespan / 3600;
        const reservedResources = instance.vCPUs;
        const totalResources = instance.maxvCPUs;
        // Multiply totalEmissions by 1000 to convert from kgCO2e to gCO2e
        return (totalEmissions *
            1000 *
            (timeReserved / expectedLifespanInSeconds) *
            (reservedResources / totalResources));
    };
    /**
     * Validates static parameters.
     */
    const validateInput = (input) => {
        const schema = zod_1.z
            .object({
            'cloud/instance-type': zod_1.z.string(),
            'cpu/expected-lifespan': zod_1.z.number().optional(),
        })
            .refine(param => {
            validateInstanceType(param['cloud/instance-type']);
            return true;
        });
        return (0, validations_1.validate)(schema, input);
    };
    /**
     * Validates an instance type.
     */
    const validateInstanceType = (instanceType) => {
        if (instanceType !== undefined &&
            (!(instanceType in computeInstances) || instanceType === '')) {
            throw new UnsupportedValueError(errorBuilder({
                message: `Instance type ${instanceType} is not supported`,
            }));
        }
    };
    return {
        metadata,
        execute,
    };
};
exports.TeadsAWS = TeadsAWS;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RlYWRzLWF3cy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxxRUFBNkM7QUFDN0MsNkJBQXNCO0FBR3RCLCtDQU00QjtBQUU1QixnREFBcUQ7QUFDckQsd0RBQWdEO0FBQ2hELDhDQUF5QztBQUV6QyxzREFBc0Q7QUFDdEQsb0RBQW9EO0FBRXBELE1BQU0sRUFBQyxvQkFBb0IsRUFBRSxxQkFBcUIsRUFBQyxHQUFHLGVBQU0sQ0FBQztBQUV0RCxNQUFNLFFBQVEsR0FBRyxDQUFDLFlBQTBCLEVBQW1CLEVBQUU7SUFDdEUsTUFBTSxRQUFRLEdBQUcsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLENBQUM7SUFDbkMsTUFBTSxnQkFBZ0IsR0FBb0MsRUFBRSxDQUFDO0lBQzdELE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQzdDLE1BQU0sYUFBYSxHQUFHLFlBQVksQ0FBQyxhQUFhLElBQUksc0JBQWEsQ0FBQyxNQUFNLENBQUM7SUFFekUsTUFBTSxZQUFZLEdBQUcsSUFBQSwyQkFBaUIsRUFBQyxnQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXREOztPQUVHO0lBQ0gsTUFBTSxPQUFPLEdBQUcsS0FBSyxFQUFFLE1BQXNCLEVBQUUsRUFBRTtRQUMvQywwQkFBMEIsRUFBRSxDQUFDO1FBRTdCLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN4QixNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFFakUsTUFBTSxZQUFZLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLENBQUM7WUFDdEQsTUFBTSxxQkFBcUIsR0FDekIsS0FBSyxDQUFDLHVC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QU0sQ0FBQztZQUNOLHFCQUFxQixFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7WUFDakMsdUJBQXVCLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRTtTQUMvQyxDQUFDO2FBQ0QsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2Qsb0JBQW9CLENBQUMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQztZQUNuRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQyxDQUFDO1FBRUwsT0FBTyxJQUFBLHNCQUFRLEVBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pDLENBQUMsQ0FBQztJQUVGOztPQUVHO0lBQ0gsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLFlBQWdDLEVBQUUsRUFBRTtRQUNoRSxJQUNFLFlBQVksS0FBSyxTQUFTO1lBQzFCLENBQUMsQ0FBQyxDQUFDLFlBQVksSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLFlBQVksS0FBSyxFQUFFLENBQUMsRUFDNUQ7WUFDQSxNQUFNLElBQUkscUJBQXFCLENBQzdCLFlBQVksQ0FBQztnQkFDWCxPQUFPLEVBQUUsaUJBQWlCLFlBQVksbUJBQW1CO2FBQzFELENBQUMsQ0FDSCxDQUFDO1NBQ0g7SUFDSCxDQUFDLENBQUM7SUFFRixPQUFPO1FBQ0wsUUFBUTtRQUNSLE9BQU87S0FDUixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBdk5XLFFBQUEsUUFBUSxZQXVObkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3BsaW5lIGZyb20gJ3R5cGVzY3JpcHQtY3ViaWMtc3BsaW5lJztcbmltcG9ydCB7en0gZnJvbSAnem9kJztcblxuaW1wb3J0IHtQbHVnaW5JbnRlcmZhY2V9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtcbiAgSW50ZXJwb2xhdGlvbixcbiAgS2V5VmFsdWVQYWlyLFxuICBQbHVnaW5QYXJhbXMsXG4gIENvbXB1dGVJbnN0YW5jZSxcbiAgQ29uZmlnUGFyYW1zLFxufSBmcm9tICcuLi8uLi90eXBlcy9jb21tb24nO1xuXG5pbXBvcnQge2J1aWxkRXJyb3JNZXNzYWdlfSBmcm9tICcuLi8uLi91dGlsL2hlbHBlcnMnO1xuaW1wb3J0IHt2YWxpZGF0ZX0gZnJvbSAnLi4vLi4vdXRpbC92YWxpZGF0aW9ucyc7XG5pbXBvcnQge0VSUk9SU30gZnJvbSAnLi4vLi4vdXRpbC9lcnJvcnMnO1xuXG5pbXBvcnQgKiBhcyBBV1NfSU5TVEFOQ0VTIGZyb20gJy4vYXdzLWluc3RhbmNlcy5qc29uJztcbmltcG9ydCAqIGFzIEFXU19FTUJPRElFRCBmcm9tICcuL2F3cy1lbWJvZGllZC5qc29uJztcblxuY29uc3Qge0lucHV0VmFsaWRhdGlvbkVycm9yLCBVbnN1cHBvcnRlZFZhbHVlRXJyb3J9ID0gRVJST1JTO1xuXG5leHBvcnQgY29uc3QgVGVhZHNBV1MgPSAoZ2xvYmFsQ29uZmlnOiBDb25maWdQYXJhbXMpOiBQbHVnaW5JbnRlcmZhY2UgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IHtraW5kOiAnZXhlY3V0ZSd9O1xuICBjb25zdCBjb21wdXRlSW5zdGFuY2VzOiBSZWNvcmQ8c3RyaW5nLCBDb21wdXRlSW5zdGFuY2U+ID0ge307XG4gIGNvbnN0IGV4cGVjdGVkTGlmZXNwYW4gPSA0ICogMzY1ICogMjQgKiAzNjAwO1xuICBjb25zdCBpbnRlcnBvbGF0aW9uID0gZ2xvYmFsQ29uZmlnLmludGVycG9sYXRpb24gfHwgSW50ZXJwb2xhdGlvbi5MSU5FQVI7XG5cbiAgY29uc3QgZXJyb3JCdWlsZGVyID0gYnVpbGRFcnJvck1lc3NhZ2UoVGVhZHNBV1MubmFtZSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgdG90YWwgZW1pc3Npb25zIGZvciBhIGxpc3Qgb2YgaW5wdXRzLlxuICAgKi9cbiAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jIChpbnB1dHM6IFBsdWdpblBhcmFtc1tdKSA9PiB7XG4gICAgc3RhbmRhcmRpemVJbnN0YW5jZU1ldHJpY3MoKTtcblxuICAgIHJldHVybiBpbnB1dHMubWFwKGlucHV0ID0+IHtcbiAgICAgIGNvbnN0IHNhZmVJbnB1dCA9IE9iamVjdC5hc3NpZ24oe30sIGlucHV0LCB2YWxpZGF0ZUlucHV0KGlucHV0KSk7XG5cbiAgICAgIGNvbnN0IGluc3RhbmNlVHlwZSA9IHNhZmVJbnB1dFsnY2xvdWQvaW5zdGFuY2UtdHlwZSddO1xuICAgICAgY29uc3QgdmFsaWRFeHBlY3RlZExpZmVzcGFuID1cbiAgICAgICAgaW5wdXRbJ2NwdS9leHBlY3RlZC1saWZlc3BhbiddID8/IGV4cGVjdGVkTGlmZXNwYW47XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmlucHV0LFxuICAgICAgICBlbmVyZ3k6IGNhbGN1bGF0ZUVuZXJneShzYWZlSW5wdXQsIGluc3RhbmNlVHlwZSksXG4gICAgICAgICdjYXJib24tZW1ib2RpZWQnOiBlbWJvZGllZEVtaXNzaW9ucyhcbiAgICAgICAgICBzYWZlSW5wdXQsXG4gICAgICAgICAgaW5zdGFuY2VUeXBlLFxuICAgICAgICAgIHZhbGlkRXhwZWN0ZWRMaWZlc3BhblxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhbmRhcmRpemUgdGhlIGluc3RhbmNlIG1ldHJpY3MgZm9yIGFsbCB0aGUgdmVuZG9ycy5cbiAgICogTWFwcyB0aGUgaW5zdGFuY2UgbWV0cmljcyB0byBhIHN0YW5kYXJkIGZvcm1hdCAobWluLCBtYXgsIGlkbGUsIDEwJSwgNTAlLCAxMDAlKSBmb3IgYWxsIHRoZSB2ZW5kb3JzLlxuICAgKi9cbiAgY29uc3Qgc3RhbmRhcmRpemVJbnN0YW5jZU1ldHJpY3MgPSAoKSA9PiB7XG4gICAgQVdTX0lOU1RBTkNFUy5mb3JFYWNoKChpbnN0YW5jZTogS2V5VmFsdWVQYWlyKSA9PiB7XG4gICAgICBjb25zdCBjcHVzID0gcGFyc2VJbnQoaW5zdGFuY2VbJ0luc3RhbmNlIHZDUFUnXSwgMTApO1xuICAgICAgY29uc3QgY29uc3VtcHRpb24gPSBwYXJzZUNvbnN1bXB0aW9uVmFsdWVzKGluc3RhbmNlKTtcblxuICAgICAgY29tcHV0ZUluc3RhbmNlc1tpbnN0YW5jZVsnSW5zdGFuY2UgdHlwZSddXSA9IHtcbiAgICAgICAgY29uc3VtcHRpb24sXG4gICAgICAgIHZDUFVzOiBjcHVzLFxuICAgICAgICBtYXh2Q1BVczogcGFyc2VJbnQoaW5zdGFuY2VbJ1BsYXRmb3JtIFRvdGFsIE51bWJlciBvZiB2Q1BVJ10sIDEwKSxcbiAgICAgICAgbmFtZTogaW5zdGFuY2VbJ0luc3RhbmNlIHR5cGUnXSxcbiAgICAgIH0gYXMgQ29tcHV0ZUluc3RhbmNlO1xuICAgIH0pO1xuXG4gICAgQVdTX0VNQk9ESUVELmZvckVhY2goKGluc3RhbmNlOiBLZXlWYWx1ZVBhaXIpID0+IHtcbiAgICAgIGNvbXB1dGVJbnN0YW5jZXNbaW5zdGFuY2VbJ3R5cGUnXV0uZW1ib2RpZWRFbWlzc2lvbiA9IGluc3RhbmNlWyd0b3RhbCddO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBjb25zdW1wdGlvbiBtZXRyaWNzIChpZGxlLCAxMCUsIDUwJSwgMTAwJSkgZm9yIGEgZ2l2ZW4gY29tcHV0ZSBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0IHBhcnNlQ29uc3VtcHRpb25WYWx1ZXMgPSAoaW5zdGFuY2U6IEtleVZhbHVlUGFpcikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBpZGxlOiBnZXRQYXJzZWRJbnN0YW5jZU1ldHJpYyhpbnN0YW5jZVsnSW5zdGFuY2UgQCBJZGxlJ10pLFxuICAgICAgdGVuUGVyY2VudDogZ2V0UGFyc2VkSW5zdGFuY2VNZXRyaWMoaW5zdGFuY2VbJ0luc3RhbmNlIEAgMTAlJ10pLFxuICAgICAgZmlmdHlQZXJjZW50OiBnZXRQYXJzZWRJbnN0YW5jZU1ldHJpYyhpbnN0YW5jZVsnSW5zdGFuY2UgQCA1MCUnXSksXG4gICAgICBodW5kcmVkUGVyY2VudDogZ2V0UGFyc2VkSW5zdGFuY2VNZXRyaWMoaW5zdGFuY2VbJ0luc3RhbmNlIEAgMTAwJSddKSxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBtZXRyaWMgdmFsdWUgdG8gYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAqL1xuICBjb25zdCBnZXRQYXJzZWRJbnN0YW5jZU1ldHJpYyA9IChtZXRyaWM6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KG1ldHJpYy5yZXBsYWNlKCcsJywgJy4nKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGVuZXJneSBjb25zdW1wdGlvbiBmb3IgYSBzaW5nbGUgaW5wdXRcbiAgICogVXNlcyBhIHNwbGluZSBtZXRob2QgZm9yIEFXUyBhbmQgbGluZWFyIGludGVycG9sYXRpb24gZm9yIEdDUCBhbmQgQXp1cmVcbiAgICpcbiAgICogd2F0dGFnZSBpcyBpbiB3YXR0c1xuICAgKiBlZzogMzBXIHggMzAwcyA9IDkwMDAgSlxuICAgKiAxIFdoID0gMzYwMCBKXG4gICAqIDkwMDAgSiAvIDM2MDAgPSAyLjUgV2hcbiAgICogSiAvIDM2MDAgPSBXaFxuICAgKiAyLjUgV2ggLyAxMDAwID0gMC4wMDI1IGtXaFxuICAgKiBXaCAvIDEwMDAgPSBrV2hcbiAgICogKHdhdHRhZ2UgKiBkdXJhdGlvbikgLyAoc2Vjb25kcyBpbiBhbiBob3VyKSAvIDEwMDAgPSBrV2hcbiAgICovXG4gIGNvbnN0IGNhbGN1bGF0ZUVuZXJneSA9IChpbnB1dDogUGx1Z2luUGFyYW1zLCBpbnN0YW5jZVR5cGU6IHN0cmluZykgPT4ge1xuICAgIGlmICghKCdjcHUvdXRpbGl6YXRpb24nIGluIGlucHV0KSkge1xuICAgICAgdGhyb3cgbmV3IElucHV0VmFsaWRhdGlvbkVycm9yKFxuICAgICAgICBlcnJvckJ1aWxkZXIoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiUmVxdWlyZWQgcGFyYW1ldGVycyAnY3B1L3V0aWxpemF0aW9uJyBpcyBub3QgcHJvdmlkZWRcIixcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qge2R1cmF0aW9uLCAnY3B1L3V0aWxpemF0aW9uJzogY3B1fSA9IGlucHV0O1xuICAgIGNvbnN0IHdhdHRhZ2UgPSBjYWxjdWxhdGVXYXR0YWdlKGNwdSwgaW5zdGFuY2VUeXBlKTtcblxuICAgIHJldHVybiAod2F0dGFnZSAqIGR1cmF0aW9uKSAvIDM2MDAgLyAxMDAwO1xuICB9O1xuXG4gIGNvbnN0IGNhbGN1bGF0ZVdhdHRhZ2UgPSAoY3B1OiBudW1iZXIsIGluc3RhbmNlVHlwZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgY29uc3VtcHRpb24gPSBjb21wdXRlSW5zdGFuY2VzW2luc3RhbmNlVHlwZV0uY29uc3VtcHRpb247XG4gICAgY29uc3QgeCA9IFswLCAxMCwgNTAsIDEwMF07IC8vIEdldCB0aGUgd2F0dGFnZSBmb3IgdGhlIGluc3RhbmNlIHR5cGUuXG4gICAgY29uc3QgeTogbnVtYmVyW10gPSBbXG4gICAgICBjb25zdW1wdGlvbi5pZGxlLFxuICAgICAgY29uc3VtcHRpb24udGVuUGVyY2VudCxcbiAgICAgIGNvbnN1bXB0aW9uLmZpZnR5UGVyY2VudCxcbiAgICAgIGNvbnN1bXB0aW9uLmh1bmRyZWRQZXJjZW50LFxuICAgIF07XG4gICAgY29uc3Qgc3BsaW5lID0gbmV3IFNwbGluZSh4LCB5KTtcblxuICAgIGlmIChpbnRlcnBvbGF0aW9uID09PSBJbnRlcnBvbGF0aW9uLlNQTElORSkge1xuICAgICAgcmV0dXJuIHNwbGluZS5hdChjcHUpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxjdWxhdGVMaW5lYXJJbnRlcnBvbGF0aW9uV2F0dGFnZShjcHUsIHgsIHkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3YXR0YWdlLlxuICAgKi9cbiAgY29uc3QgY2FsY3VsYXRlTGluZWFySW50ZXJwb2xhdGlvbldhdHRhZ2UgPSAoXG4gICAgY3B1OiBudW1iZXIsXG4gICAgcG9pbnRzOiBudW1iZXJbXSxcbiAgICBjdXJ2ZTogbnVtYmVyW11cbiAgKTogbnVtYmVyID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBwb2ludHMucmVkdWNlKFxuICAgICAgKGFjYywgcG9pbnQsIGkpID0+IHtcbiAgICAgICAgaWYgKGNwdSA9PT0gcG9pbnQpIHtcbiAgICAgICAgICBhY2MuYmFzZVJhdGUgPSBjdXJ2ZVtpXTtcbiAgICAgICAgICBhY2MuYmFzZUNwdSA9IHBvaW50O1xuICAgICAgICB9IGVsc2UgaWYgKGNwdSA+IHBvaW50ICYmIGNwdSA8IHBvaW50c1tpICsgMV0pIHtcbiAgICAgICAgICBhY2MuYmFzZVJhdGUgPSBjdXJ2ZVtpXTtcbiAgICAgICAgICBhY2MuYmFzZUNwdSA9IHBvaW50O1xuICAgICAgICAgIGFjYy5yYXRpbyA9IChjdXJ2ZVtpICsgMV0gLSBjdXJ2ZVtpXSkgLyAocG9pbnRzW2kgKyAxXSAtIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHtiYXNlUmF0ZTogMCwgYmFzZUNwdTogMCwgcmF0aW86IDB9XG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHQuYmFzZVJhdGUgKyAoY3B1IC0gcmVzdWx0LmJhc2VDcHUpICogcmVzdWx0LnJhdGlvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBlbWJvZGllZCBlbWlzc2lvbnMgZm9yIGEgZ2l2ZW4gaW5wdXQuXG4gICAqXG4gICAqICBNID0gVEUgKiAoVFIvRUwpICogKFJSL1RSKVxuICAgKiAgV2hlcmU6XG4gICAqICBURSA9IFRvdGFsIEVtYm9kaWVkIEVtaXNzaW9ucywgdGhlIHN1bSBvZiBMaWZlIEN5Y2xlIEFzc2Vzc21lbnQoTENBKSBlbWlzc2lvbnMgZm9yIGFsbCBoYXJkd2FyZSBjb21wb25lbnRzXG4gICAqICBUUiA9IFRpbWUgUmVzZXJ2ZWQsIHRoZSBsZW5ndGggb2YgdGltZSB0aGUgaGFyZHdhcmUgaXMgcmVzZXJ2ZWQgZm9yIHVzZSBieSB0aGUgc29mdHdhcmVcbiAgICogIEVMID0gRXhwZWN0ZWQgTGlmZXNwYW4sIHRoZSBhbnRpY2lwYXRlZCB0aW1lIHRoYXQgdGhlIGVxdWlwbWVudCB3aWxsIGJlIGluc3RhbGxlZFxuICAgKiAgUlIgPSBSZXNvdXJjZXMgUmVzZXJ2ZWQsIHRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHJlc2VydmVkIGZvciB1c2UgYnkgdGhlIHNvZnR3YXJlLlxuICAgKiAgVFIgPSBUb3RhbCBSZXNvdXJjZXMsIHRoZSB0b3RhbCBudW1iZXIgb2YgcmVzb3VyY2VzIGF2YWlsYWJsZS5cbiAgICovXG4gIGNvbnN0IGVtYm9kaWVkRW1pc3Npb25zID0gKFxuICAgIGlucHV0OiBQbHVnaW5QYXJhbXMsXG4gICAgaW5zdGFuY2VUeXBlOiBzdHJpbmcsXG4gICAgZXhwZWN0ZWRMaWZlc3BhbjogbnVtYmVyXG4gICk6IG51bWJlciA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjb21wdXRlSW5zdGFuY2VzW2luc3RhbmNlVHlwZV07XG4gICAgY29uc3QgdG90YWxFbWlzc2lvbnMgPSBpbnN0YW5jZS5lbWJvZGllZEVtaXNzaW9uO1xuICAgIGNvbnN0IHRpbWVSZXNlcnZlZCA9IGlucHV0WydkdXJhdGlvbiddIC8gMzYwMDtcbiAgICBjb25zdCBleHBlY3RlZExpZmVzcGFuSW5TZWNvbmRzID0gZXhwZWN0ZWRMaWZlc3BhbiAvIDM2MDA7XG4gICAgY29uc3QgcmVzZXJ2ZWRSZXNvdXJjZXMgPSBpbnN0YW5jZS52Q1BVcztcbiAgICBjb25zdCB0b3RhbFJlc291cmNlcyA9IGluc3RhbmNlLm1heHZDUFVzO1xuXG4gICAgLy8gTXVsdGlwbHkgdG90YWxFbWlzc2lvbnMgYnkgMTAwMCB0byBjb252ZXJ0IGZyb20ga2dDTzJlIHRvIGdDTzJlXG4gICAgcmV0dXJuIChcbiAgICAgIHRvdGFsRW1pc3Npb25zICpcbiAgICAgIDEwMDAgKlxuICAgICAgKHRpbWVSZXNlcnZlZCAvIGV4cGVjdGVkTGlmZXNwYW5JblNlY29uZHMpICpcbiAgICAgIChyZXNlcnZlZFJlc291cmNlcyAvIHRvdGFsUmVzb3VyY2VzKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBzdGF0aWMgcGFyYW1ldGVycy5cbiAgICovXG4gIGNvbnN0IHZhbGlkYXRlSW5wdXQgPSAoaW5wdXQ6IFBsdWdpblBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHNjaGVtYSA9IHpcbiAgICAgIC5vYmplY3Qoe1xuICAgICAgICAnY2xvdWQvaW5zdGFuY2UtdHlwZSc6IHouc3RyaW5nKCksXG4gICAgICAgICdjcHUvZXhwZWN0ZWQtbGlmZXNwYW4nOiB6Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgICB9KVxuICAgICAgLnJlZmluZShwYXJhbSA9PiB7XG4gICAgICAgIHZhbGlkYXRlSW5zdGFuY2VUeXBlKHBhcmFtWydjbG91ZC9pbnN0YW5jZS10eXBlJ10pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHZhbGlkYXRlKHNjaGVtYSwgaW5wdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW4gaW5zdGFuY2UgdHlwZS5cbiAgICovXG4gIGNvbnN0IHZhbGlkYXRlSW5zdGFuY2VUeXBlID0gKGluc3RhbmNlVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgaWYgKFxuICAgICAgaW5zdGFuY2VUeXBlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICghKGluc3RhbmNlVHlwZSBpbiBjb21wdXRlSW5zdGFuY2VzKSB8fCBpbnN0YW5jZVR5cGUgPT09ICcnKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVmFsdWVFcnJvcihcbiAgICAgICAgZXJyb3JCdWlsZGVyKHtcbiAgICAgICAgICBtZXNzYWdlOiBgSW5zdGFuY2UgdHlwZSAke2luc3RhbmNlVHlwZX0gaXMgbm90IHN1cHBvcnRlZGAsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1ldGFkYXRhLFxuICAgIGV4ZWN1dGUsXG4gIH07XG59O1xuIl19