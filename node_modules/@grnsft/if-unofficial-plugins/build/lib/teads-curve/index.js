"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeadsCurve = void 0;
const typescript_cubic_spline_1 = require("typescript-cubic-spline");
const zod_1 = require("zod");
const types_1 = require("../../types");
const helpers_1 = require("../../util/helpers");
const validations_1 = require("../../util/validations");
const errors_1 = require("../../util/errors");
const { InputValidationError } = errors_1.ERRORS;
const TeadsCurve = (globalConfig) => {
    const CURVE = [0.12, 0.32, 0.75, 1.02];
    const POINTS = [0, 10, 50, 100];
    const errorBuilder = (0, helpers_1.buildErrorMessage)(exports.TeadsCurve.name);
    const metadata = {
        kind: 'execute',
    };
    /**
     * Calculate the total emissions for a list of inputs.
     */
    const execute = async (inputs) => {
        const validatedConfig = validateConfig(globalConfig || {});
        return inputs.map((input, index) => {
            const safeInput = validateInput(input);
            const inputWithConfig = Object.assign({}, input, safeInput, validatedConfig);
            const energy = calculateEnergyForInput(inputWithConfig, index);
            return {
                ...input,
                'cpu/energy': energy,
            };
        });
    };
    /**
     * Calculates the energy for a given input, taking into account allocation if available.
     */
    const calculateEnergyForInput = (input, index) => {
        const energyWithoutAllocation = calculateEnergy(input);
        const total = parseNumericField(input, 'vcpus-total', index);
        const allocated = parseNumericField(input, 'vcpus-allocated', index);
        if (allocated !== undefined && total !== undefined && total !== 0) {
            return energyWithoutAllocation * (allocated / total);
        }
        return energyWithoutAllocation;
    };
    /**
     * Calculates the energy consumption for a single input.
     * Uses a spline method on the teads cpu wattage data.
     *
     * duration is in seconds
     * wattage is in watts
     * eg: 30W x 300s = 9000 J
     * 1 Wh = 3600 J
     * 9000 J / 3600 = 2.5 Wh
     * J / 3600 = Wh
     * 2.5 Wh / 1000 = 0.0025 kWh
     * Wh / 1000 = kWh
     * (wattage * duration) / (seconds in an hour) / 1000 = kWh
     */
    const calculateEnergy = (input) => {
        const { duration, 'cpu/utilization': cpu, 'cpu/thermal-design-power': cpuThermalDesignPower, } = input;
        const spline = new typescript_cubic_spline_1.default(POINTS, CURVE);
        const wattage = input.interpolation === types_1.Interpolation.SPLINE
            ? spline.at(cpu) * cpuThermalDesignPower
            : calculateLinearInterpolationWattage(cpu, cpuThermalDesignPower);
        return (wattage * duration) / 3600 / 1000;
    };
    /**
     * Calculates the linear interpolation wattage.
     *
     * sum of base_rate + (cpu - base_cpu) * ratio = total rate of cpu usage
     * total rate * tdp = wattage
     */
    const calculateLinearInterpolationWattage = (cpu, thermalDesignPower) => {
        const result = POINTS.reduce((acc, point, i) => {
            if (cpu === point) {
                acc.baseRate = CURVE[i];
                acc.baseCpu = point;
            }
            else if (cpu > point && cpu < POINTS[i + 1]) {
                acc.baseRate = CURVE[i];
                acc.baseCpu = point;
                acc.ratio = (CURVE[i + 1] - CURVE[i]) / (POINTS[i + 1] - point);
            }
            return acc;
        }, { baseRate: 0, baseCpu: 0, ratio: 0 });
        return ((result.baseRate + (cpu - result.baseCpu) * result.ratio) *
            thermalDesignPower);
    };
    /**
     * Parse a numeric field from the input and handle type validation.
     */
    const parseNumericField = (input, field, index) => {
        if (field in input) {
            const fieldValue = input[field];
            switch (typeof fieldValue) {
                case 'string':
                    return parseFloat(fieldValue);
                case 'number':
                    return fieldValue;
                default:
                    throw new InputValidationError(errorBuilder({
                        message: `Invalid type for '${field}' in input[${index}]`,
                    }));
            }
        }
        return undefined;
    };
    /**
     * Validates config params.
     */
    const validateConfig = (config) => {
        const schema = zod_1.z.object({
            interpolation: zod_1.z.nativeEnum(types_1.Interpolation).optional(),
        });
        // Manually set default value
        const interpolation = config.interpolation ?? types_1.Interpolation.SPLINE;
        return (0, validations_1.validate)(schema, { ...config, interpolation });
    };
    /**
     * Validates parameters.
     */
    const validateInput = (input) => {
        const schema = zod_1.z.object({
            duration: zod_1.z.number().gt(0),
            'cpu/utilization': zod_1.z.number().min(0).max(100),
            'cpu/thermal-design-power': zod_1.z.number().min(1),
        });
        // Manually set default value if the property is missing.
        const cpuTDP = input['cpu/thermal-design-power'] ?? 0;
        return (0, validations_1.validate)(schema, { ...input, cpuTDP });
    };
    return {
        metadata,
        execute,
    };
};
exports.TeadsCurve = TeadsCurve;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RlYWRzLWN1cnZlL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFFQUE2QztBQUM3Qyw2QkFBc0I7QUFHdEIsdUNBQXNFO0FBRXRFLGdEQUFxRDtBQUNyRCx3REFBZ0Q7QUFDaEQsOENBQXlDO0FBRXpDLE1BQU0sRUFBQyxvQkFBb0IsRUFBQyxHQUFHLGVBQU0sQ0FBQztBQUUvQixNQUFNLFVBQVUsR0FBRyxDQUFDLFlBQTJCLEVBQW1CLEVBQUU7SUFDekUsTUFBTSxLQUFLLEdBQWEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNqRCxNQUFNLE1BQU0sR0FBYSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sWUFBWSxHQUFHLElBQUEsMkJBQWlCLEVBQUMsa0JBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV4RCxNQUFNLFFBQVEsR0FBRztRQUNmLElBQUksRUFBRSxTQUFTO0tBQ2hCLENBQUM7SUFFRjs7T0FFRztJQUNILE1BQU0sT0FBTyxHQUFHLEtBQUssRUFBRSxNQUFzQixFQUFFLEVBQUU7UUFDL0MsTUFBTSxlQUFlLEdBQUcsY0FBYyxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUMsQ0FBQztRQUUzRCxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDakMsTUFBTSxTQUFTLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3ZDLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQ25DLEVBQUUsRUFDRixLQUFLLEVBQ0wsU0FBUyxFQUNULGVBQWUsQ0FDaEIsQ0FBQztZQUNGLE1BQU0sTUFBTSxHQUFHLHVCQUF1QixDQUFDLGVBQWUsRUFBRSxLQUFL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QUFRLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDMUIsaUJBQWlCLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQzdDLDBCQUEwQixFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzlDLENBQUMsQ0FBQztRQUVILHlEQUF5RDtRQUN6RCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdEQsT0FBTyxJQUFBLHNCQUFRLEVBQXlCLE1BQU0sRUFBRSxFQUFDLEdBQUcsS0FBSyxFQUFFLE1BQU0sRUFBQyxDQUFDLENBQUM7SUFDdEUsQ0FBQyxDQUFDO0lBRUYsT0FBTztRQUNMLFFBQVE7UUFDUixPQUFPO0tBQ1IsQ0FBQztBQUNKLENBQUMsQ0FBQztBQTlLVyxRQUFBLFVBQVUsY0E4S3JCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNwbGluZSBmcm9tICd0eXBlc2NyaXB0LWN1YmljLXNwbGluZSc7XG5pbXBvcnQge3p9IGZyb20gJ3pvZCc7XG5cbmltcG9ydCB7UGx1Z2luSW50ZXJmYWNlfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7SW50ZXJwb2xhdGlvbiwgUGx1Z2luUGFyYW1zLCBDb25maWdQYXJhbXN9IGZyb20gJy4uLy4uL3R5cGVzJztcblxuaW1wb3J0IHtidWlsZEVycm9yTWVzc2FnZX0gZnJvbSAnLi4vLi4vdXRpbC9oZWxwZXJzJztcbmltcG9ydCB7dmFsaWRhdGV9IGZyb20gJy4uLy4uL3V0aWwvdmFsaWRhdGlvbnMnO1xuaW1wb3J0IHtFUlJPUlN9IGZyb20gJy4uLy4uL3V0aWwvZXJyb3JzJztcblxuY29uc3Qge0lucHV0VmFsaWRhdGlvbkVycm9yfSA9IEVSUk9SUztcblxuZXhwb3J0IGNvbnN0IFRlYWRzQ3VydmUgPSAoZ2xvYmFsQ29uZmlnPzogQ29uZmlnUGFyYW1zKTogUGx1Z2luSW50ZXJmYWNlID0+IHtcbiAgY29uc3QgQ1VSVkU6IG51bWJlcltdID0gWzAuMTIsIDAuMzIsIDAuNzUsIDEuMDJdO1xuICBjb25zdCBQT0lOVFM6IG51bWJlcltdID0gWzAsIDEwLCA1MCwgMTAwXTtcbiAgY29uc3QgZXJyb3JCdWlsZGVyID0gYnVpbGRFcnJvck1lc3NhZ2UoVGVhZHNDdXJ2ZS5uYW1lKTtcblxuICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICBraW5kOiAnZXhlY3V0ZScsXG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgdG90YWwgZW1pc3Npb25zIGZvciBhIGxpc3Qgb2YgaW5wdXRzLlxuICAgKi9cbiAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jIChpbnB1dHM6IFBsdWdpblBhcmFtc1tdKSA9PiB7XG4gICAgY29uc3QgdmFsaWRhdGVkQ29uZmlnID0gdmFsaWRhdGVDb25maWcoZ2xvYmFsQ29uZmlnIHx8IHt9KTtcblxuICAgIHJldHVybiBpbnB1dHMubWFwKChpbnB1dCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNhZmVJbnB1dCA9IHZhbGlkYXRlSW5wdXQoaW5wdXQpO1xuICAgICAgY29uc3QgaW5wdXRXaXRoQ29uZmlnID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIGlucHV0LFxuICAgICAgICBzYWZlSW5wdXQsXG4gICAgICAgIHZhbGlkYXRlZENvbmZpZ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGVuZXJneSA9IGNhbGN1bGF0ZUVuZXJneUZvcklucHV0KGlucHV0V2l0aENvbmZpZywgaW5kZXgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbnB1dCxcbiAgICAgICAgJ2NwdS9lbmVyZ3knOiBlbmVyZ3ksXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBlbmVyZ3kgZm9yIGEgZ2l2ZW4gaW5wdXQsIHRha2luZyBpbnRvIGFjY291bnQgYWxsb2NhdGlvbiBpZiBhdmFpbGFibGUuXG4gICAqL1xuICBjb25zdCBjYWxjdWxhdGVFbmVyZ3lGb3JJbnB1dCA9IChcbiAgICBpbnB1dDogUGx1Z2luUGFyYW1zLFxuICAgIGluZGV4OiBudW1iZXJcbiAgKTogbnVtYmVyID0+IHtcbiAgICBjb25zdCBlbmVyZ3lXaXRob3V0QWxsb2NhdGlvbiA9IGNhbGN1bGF0ZUVuZXJneShpbnB1dCk7XG5cbiAgICBjb25zdCB0b3RhbCA9IHBhcnNlTnVtZXJpY0ZpZWxkKGlucHV0LCAndmNwdXMtdG90YWwnLCBpbmRleCk7XG4gICAgY29uc3QgYWxsb2NhdGVkID0gcGFyc2VOdW1lcmljRmllbGQoaW5wdXQsICd2Y3B1cy1hbGxvY2F0ZWQnLCBpbmRleCk7XG5cbiAgICBpZiAoYWxsb2NhdGVkICE9PSB1bmRlZmluZWQgJiYgdG90YWwgIT09IHVuZGVmaW5lZCAmJiB0b3RhbCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGVuZXJneVdpdGhvdXRBbGxvY2F0aW9uICogKGFsbG9jYXRlZCAvIHRvdGFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5lcmd5V2l0aG91dEFsbG9jYXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGVuZXJneSBjb25zdW1wdGlvbiBmb3IgYSBzaW5nbGUgaW5wdXQuXG4gICAqIFVzZXMgYSBzcGxpbmUgbWV0aG9kIG9uIHRoZSB0ZWFkcyBjcHUgd2F0dGFnZSBkYXRhLlxuICAgKlxuICAgKiBkdXJhdGlvbiBpcyBpbiBzZWNvbmRzXG4gICAqIHdhdHRhZ2UgaXMgaW4gd2F0dHNcbiAgICogZWc6IDMwVyB4IDMwMHMgPSA5MDAwIEpcbiAgICogMSBXaCA9IDM2MDAgSlxuICAgKiA5MDAwIEogLyAzNjAwID0gMi41IFdoXG4gICAqIEogLyAzNjAwID0gV2hcbiAgICogMi41IFdoIC8gMTAwMCA9IDAuMDAyNSBrV2hcbiAgICogV2ggLyAxMDAwID0ga1doXG4gICAqICh3YXR0YWdlICogZHVyYXRpb24pIC8gKHNlY29uZHMgaW4gYW4gaG91cikgLyAxMDAwID0ga1doXG4gICAqL1xuICBjb25zdCBjYWxjdWxhdGVFbmVyZ3kgPSAoaW5wdXQ6IFBsdWdpblBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgJ2NwdS91dGlsaXphdGlvbic6IGNwdSxcbiAgICAgICdjcHUvdGhlcm1hbC1kZXNpZ24tcG93ZXInOiBjcHVUaGVybWFsRGVzaWduUG93ZXIsXG4gICAgfSA9IGlucHV0O1xuICAgIGNvbnN0IHNwbGluZTogYW55ID0gbmV3IFNwbGluZShQT0lOVFMsIENVUlZFKTtcblxuICAgIGNvbnN0IHdhdHRhZ2UgPVxuICAgICAgaW5wdXQuaW50ZXJwb2xhdGlvbiA9PT0gSW50ZXJwb2xhdGlvbi5TUExJTkVcbiAgICAgICAgPyBzcGxpbmUuYXQoY3B1KSAqIGNwdVRoZXJtYWxEZXNpZ25Qb3dlclxuICAgICAgICA6IGNhbGN1bGF0ZUxpbmVhckludGVycG9sYXRpb25XYXR0YWdlKGNwdSwgY3B1VGhlcm1hbERlc2lnblBvd2VyKTtcblxuICAgIHJldHVybiAod2F0dGFnZSAqIGR1cmF0aW9uKSAvIDM2MDAgLyAxMDAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3YXR0YWdlLlxuICAgKlxuICAgKiBzdW0gb2YgYmFzZV9yYXRlICsgKGNwdSAtIGJhc2VfY3B1KSAqIHJhdGlvID0gdG90YWwgcmF0ZSBvZiBjcHUgdXNhZ2VcbiAgICogdG90YWwgcmF0ZSAqIHRkcCA9IHdhdHRhZ2VcbiAgICovXG4gIGNvbnN0IGNhbGN1bGF0ZUxpbmVhckludGVycG9sYXRpb25XYXR0YWdlID0gKFxuICAgIGNwdTogbnVtYmVyLFxuICAgIHRoZXJtYWxEZXNpZ25Qb3dlcjogbnVtYmVyXG4gICkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFBPSU5UUy5yZWR1Y2UoXG4gICAgICAoYWNjLCBwb2ludCwgaSkgPT4ge1xuICAgICAgICBpZiAoY3B1ID09PSBwb2ludCkge1xuICAgICAgICAgIGFjYy5iYXNlUmF0ZSA9IENVUlZFW2ldO1xuICAgICAgICAgIGFjYy5iYXNlQ3B1ID0gcG9pbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY3B1ID4gcG9pbnQgJiYgY3B1IDwgUE9JTlRTW2kgKyAxXSkge1xuICAgICAgICAgIGFjYy5iYXNlUmF0ZSA9IENVUlZFW2ldO1xuICAgICAgICAgIGFjYy5iYXNlQ3B1ID0gcG9pbnQ7XG4gICAgICAgICAgYWNjLnJhdGlvID0gKENVUlZFW2kgKyAxXSAtIENVUlZFW2ldKSAvIChQT0lOVFNbaSArIDFdIC0gcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LFxuICAgICAge2Jhc2VSYXRlOiAwLCBiYXNlQ3B1OiAwLCByYXRpbzogMH1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIChyZXN1bHQuYmFzZVJhdGUgKyAoY3B1IC0gcmVzdWx0LmJhc2VDcHUpICogcmVzdWx0LnJhdGlvKSAqXG4gICAgICB0aGVybWFsRGVzaWduUG93ZXJcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIG51bWVyaWMgZmllbGQgZnJvbSB0aGUgaW5wdXQgYW5kIGhhbmRsZSB0eXBlIHZhbGlkYXRpb24uXG4gICAqL1xuICBjb25zdCBwYXJzZU51bWVyaWNGaWVsZCA9IChcbiAgICBpbnB1dDogUGx1Z2luUGFyYW1zLFxuICAgIGZpZWxkOiBzdHJpbmcsXG4gICAgaW5kZXg6IG51bWJlclxuICApOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmIChmaWVsZCBpbiBpbnB1dCkge1xuICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGlucHV0W2ZpZWxkXTtcblxuICAgICAgc3dpdGNoICh0eXBlb2YgZmllbGRWYWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGZpZWxkVmFsdWUpO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBJbnB1dFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICAgIGVycm9yQnVpbGRlcih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIHR5cGUgZm9yICcke2ZpZWxkfScgaW4gaW5wdXRbJHtpbmRleH1dYCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgY29uZmlnIHBhcmFtcy5cbiAgICovXG4gIGNvbnN0IHZhbGlkYXRlQ29uZmlnID0gKGNvbmZpZzogQ29uZmlnUGFyYW1zKSA9PiB7XG4gICAgY29uc3Qgc2NoZW1hID0gei5vYmplY3Qoe1xuICAgICAgaW50ZXJwb2xhdGlvbjogei5uYXRpdmVFbnVtKEludGVycG9sYXRpb24pLm9wdGlvbmFsKCksXG4gICAgfSk7XG5cbiAgICAvLyBNYW51YWxseSBzZXQgZGVmYXVsdCB2YWx1ZVxuICAgIGNvbnN0IGludGVycG9sYXRpb24gPSBjb25maWcuaW50ZXJwb2xhdGlvbiA/PyBJbnRlcnBvbGF0aW9uLlNQTElORTtcblxuICAgIHJldHVybiB2YWxpZGF0ZTx6LmluZmVyPHR5cGVvZiBzY2hlbWE+PihzY2hlbWEsIHsuLi5jb25maWcsIGludGVycG9sYXRpb259KTtcbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGVzIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdCB2YWxpZGF0ZUlucHV0ID0gKGlucHV0OiBQbHVnaW5QYXJhbXMpID0+IHtcbiAgICBjb25zdCBzY2hlbWEgPSB6Lm9iamVjdCh7XG4gICAgICBkdXJhdGlvbjogei5udW1iZXIoKS5ndCgwKSxcbiAgICAgICdjcHUvdXRpbGl6YXRpb24nOiB6Lm51bWJlcigpLm1pbigwKS5tYXgoMTAwKSxcbiAgICAgICdjcHUvdGhlcm1hbC1kZXNpZ24tcG93ZXInOiB6Lm51bWJlcigpLm1pbigxKSxcbiAgICB9KTtcblxuICAgIC8vIE1hbnVhbGx5IHNldCBkZWZhdWx0IHZhbHVlIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLlxuICAgIGNvbnN0IGNwdVREUCA9IGlucHV0WydjcHUvdGhlcm1hbC1kZXNpZ24tcG93ZXInXSA/PyAwO1xuXG4gICAgcmV0dXJuIHZhbGlkYXRlPHouaW5mZXI8dHlwZW9mIHNjaGVtYT4+KHNjaGVtYSwgey4uLmlucHV0LCBjcHVURFB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1ldGFkYXRhLFxuICAgIGV4ZWN1dGUsXG4gIH07XG59O1xuIl19