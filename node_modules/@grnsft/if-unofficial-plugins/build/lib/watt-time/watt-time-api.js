"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WattTimeAPI = void 0;
const dotenv = require("dotenv");
const dayjs = require("dayjs");
const axios_1 = require("axios");
const errors_1 = require("../../util/errors");
const helpers_1 = require("../../util/helpers");
const { AuthorizationError, APIRequestError } = errors_1.ERRORS;
const WattTimeAPI = () => {
    const baseUrl = 'https://api.watttime.org/v3';
    let token = '';
    const errorBuilder = (0, helpers_1.buildErrorMessage)(exports.WattTimeAPI.name);
    /**
     * Authenticates the user with the WattTime API using the provided authentication parameters.
     * If a token is not provided, attempts to authenticate with the provided username and password.
     * Updates the token and base URL for API requests upon successful authentication.
     */
    const authenticate = async () => {
        dotenv.config();
        token = process.env.WATT_TIME_TOKEN ?? '';
        if (token === '') {
            const tokenResponse = await axios_1.default.get('https://api.watttime.org/login', {
                auth: {
                    username: process.env.WATT_TIME_USERNAME || '',
                    password: process.env.WATT_TIME_PASSWORD || '',
                },
            });
            if (tokenResponse === undefined ||
                tokenResponse.data === undefined ||
                !('token' in tokenResponse.data)) {
                throw new AuthorizationError(errorBuilder({
                    message: 'Missing token in response. Invalid credentials provided',
                    scope: 'authorization',
                }));
            }
            token = tokenResponse.data.token;
        }
    };
    /**
     * Support v2 version of WattTime API.
     *
     * Fetches and sorts data from the WattTime API based on the provided parameters.
     * Throws an APIRequestError if an error occurs during the request or if the response is invalid.
     */
    const fetchAndSortData = async (params) => {
        const result = await axios_1.default
            .get('https://api2.watttime.org/v2/data', {
            params,
            headers: {
                Authorization: `Bearer ${token}`,
            },
        })
            .catch(error => {
            throw new APIRequestError(errorBuilder({
                message: `Error fetching data from WattTime API. ${JSON.stringify((error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                    error)}`,
            }));
        });
        if (result.status !== 200) {
            throw new APIRequestError(errorBuilder({
                message: `Error fetching data from WattTime API: ${JSON.stringify(result.status)}`,
            }));
        }
        if (!('data' in result) || !Array.isArray(result.data)) {
            throw new APIRequestError(errorBuilder({
                message: 'Invalid response from WattTime API',
            }));
        }
        return sortData(result.data);
    };
    /**
     * Get `signal_type` for specified access token.
     */
    const getSignalType = async (token) => {
        const result = await axios_1.default
            .get(`${baseUrl}/my-access`, {
            params: {},
            headers: {
                Authorization: `Bearer ${token}`,
            },
        })
            .catch(error => {
            throw new APIRequestError(errorBuilder({
                message: `Error fetching \`signal_type\` from WattTime API. ${JSON.stringify((error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                    error)}`,
            }));
        });
        if (!('data' in result) ||
            !Array.isArray(result.data.signal_types) ||
            result.data.signal_types.length === 0) {
            throw new APIRequestError(errorBuilder({
                message: 'Invalid response from WattTime API',
            }));
        }
        return result.data.signal_types[0].signal_type;
    };
    /**
     * Fetches and sorts data from the WattTime API based on the provided region and time period.
     * Throws an APIRequestError if an error occurs during the request or if the response is invalid.
     */
    const fetchDataWithRegion = async (params) => {
        const signalType = (await getSignalType(token)) || params.signal_type;
        Object.assign(params, { signal_type: signalType });
        const result = await axios_1.default
            .get(`${baseUrl}/forecast/historical`, {
            params,
            headers: {
                Authorization: `Bearer ${token}`,
            },
        })
            .catch(error => {
            throw new APIRequestError(errorBuilder({
                message: `Error fetching data from WattTime API. ${JSON.stringify((error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                    error)}`,
            }));
        });
        if (result.status !== 200) {
            throw new APIRequestError(errorBuilder({
                message: `Error fetching data from WattTime API: ${JSON.stringify(result.status)}`,
            }));
        }
        if (!('data' in result) || !Array.isArray(result.data.data)) {
            throw new APIRequestError(errorBuilder({
                message: 'Invalid response from WattTime API',
            }));
        }
        return simplifyAndSortData(result.data.data).flat();
    };
    const simplifyAndSortData = (data) => {
        const forecasts = data.map((item) => item.forecast);
        return sortData(forecasts);
    };
    /**
     * Sorts the data based on the 'point_time' property in ascending order.
     */
    const sortData = (data) => {
        return data.sort((a, b) => {
            return dayjs(a.point_time).unix() > dayjs(b.point_time).unix() ? 1 : -1;
        });
    };
    return {
        authenticate,
        fetchAndSortData,
        fetchDataWithRegion,
    };
};
exports.WattTimeAPI = WattTimeAPI;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2F0dC10aW1lLWFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvd2F0dC10aW1lL3dhdHQtdGltZS1hcGkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQixpQ0FBMEI7QUFFMUIsOENBQXlDO0FBQ3pDLGdEQUFxRDtBQUlyRCxNQUFNLEVBQUMsa0JBQWtCLEVBQUUsZUFBZSxFQUFDLEdBQUcsZUFBTSxDQUFDO0FBRTlDLE1BQU0sV0FBVyxHQUFHLEdBQUcsRUFBRTtJQUM5QixNQUFNLE9BQU8sR0FBRyw2QkFBNkIsQ0FBQztJQUM5QyxJQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7SUFFZixNQUFNLFlBQVksR0FBRyxJQUFBLDJCQUFpQixFQUFDLG1CQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFekQ7Ozs7T0FJRztJQUNILE1BQU0sWUFBWSxHQUFHLEtBQUssSUFBbUIsRUFBRTtRQUM3QyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFaEIsS0FBSyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxJQUFJLEVBQUUsQ0FBQztRQUUxQyxJQUFJLEtBQUssS0FBSyxFQUFFLEVBQUU7WUFDaEIsTUFBTSxhQUFhLEdBQUcsTUFBTSxlQUFLLENBQUMsR0FBRyxDQUFDLGdDQUFnQyxFQUFFO2dCQUN0RSxJQUFJLEVBQUU7b0JBQ0osUUFBUSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLElBQUksRUFBRTtvQkFDOUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLElBQUksRUFBRTtpQkFDL0M7YUFDRixDQUFDLENBQUM7WUFFSCxJQUNFLGFBQWEsS0FBSyxTQUFTO2dCQUMzQixhQUFhLENBQUMsSUFBSSxLQUFLLFNBQVM7Z0JBQ2hDLENBQUMsQ0FBQyxPQUFPLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxFQUNoQztnQkFD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Q0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMzRCxNQUFNLElBQUksZUFBZSxDQUN2QixZQUFZLENBQUM7Z0JBQ1gsT0FBTyxFQUFFLG9DQUFvQzthQUM5QyxDQUFDLENBQ0gsQ0FBQztTQUNIO1FBRUQsT0FBTyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3RELENBQUMsQ0FBQztJQUVGLE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxJQUFTLEVBQUUsRUFBRTtRQUN4QyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUN4QixDQUFDLElBQTBDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQzlELENBQUM7UUFFRixPQUFPLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM3QixDQUFDLENBQUM7SUFFRjs7T0FFRztJQUNILE1BQU0sUUFBUSxHQUFHLENBQWlDLElBQVMsRUFBRSxFQUFFO1FBQzdELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUksRUFBRSxDQUFJLEVBQUUsRUFBRTtZQUM5QixPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxRSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztJQUVGLE9BQU87UUFDTCxZQUFZO1FBQ1osZ0JBQWdCO1FBQ2hCLG1CQUFtQjtLQUNwQixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBeE1XLFFBQUEsV0FBVyxlQXdNdEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBkb3RlbnYgZnJvbSAnZG90ZW52JztcbmltcG9ydCAqIGFzIGRheWpzIGZyb20gJ2RheWpzJztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5cbmltcG9ydCB7RVJST1JTfSBmcm9tICcuLi8uLi91dGlsL2Vycm9ycyc7XG5pbXBvcnQge2J1aWxkRXJyb3JNZXNzYWdlfSBmcm9tICcuLi8uLi91dGlsL2hlbHBlcnMnO1xuXG5pbXBvcnQge1dhdHRUaW1lUGFyYW1zLCBXYXR0VGltZVJlZ2lvblBhcmFtc30gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IHtBdXRob3JpemF0aW9uRXJyb3IsIEFQSVJlcXVlc3RFcnJvcn0gPSBFUlJPUlM7XG5cbmV4cG9ydCBjb25zdCBXYXR0VGltZUFQSSA9ICgpID0+IHtcbiAgY29uc3QgYmFzZVVybCA9ICdodHRwczovL2FwaS53YXR0dGltZS5vcmcvdjMnO1xuICBsZXQgdG9rZW4gPSAnJztcblxuICBjb25zdCBlcnJvckJ1aWxkZXIgPSBidWlsZEVycm9yTWVzc2FnZShXYXR0VGltZUFQSS5uYW1lKTtcblxuICAvKipcbiAgICogQXV0aGVudGljYXRlcyB0aGUgdXNlciB3aXRoIHRoZSBXYXR0VGltZSBBUEkgdXNpbmcgdGhlIHByb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnMuXG4gICAqIElmIGEgdG9rZW4gaXMgbm90IHByb3ZpZGVkLCBhdHRlbXB0cyB0byBhdXRoZW50aWNhdGUgd2l0aCB0aGUgcHJvdmlkZWQgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAgKiBVcGRhdGVzIHRoZSB0b2tlbiBhbmQgYmFzZSBVUkwgZm9yIEFQSSByZXF1ZXN0cyB1cG9uIHN1Y2Nlc3NmdWwgYXV0aGVudGljYXRpb24uXG4gICAqL1xuICBjb25zdCBhdXRoZW50aWNhdGUgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgZG90ZW52LmNvbmZpZygpO1xuXG4gICAgdG9rZW4gPSBwcm9jZXNzLmVudi5XQVRUX1RJTUVfVE9LRU4gPz8gJyc7XG5cbiAgICBpZiAodG9rZW4gPT09ICcnKSB7XG4gICAgICBjb25zdCB0b2tlblJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KCdodHRwczovL2FwaS53YXR0dGltZS5vcmcvbG9naW4nLCB7XG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICB1c2VybmFtZTogcHJvY2Vzcy5lbnYuV0FUVF9USU1FX1VTRVJOQU1FIHx8ICcnLFxuICAgICAgICAgIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5XQVRUX1RJTUVfUEFTU1dPUkQgfHwgJycsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKFxuICAgICAgICB0b2tlblJlc3BvbnNlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgdG9rZW5SZXNwb25zZS5kYXRhID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgISgndG9rZW4nIGluIHRva2VuUmVzcG9uc2UuZGF0YSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aG9yaXphdGlvbkVycm9yKFxuICAgICAgICAgIGVycm9yQnVpbGRlcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnTWlzc2luZyB0b2tlbiBpbiByZXNwb25zZS4gSW52YWxpZCBjcmVkZW50aWFscyBwcm92aWRlZCcsXG4gICAgICAgICAgICBzY29wZTogJ2F1dGhvcml6YXRpb24nLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRva2VuID0gdG9rZW5SZXNwb25zZS5kYXRhLnRva2VuO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3VwcG9ydCB2MiB2ZXJzaW9uIG9mIFdhdHRUaW1lIEFQSS5cbiAgICpcbiAgICogRmV0Y2hlcyBhbmQgc29ydHMgZGF0YSBmcm9tIHRoZSBXYXR0VGltZSBBUEkgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuXG4gICAqIFRocm93cyBhbiBBUElSZXF1ZXN0RXJyb3IgaWYgYW4gZXJyb3Igb2NjdXJzIGR1cmluZyB0aGUgcmVxdWVzdCBvciBpZiB0aGUgcmVzcG9uc2UgaXMgaW52YWxpZC5cbiAgICovXG4gIGNvbnN0IGZldGNoQW5kU29ydERhdGEgPSBhc3luYyAocGFyYW1zOiBXYXR0VGltZVBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF4aW9zXG4gICAgICAuZ2V0KCdodHRwczovL2FwaTIud2F0dHRpbWUub3JnL3YyL2RhdGEnLCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBBUElSZXF1ZXN0RXJyb3IoXG4gICAgICAgICAgZXJyb3JCdWlsZGVyKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBFcnJvciBmZXRjaGluZyBkYXRhIGZyb20gV2F0dFRpbWUgQVBJLiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAoZXJyb3IucmVzcG9uc2UgJiZcbiAgICAgICAgICAgICAgICBlcnJvci5yZXNwb25zZS5kYXRhICYmXG4gICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UuZGF0YS5tZXNzYWdlKSB8fFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVJlcXVlc3RFcnJvcihcbiAgICAgICAgZXJyb3JCdWlsZGVyKHtcbiAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgZmV0Y2hpbmcgZGF0YSBmcm9tIFdhdHRUaW1lIEFQSTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHJlc3VsdC5zdGF0dXNcbiAgICAgICAgICApfWAsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghKCdkYXRhJyBpbiByZXN1bHQpIHx8ICFBcnJheS5pc0FycmF5KHJlc3VsdC5kYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEFQSVJlcXVlc3RFcnJvcihcbiAgICAgICAgZXJyb3JCdWlsZGVyKHtcbiAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXNwb25zZSBmcm9tIFdhdHRUaW1lIEFQSScsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzb3J0RGF0YShyZXN1bHQuZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBgc2lnbmFsX3R5cGVgIGZvciBzcGVjaWZpZWQgYWNjZXNzIHRva2VuLlxuICAgKi9cbiAgY29uc3QgZ2V0U2lnbmFsVHlwZSA9IGFzeW5jICh0b2tlbjogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXhpb3NcbiAgICAgIC5nZXQoYCR7YmFzZVVybH0vbXktYWNjZXNzYCwge1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSVJlcXVlc3RFcnJvcihcbiAgICAgICAgICBlcnJvckJ1aWxkZXIoe1xuICAgICAgICAgICAgbWVzc2FnZTogYEVycm9yIGZldGNoaW5nIFxcYHNpZ25hbF90eXBlXFxgIGZyb20gV2F0dFRpbWUgQVBJLiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAoZXJyb3IucmVzcG9uc2UgJiZcbiAgICAgICAgICAgICAgICBlcnJvci5yZXNwb25zZS5kYXRhICYmXG4gICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UuZGF0YS5tZXNzYWdlKSB8fFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKFxuICAgICAgISgnZGF0YScgaW4gcmVzdWx0KSB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkocmVzdWx0LmRhdGEuc2lnbmFsX3R5cGVzKSB8fFxuICAgICAgcmVzdWx0LmRhdGEuc2lnbmFsX3R5cGVzLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEFQSVJlcXVlc3RFcnJvcihcbiAgICAgICAgZXJyb3JCdWlsZGVyKHtcbiAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXNwb25zZSBmcm9tIFdhdHRUaW1lIEFQSScsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuZGF0YS5zaWduYWxfdHlwZXNbMF0uc2lnbmFsX3R5cGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYW5kIHNvcnRzIGRhdGEgZnJvbSB0aGUgV2F0dFRpbWUgQVBJIGJhc2VkIG9uIHRoZSBwcm92aWRlZCByZWdpb24gYW5kIHRpbWUgcGVyaW9kLlxuICAgKiBUaHJvd3MgYW4gQVBJUmVxdWVzdEVycm9yIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgdGhlIHJlcXVlc3Qgb3IgaWYgdGhlIHJlc3BvbnNlIGlzIGludmFsaWQuXG4gICAqL1xuICBjb25zdCBmZXRjaERhdGFXaXRoUmVnaW9uID0gYXN5bmMgKHBhcmFtczogV2F0dFRpbWVSZWdpb25QYXJhbXMpID0+IHtcbiAgICBjb25zdCBzaWduYWxUeXBlID0gKGF3YWl0IGdldFNpZ25hbFR5cGUodG9rZW4pKSB8fCBwYXJhbXMuc2lnbmFsX3R5cGU7XG5cbiAgICBPYmplY3QuYXNzaWduKHBhcmFtcywge3NpZ25hbF90eXBlOiBzaWduYWxUeXBlfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBheGlvc1xuICAgICAgLmdldChgJHtiYXNlVXJsfS9mb3JlY2FzdC9oaXN0b3JpY2FsYCwge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgQVBJUmVxdWVzdEVycm9yKFxuICAgICAgICAgIGVycm9yQnVpbGRlcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgZmV0Y2hpbmcgZGF0YSBmcm9tIFdhdHRUaW1lIEFQSS4gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgKGVycm9yLnJlc3BvbnNlICYmXG4gICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UuZGF0YSAmJlxuICAgICAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlLmRhdGEubWVzc2FnZSkgfHxcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKX1gLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgIGlmIChyZXN1bHQuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBBUElSZXF1ZXN0RXJyb3IoXG4gICAgICAgIGVycm9yQnVpbGRlcih7XG4gICAgICAgICAgbWVzc2FnZTogYEVycm9yIGZldGNoaW5nIGRhdGEgZnJvbSBXYXR0VGltZSBBUEk6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICByZXN1bHQuc3RhdHVzXG4gICAgICAgICAgKX1gLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoISgnZGF0YScgaW4gcmVzdWx0KSB8fCAhQXJyYXkuaXNBcnJheShyZXN1bHQuZGF0YS5kYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEFQSVJlcXVlc3RFcnJvcihcbiAgICAgICAgZXJyb3JCdWlsZGVyKHtcbiAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXNwb25zZSBmcm9tIFdhdHRUaW1lIEFQSScsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzaW1wbGlmeUFuZFNvcnREYXRhKHJlc3VsdC5kYXRhLmRhdGEpLmZsYXQoKTtcbiAgfTtcblxuICBjb25zdCBzaW1wbGlmeUFuZFNvcnREYXRhID0gKGRhdGE6IGFueSkgPT4ge1xuICAgIGNvbnN0IGZvcmVjYXN0cyA9IGRhdGEubWFwKFxuICAgICAgKGl0ZW06IHtmb3JlY2FzdDogW107IGdlbmVyYXRlZF9hdDogc3RyaW5nfSkgPT4gaXRlbS5mb3JlY2FzdFxuICAgICk7XG5cbiAgICByZXR1cm4gc29ydERhdGEoZm9yZWNhc3RzKTtcbiAgfTtcblxuICAvKipcbiAgICogU29ydHMgdGhlIGRhdGEgYmFzZWQgb24gdGhlICdwb2ludF90aW1lJyBwcm9wZXJ0eSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBjb25zdCBzb3J0RGF0YSA9IDxUIGV4dGVuZHMge3BvaW50X3RpbWU6IHN0cmluZ30+KGRhdGE6IFRbXSkgPT4ge1xuICAgIHJldHVybiBkYXRhLnNvcnQoKGE6IFQsIGI6IFQpID0+IHtcbiAgICAgIHJldHVybiBkYXlqcyhhLnBvaW50X3RpbWUpLnVuaXgoKSA+IGRheWpzKGIucG9pbnRfdGltZSkudW5peCgpID8gMSA6IC0xO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYXV0aGVudGljYXRlLFxuICAgIGZldGNoQW5kU29ydERhdGEsXG4gICAgZmV0Y2hEYXRhV2l0aFJlZ2lvbixcbiAgfTtcbn07XG4iXX0=