"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudCarbonFootprint = void 0;
const AWSInstanceTypes_1 = require("@cloud-carbon-footprint/aws/dist/lib/AWSInstanceTypes");
const typescript_cubic_spline_1 = require("typescript-cubic-spline");
const zod_1 = require("zod");
const common_1 = require("../../types/common");
const validations_1 = require("../../util/validations");
const helpers_1 = require("../../util/helpers");
const errors_1 = require("../../util/errors");
const AWS_INSTANCES = require("./aws-instances.json");
const GCP_INSTANCES = require("./gcp-instances.json");
const AZURE_INSTANCES = require("./azure-instances.json");
const GCP_USE = require("./gcp-use.json");
const AWS_USE = require("./aws-use.json");
const AZURE_USE = require("./azure-use.json");
const GCP_EMBODIED = require("./gcp-embodied.json");
const AWS_EMBODIED = require("./aws-embodied.json");
const AZURE_EMBODIED = require("./azure-embodied.json");
const { UnsupportedValueError } = errors_1.ERRORS;
const CloudCarbonFootprint = (globalConfig) => {
    const metadata = { kind: 'execute' };
    const computeInstances = {};
    const instanceUsage = {
        gcp: {},
        aws: {},
        azure: {},
    };
    const SUPPORTED_VENDORS = ['aws', 'gcp', 'azure'];
    const deafultExpectedLifespan = 4;
    const errorBuilder = (0, helpers_1.buildErrorMessage)(exports.CloudCarbonFootprint.name);
    /**
     * Calculate the total emissions for inputs.
     */
    const execute = async (inputs) => {
        standardizeInstanceMetrics();
        return inputs.map(input => {
            const mergedWithConfig = Object.assign({}, input, globalConfig);
            const validatedInputWithConfig = Object.assign({}, { interpolation: mergedWithConfig.interpolation || common_1.Interpolation.LINEAR }, validateInputWithConfig(mergedWithConfig));
            return {
                ...input,
                energy: calculateEnergy(validatedInputWithConfig),
                'carbon-embodied': embodiedEmissions(validatedInputWithConfig),
            };
        });
    };
    /**
     * Validates the interpolation method for AWS cloud/vendor.
     */
    const validateInterpolationForAws = (interpolation, cloudVendor) => {
        if (interpolation && cloudVendor !== 'aws') {
            throw new UnsupportedValueError(errorBuilder({
                message: `Interpolation ${interpolation} method is not supported`,
            }));
        }
        return true;
    };
    /**
     * Validates the instance type for a specified cloud/vendor.
     */
    const validateInstanceTypeForVendor = (instanceType, cloudVendor) => {
        if (!(instanceType in computeInstances[cloudVendor])) {
            throw new UnsupportedValueError(errorBuilder({
                message: `Instance type ${instanceType} is not supported`,
            }));
        }
        return true;
    };
    /**
     * Validates single input fields.
     */
    const validateInputWithConfig = (params) => {
        const errorMessageForVendor = `Only ${SUPPORTED_VENDORS} is currently supported`;
        const errorMessageForInterpolation = `Only ${common_1.Interpolation} is currently supported`;
        const schema = zod_1.z
            .object({
            duration: zod_1.z.number(),
            'cpu/utilization': zod_1.z.number(),
            'cloud/instance-type': zod_1.z.string(),
            'cloud/vendor': zod_1.z.enum(SUPPORTED_VENDORS, {
                required_error: errorMessageForVendor,
            }),
            'cpu/expected-lifespan': zod_1.z.number().optional(),
            interpolation: zod_1.z
                .nativeEnum(common_1.Interpolation, {
                required_error: errorMessageForInterpolation,
            })
                .optional(),
        })
            .refine(param => {
            validateInterpolationForAws(param.interpolation, param['cloud/vendor']);
            validateInstanceTypeForVendor(param['cloud/instance-type'], param['cloud/vendor']);
            return true;
        }, {
            message: '`duration`, `cpu/utilization`, `cloud/instance-type`, and `cloud/vendor` should be present in the input',
        });
        return (0, validations_1.validate)(schema, params);
    };
    /**
     * Calculates the energy consumption for a single input
     * (wattage * duration) / (seconds in an hour) / 1000 = kWh
     */
    const calculateEnergy = (input) => {
        const { duration, 'cpu/utilization': cpu, 'cloud/instance-type': instanceType, 'cloud/vendor': cloudVendor, } = input;
        const wattage = cloudVendor === 'aws' && input.interpolation === 'spline'
            ? getAWSSplineWattage(cpu, instanceType)
            : getLinerInterpolationWattage(cpu, input);
        return (wattage * duration) / 3600 / 1000;
    };
    /**
     * Uses a spline method for AWS to get wattages.
     */
    const getAWSSplineWattage = (cpu, instanceType) => {
        const consumption = computeInstances['aws'][instanceType].consumption;
        const x = [0, 10, 50, 100];
        const y = [
            consumption.idle,
            consumption.tenPercent,
            consumption.fiftyPercent,
            consumption.hundredPercent,
        ];
        const spline = new typescript_cubic_spline_1.default(x, y);
        return spline.at(cpu);
    };
    /**
     *  Gets Liner interpolation wattages for GCP and Azure.
     */
    const getLinerInterpolationWattage = (cpu, input) => {
        const { 'cloud/vendor': cloudVendor, 'cloud/instance-type': instanceType } = input;
        const idle = computeInstances[cloudVendor][instanceType].consumption.minWatts;
        const max = computeInstances[cloudVendor][instanceType].consumption.maxWatts;
        return idle + (max - idle) * (cpu / 100);
    };
    /**
     * Standardize the instance metrics for all the vendors.
     * Maps the instance metrics to a standard format (min, max, idle, 10%, 50%, 100%) for all the vendors.
     */
    const standardizeInstanceMetrics = () => {
        initializeComputeInstances();
        calculateAverage('gcp', GCP_USE);
        calculateAverage('azure', AZURE_USE);
        calculateAverage('aws', AWS_USE);
        processInstances(AWS_INSTANCES, 'aws', 'Instance type', 'Platform Total Number of vCPU');
        processInstances(GCP_INSTANCES, 'gcp', 'Machine type', 'Platform vCPUs (highest vCPU possible)');
        processInstances(AZURE_INSTANCES, 'azure', 'Virtual Machine', 'Platform vCPUs (highest vCPU possible)');
        processEmbodiedEmissions(AWS_EMBODIED, 'aws');
        processEmbodiedEmissions(GCP_EMBODIED, 'gcp');
        processEmbodiedEmissions(AZURE_EMBODIED, 'azure');
    };
    /**
     * Initializes instances.
     */
    const initializeComputeInstances = () => {
        computeInstances['aws'] = {};
        computeInstances['gcp'] = {};
        computeInstances['azure'] = {};
    };
    /**
     * Calculates average of all instances.
     */
    const calculateAverage = (cloudVendor, instanceList) => {
        const { totalMin, totalMax, count } = instanceList.reduce((accumulator, instance) => {
            instanceUsage[cloudVendor][instance['Architecture']] = instance;
            accumulator.totalMin += parseFloat(instance['Min Watts']);
            accumulator.totalMax += parseFloat(instance['Max Watts']);
            accumulator.count += 1.0;
            return accumulator;
        }, { totalMin: 0.0, totalMax: 0.0, count: 0.0 });
        instanceUsage[cloudVendor]['Average'] = {
            'Min Watts': totalMin / count,
            'Max Watts': totalMax / count,
            Architecture: 'Average',
        };
    };
    /**
     * Resolves differences in AWS instance architecture strings.
     * Modifies the input architecture string based on predefined rules.
     * Validates the resolved architecture using the validateAwsArchitecture method.
     */
    const resolveAwsArchitecture = (architecture) => {
        const modifyArchitecture = {
            'AMD ': () => {
                architecture = architecture.substring(4);
            },
            Skylake: () => {
                architecture = 'Sky Lake';
            },
            Graviton: () => {
                architecture = architecture.includes('2') ? 'Graviton2' : 'Graviton';
            },
            Unknown: () => {
                architecture = 'Average';
            },
        };
        Object.keys(modifyArchitecture).forEach(key => {
            if (architecture.includes(key)) {
                modifyArchitecture[key]();
            }
        });
        validateAwsArchitecture(architecture);
        return architecture;
    };
    /**
     * Validates the AWS instance architecture against a predefined set of supported architectures.
     */
    const validateAwsArchitecture = (architecture) => {
        if (!(architecture in instanceUsage['aws'])) {
            throw new UnsupportedValueError(errorBuilder({
                message: `Architecture '${architecture}' is not supported`,
            }));
        }
    };
    /**
     * Calculates the embodied emissions for a given input.
     * Multiply totalEmissions by 1000 to convert from kgCO2e to gCO2e
     * M = TE * (TR/EL) * (RR/TR)
     * Where:
     * TE = Total Embodied Emissions, the sum of Life Cycle Assessment(LCA) emissions for all hardware components
     * TR = Time Reserved, the length of time the hardware is reserved for use by the software
     * EL = Expected Lifespan, the anticipated time that the equipment will be installed
     * RR = Resources Reserved, the number of resources reserved for use by the software.
     * TR = Total Resources, the total number of resources available.
     */
    const embodiedEmissions = (input) => {
        const { 'cloud/vendor': cloudVendor, 'cloud/instance-type': instanceType, 'cpu/expected-lifespan': expectedLifespan, duration, } = input;
        const durationInHours = duration / 3600;
        const instance = computeInstances[cloudVendor][instanceType];
        const totalEmissions = instance.embodiedEmission;
        const expectedLifespanInHours = 8760 * (expectedLifespan || deafultExpectedLifespan);
        const reservedResources = instance.vCPUs;
        const totalResources = instance.maxvCPUs;
        return (totalEmissions *
            1000 *
            (durationInHours / expectedLifespanInHours) *
            (reservedResources / totalResources));
    };
    /**
     * Processes a list of instances, calculates their consumption, and stores the standardized information in the computeInstances object.
     */
    const processInstances = (instances, cloudVendor, type, maxvCPUs) => {
        instances.forEach((instance) => {
            const vCPU = cloudVendor === 'aws' ? 'Instance vCPU' : 'Instance vCPUs';
            const cpus = parseInt(instance[vCPU], 10);
            const consumption = cloudVendor === 'aws'
                ? calculateAwsConsumption(instance, cpus)
                : calculateConsumption(instance, cloudVendor, cpus);
            computeInstances[cloudVendor][instance[type]] = {
                name: instance[type],
                vCPUs: cpus,
                consumption,
                maxvCPUs: parseInt(instance[maxvCPUs], 10),
            };
        });
    };
    /**
     * Retrieves the list of architectures for a given instance based on the INSTANCE_TYPE_COMPUTE_PROCESSOR_MAPPING.
     */
    const getInstanceArchitectures = (instance) => {
        const architectures = AWSInstanceTypes_1.INSTANCE_TYPE_COMPUTE_PROCESSOR_MAPPING[instance['Instance type']] ?? ['Average'];
        return architectures.map((architecture) => resolveAwsArchitecture(architecture));
    };
    /**
     * Calculates the average minimum and maximum watts consumption for AWS instances based on the provided architectures.
     */
    const calculateAwsAverageWatts = (architectures) => {
        const awsInstance = instanceUsage['aws'];
        const { minWatts, maxWatts, count } = architectures.reduce((accumulator, architecture) => {
            accumulator.minWatts += awsInstance[architecture]['Min Watts'];
            accumulator.maxWatts += awsInstance[architecture]['Max Watts'];
            accumulator.count += 1;
            return accumulator;
        }, { minWatts: 0.0, maxWatts: 0.0, count: 0 });
        return {
            minWatts: minWatts / count,
            maxWatts: maxWatts / count,
        };
    };
    /**
     * Calculates the consumption metrics (idle, 10%, 50%, 100%, minWatts, maxWatts) for a given compute instance.cv
     */
    const calculateConsumption = (instance, cloudVendor, cpus) => {
        const architecture = instance['Microarchitecture'] in instanceUsage[cloudVendor]
            ? instance['Microarchitecture']
            : 'Average';
        return {
            idle: 0,
            tenPercent: 0,
            fiftyPercent: 0,
            hundredPercent: 0,
            minWatts: instanceUsage[cloudVendor][architecture]['Min Watts'] * cpus,
            maxWatts: instanceUsage[cloudVendor][architecture]['Max Watts'] * cpus,
        };
    };
    /**
     * Calculates the consumption metrics (idle, 10%, 50%, 100%, minWatts, maxWatts) for a given compute instance.
     */
    const calculateAwsConsumption = (instance, cpus) => {
        const architectures = getInstanceArchitectures(instance);
        const { minWatts, maxWatts } = calculateAwsAverageWatts(architectures);
        return {
            idle: getParsedInstanceMetric(instance['Instance @ Idle']),
            tenPercent: getParsedInstanceMetric(instance['Instance @ 10%']),
            fiftyPercent: getParsedInstanceMetric(instance['Instance @ 50%']),
            hundredPercent: getParsedInstanceMetric(instance['Instance @ 100%']),
            minWatts: minWatts * cpus,
            maxWatts: maxWatts * cpus,
        };
    };
    /**
     * Parses a metric value to a floating-point number.
     */
    const getParsedInstanceMetric = (metric) => {
        return parseFloat(metric.replace(',', '.'));
    };
    /**
     * Processes and assigns embodied emissions data to compute instances for a specific cloud/vendor.
     */
    const processEmbodiedEmissions = (embodiedList, cloudVendor) => {
        embodiedList.forEach((instance) => {
            computeInstances[cloudVendor][instance['type']].embodiedEmission =
                instance['total'];
        });
    };
    return {
        metadata,
        execute,
    };
};
exports.CloudCarbonFootprint = CloudCarbonFootprint;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2NjZi9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw0RkFBOEc7QUFFOUcscUVBQTZDO0FBQzdDLDZCQUFzQjtBQUd0QiwrQ0FNNEI7QUFFNUIsd0RBQWdEO0FBQ2hELGdEQUFxRDtBQUNyRCw4Q0FBeUM7QUFFekMsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCwwREFBMEQ7QUFDMUQsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQyw4Q0FBOEM7QUFDOUMsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCx3REFBd0Q7QUFFeEQsTUFBTSxFQUFDLHFCQUFxQixFQUFDLEdBQUcsZUFBTSxDQUFDO0FBRWhDLE1BQU0sb0JBQW9CLEdBQUcsQ0FDbEMsWUFBMkIsRUFDVixFQUFFO0lBQ25CLE1BQU0sUUFBUSxHQUFHLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxDQUFDO0lBQ25DLE1BQU0sZ0JBQWdCLEdBQW9ELEVBQUUsQ0FBQztJQUU3RSxNQUFNLGFBQWEsR0FBaUI7UUFDbEMsR0FBRyxFQUFFLEVBQUU7UUFDUCxHQUFHLEVBQUUsRUFBRTtRQUNQLEtBQUssRUFBRSxFQUFFO0tBQ1YsQ0FBQztJQUNGLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBVSxDQUFDO0lBQzNELE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLE1BQU0sWUFBWSxHQUFHLElBQUEsMkJBQWlCLEVBQUMsNEJBQW9CLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFbEU7O09BRUc7SUFDSCxNQUFNLE9BQU8sR0FBRyxLQUFLLEVBQUUsTUFBc0IsRUFBRSxFQUFFO1FBQy9DLDBCQUEwQixFQUFFLENBQUM7UUFFN0IsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3hCLE1BQU0sZ0JBQWdCLEdBQUcs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QUFDLENBQUM7WUFDMUQsVUFBVSxFQUFFLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQy9ELFlBQVksRUFBRSx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUNqRSxjQUFjLEVBQUUsdUJBQXVCLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFDcEUsUUFBUSxFQUFFLFFBQVEsR0FBRyxJQUFJO1lBQ3pCLFFBQVEsRUFBRSxRQUFRLEdBQUcsSUFBSTtTQUMxQixDQUFDO0lBQ0osQ0FBQyxDQUFDO0lBRUY7O09BRUc7SUFDSCxNQUFNLHVCQUF1QixHQUFHLENBQUMsTUFBYyxFQUFFLEVBQUU7UUFDakQsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5QyxDQUFDLENBQUM7SUFFRjs7T0FFRztJQUNILE1BQU0sd0JBQXdCLEdBQUcsQ0FDL0IsWUFBNEIsRUFDNUIsV0FBbUIsRUFDbkIsRUFBRTtRQUNGLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFzQixFQUFFLEVBQUU7WUFDOUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsZ0JBQWdCO2dCQUM5RCxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7SUFFRixPQUFPO1FBQ0wsUUFBUTtRQUNSLE9BQU87S0FDUixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBNWJXLFFBQUEsb0JBQW9CLHdCQTRiL0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0lOU1RBTkNFX1RZUEVfQ09NUFVURV9QUk9DRVNTT1JfTUFQUElOR30gZnJvbSAnQGNsb3VkLWNhcmJvbi1mb290cHJpbnQvYXdzL2Rpc3QvbGliL0FXU0luc3RhbmNlVHlwZXMnO1xuXG5pbXBvcnQgU3BsaW5lIGZyb20gJ3R5cGVzY3JpcHQtY3ViaWMtc3BsaW5lJztcbmltcG9ydCB7en0gZnJvbSAnem9kJztcblxuaW1wb3J0IHtQbHVnaW5JbnRlcmZhY2V9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtcbiAgSW50ZXJwb2xhdGlvbixcbiAgS2V5VmFsdWVQYWlyLFxuICBQbHVnaW5QYXJhbXMsXG4gIENvbXB1dGVJbnN0YW5jZSxcbiAgQ29uZmlnUGFyYW1zLFxufSBmcm9tICcuLi8uLi90eXBlcy9jb21tb24nO1xuXG5pbXBvcnQge3ZhbGlkYXRlfSBmcm9tICcuLi8uLi91dGlsL3ZhbGlkYXRpb25zJztcbmltcG9ydCB7YnVpbGRFcnJvck1lc3NhZ2V9IGZyb20gJy4uLy4uL3V0aWwvaGVscGVycyc7XG5pbXBvcnQge0VSUk9SU30gZnJvbSAnLi4vLi4vdXRpbC9lcnJvcnMnO1xuXG5pbXBvcnQgKiBhcyBBV1NfSU5TVEFOQ0VTIGZyb20gJy4vYXdzLWluc3RhbmNlcy5qc29uJztcbmltcG9ydCAqIGFzIEdDUF9JTlNUQU5DRVMgZnJvbSAnLi9nY3AtaW5zdGFuY2VzLmpzb24nO1xuaW1wb3J0ICogYXMgQVpVUkVfSU5TVEFOQ0VTIGZyb20gJy4vYXp1cmUtaW5zdGFuY2VzLmpzb24nO1xuaW1wb3J0ICogYXMgR0NQX1VTRSBmcm9tICcuL2djcC11c2UuanNvbic7XG5pbXBvcnQgKiBhcyBBV1NfVVNFIGZyb20gJy4vYXdzLXVzZS5qc29uJztcbmltcG9ydCAqIGFzIEFaVVJFX1VTRSBmcm9tICcuL2F6dXJlLXVzZS5qc29uJztcbmltcG9ydCAqIGFzIEdDUF9FTUJPRElFRCBmcm9tICcuL2djcC1lbWJvZGllZC5qc29uJztcbmltcG9ydCAqIGFzIEFXU19FTUJPRElFRCBmcm9tICcuL2F3cy1lbWJvZGllZC5qc29uJztcbmltcG9ydCAqIGFzIEFaVVJFX0VNQk9ESUVEIGZyb20gJy4vYXp1cmUtZW1ib2RpZWQuanNvbic7XG5cbmNvbnN0IHtVbnN1cHBvcnRlZFZhbHVlRXJyb3J9ID0gRVJST1JTO1xuXG5leHBvcnQgY29uc3QgQ2xvdWRDYXJib25Gb290cHJpbnQgPSAoXG4gIGdsb2JhbENvbmZpZz86IENvbmZpZ1BhcmFtc1xuKTogUGx1Z2luSW50ZXJmYWNlID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSB7a2luZDogJ2V4ZWN1dGUnfTtcbiAgY29uc3QgY29tcHV0ZUluc3RhbmNlczogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgQ29tcHV0ZUluc3RhbmNlPj4gPSB7fTtcblxuICBjb25zdCBpbnN0YW5jZVVzYWdlOiBLZXlWYWx1ZVBhaXIgPSB7XG4gICAgZ2NwOiB7fSxcbiAgICBhd3M6IHt9LFxuICAgIGF6dXJlOiB7fSxcbiAgfTtcbiAgY29uc3QgU1VQUE9SVEVEX1ZFTkRPUlMgPSBbJ2F3cycsICdnY3AnLCAnYXp1cmUnXSBhcyBjb25zdDtcbiAgY29uc3QgZGVhZnVsdEV4cGVjdGVkTGlmZXNwYW4gPSA0O1xuICBjb25zdCBlcnJvckJ1aWxkZXIgPSBidWlsZEVycm9yTWVzc2FnZShDbG91ZENhcmJvbkZvb3RwcmludC5uYW1lKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB0b3RhbCBlbWlzc2lvbnMgZm9yIGlucHV0cy5cbiAgICovXG4gIGNvbnN0IGV4ZWN1dGUgPSBhc3luYyAoaW5wdXRzOiBQbHVnaW5QYXJhbXNbXSkgPT4ge1xuICAgIHN0YW5kYXJkaXplSW5zdGFuY2VNZXRyaWNzKCk7XG5cbiAgICByZXR1cm4gaW5wdXRzLm1hcChpbnB1dCA9PiB7XG4gICAgICBjb25zdCBtZXJnZWRXaXRoQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgaW5wdXQsIGdsb2JhbENvbmZpZyk7XG4gICAgICBjb25zdCB2YWxpZGF0ZWRJbnB1dFdpdGhDb25maWcgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAge2ludGVycG9sYXRpb246IG1lcmdlZFdpdGhDb25maWcuaW50ZXJwb2xhdGlvbiB8fCBJbnRlcnBvbGF0aW9uLkxJTkVBUn0sXG4gICAgICAgIHZhbGlkYXRlSW5wdXRXaXRoQ29uZmlnKG1lcmdlZFdpdGhDb25maWcpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbnB1dCxcbiAgICAgICAgZW5lcmd5OiBjYWxjdWxhdGVFbmVyZ3kodmFsaWRhdGVkSW5wdXRXaXRoQ29uZmlnKSxcbiAgICAgICAgJ2NhcmJvbi1lbWJvZGllZCc6IGVtYm9kaWVkRW1pc3Npb25zKHZhbGlkYXRlZElucHV0V2l0aENvbmZpZyksXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGludGVycG9sYXRpb24gbWV0aG9kIGZvciBBV1MgY2xvdWQvdmVuZG9yLlxuICAgKi9cbiAgY29uc3QgdmFsaWRhdGVJbnRlcnBvbGF0aW9uRm9yQXdzID0gKFxuICAgIGludGVycG9sYXRpb246IEludGVycG9sYXRpb24gfCB1bmRlZmluZWQsXG4gICAgY2xvdWRWZW5kb3I6IHN0cmluZ1xuICApID0+IHtcbiAgICBpZiAoaW50ZXJwb2xhdGlvbiAmJiBjbG91ZFZlbmRvciAhPT0gJ2F3cycpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFZhbHVlRXJyb3IoXG4gICAgICAgIGVycm9yQnVpbGRlcih7XG4gICAgICAgICAgbWVzc2FnZTogYEludGVycG9sYXRpb24gJHtpbnRlcnBvbGF0aW9ufSBtZXRob2QgaXMgbm90IHN1cHBvcnRlZGAsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGluc3RhbmNlIHR5cGUgZm9yIGEgc3BlY2lmaWVkIGNsb3VkL3ZlbmRvci5cbiAgICovXG4gIGNvbnN0IHZhbGlkYXRlSW5zdGFuY2VUeXBlRm9yVmVuZG9yID0gKFxuICAgIGluc3RhbmNlVHlwZTogc3RyaW5nLFxuICAgIGNsb3VkVmVuZG9yOiBzdHJpbmdcbiAgKSA9PiB7XG4gICAgaWYgKCEoaW5zdGFuY2VUeXBlIGluIGNvbXB1dGVJbnN0YW5jZXNbY2xvdWRWZW5kb3JdKSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVmFsdWVFcnJvcihcbiAgICAgICAgZXJyb3JCdWlsZGVyKHtcbiAgICAgICAgICBtZXNzYWdlOiBgSW5zdGFuY2UgdHlwZSAke2luc3RhbmNlVHlwZX0gaXMgbm90IHN1cHBvcnRlZGAsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGVzIHNpbmdsZSBpbnB1dCBmaWVsZHMuXG4gICAqL1xuICBjb25zdCB2YWxpZGF0ZUlucHV0V2l0aENvbmZpZyA9IChwYXJhbXM6IFBsdWdpblBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZUZvclZlbmRvciA9IGBPbmx5ICR7U1VQUE9SVEVEX1ZFTkRPUlN9IGlzIGN1cnJlbnRseSBzdXBwb3J0ZWRgO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZUZvckludGVycG9sYXRpb24gPSBgT25seSAke0ludGVycG9sYXRpb259IGlzIGN1cnJlbnRseSBzdXBwb3J0ZWRgO1xuXG4gICAgY29uc3Qgc2NoZW1hID0gelxuICAgICAgLm9iamVjdCh7XG4gICAgICAgIGR1cmF0aW9uOiB6Lm51bWJlcigpLFxuICAgICAgICAnY3B1L3V0aWxpemF0aW9uJzogei5udW1iZXIoKSxcbiAgICAgICAgJ2Nsb3VkL2luc3RhbmNlLXR5cGUnOiB6LnN0cmluZygpLFxuICAgICAgICAnY2xvdWQvdmVuZG9yJzogei5lbnVtKFNVUFBPUlRFRF9WRU5ET1JTLCB7XG4gICAgICAgICAgcmVxdWlyZWRfZXJyb3I6IGVycm9yTWVzc2FnZUZvclZlbmRvcixcbiAgICAgICAgfSksXG4gICAgICAgICdjcHUvZXhwZWN0ZWQtbGlmZXNwYW4nOiB6Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgICAgIGludGVycG9sYXRpb246IHpcbiAgICAgICAgICAubmF0aXZlRW51bShJbnRlcnBvbGF0aW9uLCB7XG4gICAgICAgICAgICByZXF1aXJlZF9lcnJvcjogZXJyb3JNZXNzYWdlRm9ySW50ZXJwb2xhdGlvbixcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb25hbCgpLFxuICAgICAgfSlcbiAgICAgIC5yZWZpbmUoXG4gICAgICAgIHBhcmFtID0+IHtcbiAgICAgICAgICB2YWxpZGF0ZUludGVycG9sYXRpb25Gb3JBd3MoXG4gICAgICAgICAgICBwYXJhbS5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgcGFyYW1bJ2Nsb3VkL3ZlbmRvciddXG4gICAgICAgICAgKTtcbiAgICAgICAgICB2YWxpZGF0ZUluc3RhbmNlVHlwZUZvclZlbmRvcihcbiAgICAgICAgICAgIHBhcmFtWydjbG91ZC9pbnN0YW5jZS10eXBlJ10sXG4gICAgICAgICAgICBwYXJhbVsnY2xvdWQvdmVuZG9yJ11cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ2BkdXJhdGlvbmAsIGBjcHUvdXRpbGl6YXRpb25gLCBgY2xvdWQvaW5zdGFuY2UtdHlwZWAsIGFuZCBgY2xvdWQvdmVuZG9yYCBzaG91bGQgYmUgcHJlc2VudCBpbiB0aGUgaW5wdXQnLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgcmV0dXJuIHZhbGlkYXRlPHouaW5mZXI8dHlwZW9mIHNjaGVtYT4+KHNjaGVtYSwgcGFyYW1zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZW5lcmd5IGNvbnN1bXB0aW9uIGZvciBhIHNpbmdsZSBpbnB1dFxuICAgKiAod2F0dGFnZSAqIGR1cmF0aW9uKSAvIChzZWNvbmRzIGluIGFuIGhvdXIpIC8gMTAwMCA9IGtXaFxuICAgKi9cbiAgY29uc3QgY2FsY3VsYXRlRW5lcmd5ID0gKGlucHV0OiBQbHVnaW5QYXJhbXMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkdXJhdGlvbixcbiAgICAgICdjcHUvdXRpbGl6YXRpb24nOiBjcHUsXG4gICAgICAnY2xvdWQvaW5zdGFuY2UtdHlwZSc6IGluc3RhbmNlVHlwZSxcbiAgICAgICdjbG91ZC92ZW5kb3InOiBjbG91ZFZlbmRvcixcbiAgICB9ID0gaW5wdXQ7XG5cbiAgICBjb25zdCB3YXR0YWdlID1cbiAgICAgIGNsb3VkVmVuZG9yID09PSAnYXdzJyAmJiBpbnB1dC5pbnRlcnBvbGF0aW9uID09PSAnc3BsaW5lJ1xuICAgICAgICA/IGdldEFXU1NwbGluZVdhdHRhZ2UoY3B1LCBpbnN0YW5jZVR5cGUpXG4gICAgICAgIDogZ2V0TGluZXJJbnRlcnBvbGF0aW9uV2F0dGFnZShjcHUsIGlucHV0KTtcblxuICAgIHJldHVybiAod2F0dGFnZSAqIGR1cmF0aW9uKSAvIDM2MDAgLyAxMDAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVc2VzIGEgc3BsaW5lIG1ldGhvZCBmb3IgQVdTIHRvIGdldCB3YXR0YWdlcy5cbiAgICovXG4gIGNvbnN0IGdldEFXU1NwbGluZVdhdHRhZ2UgPSAoY3B1OiBudW1iZXIsIGluc3RhbmNlVHlwZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgY29uc3VtcHRpb24gPSBjb21wdXRlSW5zdGFuY2VzWydhd3MnXVtpbnN0YW5jZVR5cGVdLmNvbnN1bXB0aW9uO1xuICAgIGNvbnN0IHggPSBbMCwgMTAsIDUwLCAxMDBdO1xuICAgIGNvbnN0IHkgPSBbXG4gICAgICBjb25zdW1wdGlvbi5pZGxlLFxuICAgICAgY29uc3VtcHRpb24udGVuUGVyY2VudCxcbiAgICAgIGNvbnN1bXB0aW9uLmZpZnR5UGVyY2VudCxcbiAgICAgIGNvbnN1bXB0aW9uLmh1bmRyZWRQZXJjZW50LFxuICAgIF07XG5cbiAgICBjb25zdCBzcGxpbmUgPSBuZXcgU3BsaW5lKHgsIHkpO1xuXG4gICAgcmV0dXJuIHNwbGluZS5hdChjcHUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgR2V0cyBMaW5lciBpbnRlcnBvbGF0aW9uIHdhdHRhZ2VzIGZvciBHQ1AgYW5kIEF6dXJlLlxuICAgKi9cbiAgY29uc3QgZ2V0TGluZXJJbnRlcnBvbGF0aW9uV2F0dGFnZSA9IChjcHU6IG51bWJlciwgaW5wdXQ6IFBsdWdpblBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsnY2xvdWQvdmVuZG9yJzogY2xvdWRWZW5kb3IsICdjbG91ZC9pbnN0YW5jZS10eXBlJzogaW5zdGFuY2VUeXBlfSA9XG4gICAgICBpbnB1dDtcbiAgICBjb25zdCBpZGxlID1cbiAgICAgIGNvbXB1dGVJbnN0YW5jZXNbY2xvdWRWZW5kb3JdW2luc3RhbmNlVHlwZV0uY29uc3VtcHRpb24ubWluV2F0dHM7XG4gICAgY29uc3QgbWF4ID1cbiAgICAgIGNvbXB1dGVJbnN0YW5jZXNbY2xvdWRWZW5kb3JdW2luc3RhbmNlVHlwZV0uY29uc3VtcHRpb24ubWF4V2F0dHM7XG5cbiAgICByZXR1cm4gaWRsZSArIChtYXggLSBpZGxlKSAqIChjcHUgLyAxMDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZGl6ZSB0aGUgaW5zdGFuY2UgbWV0cmljcyBmb3IgYWxsIHRoZSB2ZW5kb3JzLlxuICAgKiBNYXBzIHRoZSBpbnN0YW5jZSBtZXRyaWNzIHRvIGEgc3RhbmRhcmQgZm9ybWF0IChtaW4sIG1heCwgaWRsZSwgMTAlLCA1MCUsIDEwMCUpIGZvciBhbGwgdGhlIHZlbmRvcnMuXG4gICAqL1xuICBjb25zdCBzdGFuZGFyZGl6ZUluc3RhbmNlTWV0cmljcyA9ICgpID0+IHtcbiAgICBpbml0aWFsaXplQ29tcHV0ZUluc3RhbmNlcygpO1xuXG4gICAgY2FsY3VsYXRlQXZlcmFnZSgnZ2NwJywgR0NQX1VTRSk7XG4gICAgY2FsY3VsYXRlQXZlcmFnZSgnYXp1cmUnLCBBWlVSRV9VU0UpO1xuICAgIGNhbGN1bGF0ZUF2ZXJhZ2UoJ2F3cycsIEFXU19VU0UpO1xuXG4gICAgcHJvY2Vzc0luc3RhbmNlcyhcbiAgICAgIEFXU19JTlNUQU5DRVMsXG4gICAgICAnYXdzJyxcbiAgICAgICdJbnN0YW5jZSB0eXBlJyxcbiAgICAgICdQbGF0Zm9ybSBUb3RhbCBOdW1iZXIgb2YgdkNQVSdcbiAgICApO1xuICAgIHByb2Nlc3NJbnN0YW5jZXMoXG4gICAgICBHQ1BfSU5TVEFOQ0VTLFxuICAgICAgJ2djcCcsXG4gICAgICAnTWFjaGluZSB0eXBlJyxcbiAgICAgICdQbGF0Zm9ybSB2Q1BVcyAoaGlnaGVzdCB2Q1BVIHBvc3NpYmxlKSdcbiAgICApO1xuICAgIHByb2Nlc3NJbnN0YW5jZXMoXG4gICAgICBBWlVSRV9JTlNUQU5DRVMsXG4gICAgICAnYXp1cmUnLFxuICAgICAgJ1ZpcnR1YWwgTWFjaGluZScsXG4gICAgICAnUGxhdGZvcm0gdkNQVXMgKGhpZ2hlc3QgdkNQVSBwb3NzaWJsZSknXG4gICAgKTtcblxuICAgIHByb2Nlc3NFbWJvZGllZEVtaXNzaW9ucyhBV1NfRU1CT0RJRUQsICdhd3MnKTtcbiAgICBwcm9jZXNzRW1ib2RpZWRFbWlzc2lvbnMoR0NQX0VNQk9ESUVELCAnZ2NwJyk7XG4gICAgcHJvY2Vzc0VtYm9kaWVkRW1pc3Npb25zKEFaVVJFX0VNQk9ESUVELCAnYXp1cmUnKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgaW5zdGFuY2VzLlxuICAgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUNvbXB1dGVJbnN0YW5jZXMgPSAoKSA9PiB7XG4gICAgY29tcHV0ZUluc3RhbmNlc1snYXdzJ10gPSB7fTtcbiAgICBjb21wdXRlSW5zdGFuY2VzWydnY3AnXSA9IHt9O1xuICAgIGNvbXB1dGVJbnN0YW5jZXNbJ2F6dXJlJ10gPSB7fTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhdmVyYWdlIG9mIGFsbCBpbnN0YW5jZXMuXG4gICAqL1xuICBjb25zdCBjYWxjdWxhdGVBdmVyYWdlID0gKFxuICAgIGNsb3VkVmVuZG9yOiBzdHJpbmcsXG4gICAgaW5zdGFuY2VMaXN0OiBLZXlWYWx1ZVBhaXJbXVxuICApID0+IHtcbiAgICBjb25zdCB7dG90YWxNaW4sIHRvdGFsTWF4LCBjb3VudH0gPSBpbnN0YW5jZUxpc3QucmVkdWNlKFxuICAgICAgKGFjY3VtdWxhdG9yLCBpbnN0YW5jZSkgPT4ge1xuICAgICAgICBpbnN0YW5jZVVzYWdlW2Nsb3VkVmVuZG9yXVtpbnN0YW5jZVsnQXJjaGl0ZWN0dXJlJ11dID0gaW5zdGFuY2U7XG4gICAgICAgIGFjY3VtdWxhdG9yLnRvdGFsTWluICs9IHBhcnNlRmxvYXQoaW5zdGFuY2VbJ01pbiBXYXR0cyddKTtcbiAgICAgICAgYWNjdW11bGF0b3IudG90YWxNYXggKz0gcGFyc2VGbG9hdChpbnN0YW5jZVsnTWF4IFdhdHRzJ10pO1xuICAgICAgICBhY2N1bXVsYXRvci5jb3VudCArPSAxLjA7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIH0sXG4gICAgICB7dG90YWxNaW46IDAuMCwgdG90YWxNYXg6IDAuMCwgY291bnQ6IDAuMH1cbiAgICApO1xuXG4gICAgaW5zdGFuY2VVc2FnZVtjbG91ZFZlbmRvcl1bJ0F2ZXJhZ2UnXSA9IHtcbiAgICAgICdNaW4gV2F0dHMnOiB0b3RhbE1pbiAvIGNvdW50LFxuICAgICAgJ01heCBXYXR0cyc6IHRvdGFsTWF4IC8gY291bnQsXG4gICAgICBBcmNoaXRlY3R1cmU6ICdBdmVyYWdlJyxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBkaWZmZXJlbmNlcyBpbiBBV1MgaW5zdGFuY2UgYXJjaGl0ZWN0dXJlIHN0cmluZ3MuXG4gICAqIE1vZGlmaWVzIHRoZSBpbnB1dCBhcmNoaXRlY3R1cmUgc3RyaW5nIGJhc2VkIG9uIHByZWRlZmluZWQgcnVsZXMuXG4gICAqIFZhbGlkYXRlcyB0aGUgcmVzb2x2ZWQgYXJjaGl0ZWN0dXJlIHVzaW5nIHRoZSB2YWxpZGF0ZUF3c0FyY2hpdGVjdHVyZSBtZXRob2QuXG4gICAqL1xuICBjb25zdCByZXNvbHZlQXdzQXJjaGl0ZWN0dXJlID0gKGFyY2hpdGVjdHVyZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbW9kaWZ5QXJjaGl0ZWN0dXJlOiB7W2tleTogc3RyaW5nXTogKCkgPT4gdm9pZH0gPSB7XG4gICAgICAnQU1EICc6ICgpID0+IHtcbiAgICAgICAgYXJjaGl0ZWN0dXJlID0gYXJjaGl0ZWN0dXJlLnN1YnN0cmluZyg0KTtcbiAgICAgIH0sXG4gICAgICBTa3lsYWtlOiAoKSA9PiB7XG4gICAgICAgIGFyY2hpdGVjdHVyZSA9ICdTa3kgTGFrZSc7XG4gICAgICB9LFxuICAgICAgR3Jhdml0b246ICgpID0+IHtcbiAgICAgICAgYXJjaGl0ZWN0dXJlID0gYXJjaGl0ZWN0dXJlLmluY2x1ZGVzKCcyJykgPyAnR3Jhdml0b24yJyA6ICdHcmF2aXRvbic7XG4gICAgICB9LFxuICAgICAgVW5rbm93bjogKCkgPT4ge1xuICAgICAgICBhcmNoaXRlY3R1cmUgPSAnQXZlcmFnZSc7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBPYmplY3Qua2V5cyhtb2RpZnlBcmNoaXRlY3R1cmUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChhcmNoaXRlY3R1cmUuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBtb2RpZnlBcmNoaXRlY3R1cmVba2V5XSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFsaWRhdGVBd3NBcmNoaXRlY3R1cmUoYXJjaGl0ZWN0dXJlKTtcblxuICAgIHJldHVybiBhcmNoaXRlY3R1cmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgQVdTIGluc3RhbmNlIGFyY2hpdGVjdHVyZSBhZ2FpbnN0IGEgcHJlZGVmaW5lZCBzZXQgb2Ygc3VwcG9ydGVkIGFyY2hpdGVjdHVyZXMuXG4gICAqL1xuXG4gIGNvbnN0IHZhbGlkYXRlQXdzQXJjaGl0ZWN0dXJlID0gKGFyY2hpdGVjdHVyZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCEoYXJjaGl0ZWN0dXJlIGluIGluc3RhbmNlVXNhZ2VbJ2F3cyddKSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVmFsdWVFcnJvcihcbiAgICAgICAgZXJyb3JCdWlsZGVyKHtcbiAgICAgICAgICBtZXNzYWdlOiBgQXJjaGl0ZWN0dXJlICcke2FyY2hpdGVjdHVyZX0nIGlzIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGVtYm9kaWVkIGVtaXNzaW9ucyBmb3IgYSBnaXZlbiBpbnB1dC5cbiAgICogTXVsdGlwbHkgdG90YWxFbWlzc2lvbnMgYnkgMTAwMCB0byBjb252ZXJ0IGZyb20ga2dDTzJlIHRvIGdDTzJlXG4gICAqIE0gPSBURSAqIChUUi9FTCkgKiAoUlIvVFIpXG4gICAqIFdoZXJlOlxuICAgKiBURSA9IFRvdGFsIEVtYm9kaWVkIEVtaXNzaW9ucywgdGhlIHN1bSBvZiBMaWZlIEN5Y2xlIEFzc2Vzc21lbnQoTENBKSBlbWlzc2lvbnMgZm9yIGFsbCBoYXJkd2FyZSBjb21wb25lbnRzXG4gICAqIFRSID0gVGltZSBSZXNlcnZlZCwgdGhlIGxlbmd0aCBvZiB0aW1lIHRoZSBoYXJkd2FyZSBpcyByZXNlcnZlZCBmb3IgdXNlIGJ5IHRoZSBzb2Z0d2FyZVxuICAgKiBFTCA9IEV4cGVjdGVkIExpZmVzcGFuLCB0aGUgYW50aWNpcGF0ZWQgdGltZSB0aGF0IHRoZSBlcXVpcG1lbnQgd2lsbCBiZSBpbnN0YWxsZWRcbiAgICogUlIgPSBSZXNvdXJjZXMgUmVzZXJ2ZWQsIHRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHJlc2VydmVkIGZvciB1c2UgYnkgdGhlIHNvZnR3YXJlLlxuICAgKiBUUiA9IFRvdGFsIFJlc291cmNlcywgdGhlIHRvdGFsIG51bWJlciBvZiByZXNvdXJjZXMgYXZhaWxhYmxlLlxuICAgKi9cbiAgY29uc3QgZW1ib2RpZWRFbWlzc2lvbnMgPSAoaW5wdXQ6IFBsdWdpblBhcmFtcyk6IG51bWJlciA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgJ2Nsb3VkL3ZlbmRvcic6IGNsb3VkVmVuZG9yLFxuICAgICAgJ2Nsb3VkL2luc3RhbmNlLXR5cGUnOiBpbnN0YW5jZVR5cGUsXG4gICAgICAnY3B1L2V4cGVjdGVkLWxpZmVzcGFuJzogZXhwZWN0ZWRMaWZlc3BhbixcbiAgICAgIGR1cmF0aW9uLFxuICAgIH0gPSBpbnB1dDtcbiAgICBjb25zdCBkdXJhdGlvbkluSG91cnMgPSBkdXJhdGlvbiAvIDM2MDA7XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IGNvbXB1dGVJbnN0YW5jZXNbY2xvdWRWZW5kb3JdW2luc3RhbmNlVHlwZV07XG5cbiAgICBjb25zdCB0b3RhbEVtaXNzaW9ucyA9IGluc3RhbmNlLmVtYm9kaWVkRW1pc3Npb247XG4gICAgY29uc3QgZXhwZWN0ZWRMaWZlc3BhbkluSG91cnMgPVxuICAgICAgODc2MCAqIChleHBlY3RlZExpZmVzcGFuIHx8IGRlYWZ1bHRFeHBlY3RlZExpZmVzcGFuKTtcbiAgICBjb25zdCByZXNlcnZlZFJlc291cmNlcyA9IGluc3RhbmNlLnZDUFVzO1xuICAgIGNvbnN0IHRvdGFsUmVzb3VyY2VzID0gaW5zdGFuY2UubWF4dkNQVXM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgdG90YWxFbWlzc2lvbnMgKlxuICAgICAgMTAwMCAqXG4gICAgICAoZHVyYXRpb25JbkhvdXJzIC8gZXhwZWN0ZWRMaWZlc3BhbkluSG91cnMpICpcbiAgICAgIChyZXNlcnZlZFJlc291cmNlcyAvIHRvdGFsUmVzb3VyY2VzKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIGxpc3Qgb2YgaW5zdGFuY2VzLCBjYWxjdWxhdGVzIHRoZWlyIGNvbnN1bXB0aW9uLCBhbmQgc3RvcmVzIHRoZSBzdGFuZGFyZGl6ZWQgaW5mb3JtYXRpb24gaW4gdGhlIGNvbXB1dGVJbnN0YW5jZXMgb2JqZWN0LlxuICAgKi9cbiAgY29uc3QgcHJvY2Vzc0luc3RhbmNlcyA9IChcbiAgICBpbnN0YW5jZXM6IEtleVZhbHVlUGFpcltdLFxuICAgIGNsb3VkVmVuZG9yOiBzdHJpbmcsXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIG1heHZDUFVzOiBzdHJpbmdcbiAgKSA9PiB7XG4gICAgaW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlOiBLZXlWYWx1ZVBhaXIpID0+IHtcbiAgICAgIGNvbnN0IHZDUFUgPSBjbG91ZFZlbmRvciA9PT0gJ2F3cycgPyAnSW5zdGFuY2UgdkNQVScgOiAnSW5zdGFuY2UgdkNQVXMnO1xuICAgICAgY29uc3QgY3B1cyA9IHBhcnNlSW50KGluc3RhbmNlW3ZDUFVdLCAxMCk7XG4gICAgICBjb25zdCBjb25zdW1wdGlvbiA9XG4gICAgICAgIGNsb3VkVmVuZG9yID09PSAnYXdzJ1xuICAgICAgICAgID8gY2FsY3VsYXRlQXdzQ29uc3VtcHRpb24oaW5zdGFuY2UsIGNwdXMpXG4gICAgICAgICAgOiBjYWxjdWxhdGVDb25zdW1wdGlvbihpbnN0YW5jZSwgY2xvdWRWZW5kb3IsIGNwdXMpO1xuXG4gICAgICBjb21wdXRlSW5zdGFuY2VzW2Nsb3VkVmVuZG9yXVtpbnN0YW5jZVt0eXBlXV0gPSB7XG4gICAgICAgIG5hbWU6IGluc3RhbmNlW3R5cGVdLFxuICAgICAgICB2Q1BVczogY3B1cyxcbiAgICAgICAgY29uc3VtcHRpb24sXG4gICAgICAgIG1heHZDUFVzOiBwYXJzZUludChpbnN0YW5jZVttYXh2Q1BVc10sIDEwKSxcbiAgICAgIH0gYXMgQ29tcHV0ZUluc3RhbmNlO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgYXJjaGl0ZWN0dXJlcyBmb3IgYSBnaXZlbiBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgSU5TVEFOQ0VfVFlQRV9DT01QVVRFX1BST0NFU1NPUl9NQVBQSU5HLlxuICAgKi9cbiAgY29uc3QgZ2V0SW5zdGFuY2VBcmNoaXRlY3R1cmVzID0gKGluc3RhbmNlOiBLZXlWYWx1ZVBhaXIpOiBzdHJpbmdbXSA9PiB7XG4gICAgY29uc3QgYXJjaGl0ZWN0dXJlcyA9IElOU1RBTkNFX1RZUEVfQ09NUFVURV9QUk9DRVNTT1JfTUFQUElOR1tcbiAgICAgIGluc3RhbmNlWydJbnN0YW5jZSB0eXBlJ11cbiAgICBdID8/IFsnQXZlcmFnZSddO1xuXG4gICAgcmV0dXJuIGFyY2hpdGVjdHVyZXMubWFwKChhcmNoaXRlY3R1cmU6IHN0cmluZykgPT5cbiAgICAgIHJlc29sdmVBd3NBcmNoaXRlY3R1cmUoYXJjaGl0ZWN0dXJlKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGF2ZXJhZ2UgbWluaW11bSBhbmQgbWF4aW11bSB3YXR0cyBjb25zdW1wdGlvbiBmb3IgQVdTIGluc3RhbmNlcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJjaGl0ZWN0dXJlcy5cbiAgICovXG4gIGNvbnN0IGNhbGN1bGF0ZUF3c0F2ZXJhZ2VXYXR0cyA9IChhcmNoaXRlY3R1cmVzOiBzdHJpbmdbXSkgPT4ge1xuICAgIGNvbnN0IGF3c0luc3RhbmNlID0gaW5zdGFuY2VVc2FnZVsnYXdzJ107XG5cbiAgICBjb25zdCB7bWluV2F0dHMsIG1heFdhdHRzLCBjb3VudH0gPSBhcmNoaXRlY3R1cmVzLnJlZHVjZShcbiAgICAgIChhY2N1bXVsYXRvciwgYXJjaGl0ZWN0dXJlKSA9PiB7XG4gICAgICAgIGFjY3VtdWxhdG9yLm1pbldhdHRzICs9IGF3c0luc3RhbmNlW2FyY2hpdGVjdHVyZV1bJ01pbiBXYXR0cyddO1xuICAgICAgICBhY2N1bXVsYXRvci5tYXhXYXR0cyArPSBhd3NJbnN0YW5jZVthcmNoaXRlY3R1cmVdWydNYXggV2F0dHMnXTtcbiAgICAgICAgYWNjdW11bGF0b3IuY291bnQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgfSxcbiAgICAgIHttaW5XYXR0czogMC4wLCBtYXhXYXR0czogMC4wLCBjb3VudDogMH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbldhdHRzOiBtaW5XYXR0cyAvIGNvdW50LFxuICAgICAgbWF4V2F0dHM6IG1heFdhdHRzIC8gY291bnQsXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgY29uc3VtcHRpb24gbWV0cmljcyAoaWRsZSwgMTAlLCA1MCUsIDEwMCUsIG1pbldhdHRzLCBtYXhXYXR0cykgZm9yIGEgZ2l2ZW4gY29tcHV0ZSBpbnN0YW5jZS5jdlxuICAgKi9cbiAgY29uc3QgY2FsY3VsYXRlQ29uc3VtcHRpb24gPSAoXG4gICAgaW5zdGFuY2U6IEtleVZhbHVlUGFpcixcbiAgICBjbG91ZFZlbmRvcjogc3RyaW5nLFxuICAgIGNwdXM6IG51bWJlclxuICApID0+IHtcbiAgICBjb25zdCBhcmNoaXRlY3R1cmUgPVxuICAgICAgaW5zdGFuY2VbJ01pY3JvYXJjaGl0ZWN0dXJlJ10gaW4gaW5zdGFuY2VVc2FnZVtjbG91ZFZlbmRvcl1cbiAgICAgICAgPyBpbnN0YW5jZVsnTWljcm9hcmNoaXRlY3R1cmUnXVxuICAgICAgICA6ICdBdmVyYWdlJztcblxuICAgIHJldHVybiB7XG4gICAgICBpZGxlOiAwLFxuICAgICAgdGVuUGVyY2VudDogMCxcbiAgICAgIGZpZnR5UGVyY2VudDogMCxcbiAgICAgIGh1bmRyZWRQZXJjZW50OiAwLFxuICAgICAgbWluV2F0dHM6IGluc3RhbmNlVXNhZ2VbY2xvdWRWZW5kb3JdW2FyY2hpdGVjdHVyZV1bJ01pbiBXYXR0cyddICogY3B1cyxcbiAgICAgIG1heFdhdHRzOiBpbnN0YW5jZVVzYWdlW2Nsb3VkVmVuZG9yXVthcmNoaXRlY3R1cmVdWydNYXggV2F0dHMnXSAqIGNwdXMsXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgY29uc3VtcHRpb24gbWV0cmljcyAoaWRsZSwgMTAlLCA1MCUsIDEwMCUsIG1pbldhdHRzLCBtYXhXYXR0cykgZm9yIGEgZ2l2ZW4gY29tcHV0ZSBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0IGNhbGN1bGF0ZUF3c0NvbnN1bXB0aW9uID0gKGluc3RhbmNlOiBLZXlWYWx1ZVBhaXIsIGNwdXM6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGFyY2hpdGVjdHVyZXMgPSBnZXRJbnN0YW5jZUFyY2hpdGVjdHVyZXMoaW5zdGFuY2UpO1xuICAgIGNvbnN0IHttaW5XYXR0cywgbWF4V2F0dHN9ID0gY2FsY3VsYXRlQXdzQXZlcmFnZVdhdHRzKGFyY2hpdGVjdHVyZXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkbGU6IGdldFBhcnNlZEluc3RhbmNlTWV0cmljKGluc3RhbmNlWydJbnN0YW5jZSBAIElkbGUnXSksXG4gICAgICB0ZW5QZXJjZW50OiBnZXRQYXJzZWRJbnN0YW5jZU1ldHJpYyhpbnN0YW5jZVsnSW5zdGFuY2UgQCAxMCUnXSksXG4gICAgICBmaWZ0eVBlcmNlbnQ6IGdldFBhcnNlZEluc3RhbmNlTWV0cmljKGluc3RhbmNlWydJbnN0YW5jZSBAIDUwJSddKSxcbiAgICAgIGh1bmRyZWRQZXJjZW50OiBnZXRQYXJzZWRJbnN0YW5jZU1ldHJpYyhpbnN0YW5jZVsnSW5zdGFuY2UgQCAxMDAlJ10pLFxuICAgICAgbWluV2F0dHM6IG1pbldhdHRzICogY3B1cyxcbiAgICAgIG1heFdhdHRzOiBtYXhXYXR0cyAqIGNwdXMsXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGEgbWV0cmljIHZhbHVlIHRvIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgKi9cbiAgY29uc3QgZ2V0UGFyc2VkSW5zdGFuY2VNZXRyaWMgPSAobWV0cmljOiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtZXRyaWMucmVwbGFjZSgnLCcsICcuJykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYW5kIGFzc2lnbnMgZW1ib2RpZWQgZW1pc3Npb25zIGRhdGEgdG8gY29tcHV0ZSBpbnN0YW5jZXMgZm9yIGEgc3BlY2lmaWMgY2xvdWQvdmVuZG9yLlxuICAgKi9cbiAgY29uc3QgcHJvY2Vzc0VtYm9kaWVkRW1pc3Npb25zID0gKFxuICAgIGVtYm9kaWVkTGlzdDogS2V5VmFsdWVQYWlyW10sXG4gICAgY2xvdWRWZW5kb3I6IHN0cmluZ1xuICApID0+IHtcbiAgICBlbWJvZGllZExpc3QuZm9yRWFjaCgoaW5zdGFuY2U6IEtleVZhbHVlUGFpcikgPT4ge1xuICAgICAgY29tcHV0ZUluc3RhbmNlc1tjbG91ZFZlbmRvcl1baW5zdGFuY2VbJ3R5cGUnXV0uZW1ib2RpZWRFbWlzc2lvbiA9XG4gICAgICAgIGluc3RhbmNlWyd0b3RhbCddO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWV0YWRhdGEsXG4gICAgZXhlY3V0ZSxcbiAgfTtcbn07XG4iXX0=