"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Multiply = void 0;
const zod_1 = require("zod");
const helpers_1 = require("../../util/helpers");
const errors_1 = require("../../util/errors");
const validations_1 = require("../../util/validations");
const { InputValidationError } = errors_1.ERRORS;
const Multiply = (globalConfig) => {
    const errorBuilder = (0, helpers_1.buildErrorMessage)(exports.Multiply.name);
    const metadata = {
        kind: 'execute',
    };
    /**
     * Checks global config value are valid.
     */
    const validateGlobalConfig = () => {
        const globalConfigSchema = zod_1.z.object({
            'input-parameters': zod_1.z.array(zod_1.z.string()),
            'output-parameter': zod_1.z.string().min(1),
        });
        return (0, validations_1.validate)(globalConfigSchema, globalConfig);
    };
    /**
     * Checks for required fields in input.
     */
    const validateSingleInput = (input, inputParameters) => {
        inputParameters.forEach(metricToMultiply => {
            if (input[metricToMultiply] === undefined ||
                isNaN(input[metricToMultiply])) {
                throw new InputValidationError(errorBuilder({
                    message: `${metricToMultiply} is missing from the input array`,
                }));
            }
        });
        return input;
    };
    /**
     * Calculate the product of each input parameter.
     */
    const execute = async (inputs) => {
        const safeGlobalConfig = validateGlobalConfig();
        const inputParameters = safeGlobalConfig['input-parameters'];
        const outputParameter = safeGlobalConfig['output-parameter'];
        return inputs.map(input => {
            const safeInput = validateSingleInput(input, inputParameters);
            return {
                ...input,
                [outputParameter]: calculateProduct(safeInput, inputParameters),
            };
        });
    };
    /**
     * Calculates the product of the energy components.
     */
    const calculateProduct = (input, inputParameters) => inputParameters.reduce((accumulator, metricToMultiply) => accumulator * input[metricToMultiply], 1);
    return {
        metadata,
        execute,
    };
};
exports.Multiply = Multiply;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL211bHRpcGx5L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUFzQjtBQUV0QixnREFBcUQ7QUFDckQsOENBQXlDO0FBQ3pDLHdEQUFnRDtBQU1oRCxNQUFNLEVBQUMsb0JBQW9CLEVBQUMsR0FBRyxlQUFNLENBQUM7QUFFL0IsTUFBTSxRQUFRLEdBQUcsQ0FBQyxZQUE0QixFQUFtQixFQUFFO0lBQ3hFLE1BQU0sWUFBWSxHQUFHLElBQUEsMkJBQWlCLEVBQUMsZ0JBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN0RCxNQUFNLFFBQVEsR0FBRztRQUNmLElBQUksRUFBRSxTQUFTO0tBQ2hCLENBQUM7SUFFRjs7T0FFRztJQUNILE1BQU0sb0JBQW9CLEdBQUcsR0FBRyxFQUFFO1FBQ2hDLE1BQU0sa0JBQWtCLEdBQUcsT0FBQyxDQUFDLE1BQU0sQ0FBQztZQUNsQyxrQkFBa0IsRUFBRSxPQUFDLENBQUMsS0FBSyxDQUFDLE9BQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN2QyxrQkFBa0IsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUN0QyxDQUFDLENBQUM7UUFFSCxPQUFPLElBQUEsc0JBQVEsRUFDYixrQkFBa0IsRUFDbEIsWUFBWSxDQUNiLENBQUM7SUFDSixDQUFDLENBQUM7SUFFRjs7T0FFRztJQUNILE1BQU0sbUJBQW1CLEdBQUcsQ0FDMUIsS0FBbUIsRUFDbkIsZUFBeUIsRUFDekIsRUFBRTtRQUNGLGVBQWUsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUN6QyxJQUNFLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLFNBQVM7Z0JBQ3JDLEtBQUssQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxFQUM5QixDQUFDO2dCQUNELE1BQU0sSUFBSSxvQkFBb0IsQ0FDNUIsWUFBWSxDQUFDO29CQUNYLE9BQU8sRUFBRSxHQUFHLGdCQUFnQixrQ0FBa0M7aUJBQy9ELENBQUMsQ0FDSCxDQUFDO1lBQ0osQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDLENBQUM7SUFFRjs7T0FFRztJQUNILE1BQU0sT0FBTyxHQUFHLEtBQUssRUFBRSxNQUFzQixFQUEyQixFQUFFO1FBQ3hFLE1BQU0sZ0JBQWdCLEdBQUcsb0JBQW9CLEVBQUUsQ0FBQztRQUNoRCxNQUFNLGVBQWUsR0FBRyxnQkFBZ0IsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQzdELE1BQU0sZUFBZSxHQUFHLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFFN0QsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3hCLE1BQU0sU0FBUyxHQUFHLG1CQUFtQixDQUFDLEtBQUssRUFBRSxlQUFlLENBQUMsQ0FBQztZQUU5RCxPQUFPO2dCQUNMLEdBQUcsS0FBSztnQkFDUixDQUFDLGVBQWUsQ0FBQyxFQUFFLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxlQUFlLENBQUM7YUFDaEUsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0lBRUY7O09BRUc7SUFDSCxNQUFNLGdCQUFnQixHQUFHLENBQUMsS0FBbUIsRUFBRSxlQUF5QixFQUFFLEVBQUUsQ0FDMUUsZUFBZSxDQUFDLE1BQU0sQ0FDcEIsQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFDeEUsQ0FBQyxDQUNGLENBQUM7SUFFSixPQUFPO1FBQ0wsUUFBUTtRQUNSLE9BQU87S0FDUixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBM0VXLFFBQUEsUUFBUSxZQTJFbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3p9IGZyb20gJ3pvZCc7XG5cbmltcG9ydCB7YnVpbGRFcnJvck1lc3NhZ2V9IGZyb20gJy4uLy4uL3V0aWwvaGVscGVycyc7XG5pbXBvcnQge0VSUk9SU30gZnJvbSAnLi4vLi4vdXRpbC9lcnJvcnMnO1xuaW1wb3J0IHt2YWxpZGF0ZX0gZnJvbSAnLi4vLi4vdXRpbC92YWxpZGF0aW9ucyc7XG5cbmltcG9ydCB7UGx1Z2luSW50ZXJmYWNlfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7UGx1Z2luUGFyYW1zfSBmcm9tICcuLi8uLi90eXBlcy9jb21tb24nO1xuaW1wb3J0IHtNdWx0aXBseUNvbmZpZ30gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IHtJbnB1dFZhbGlkYXRpb25FcnJvcn0gPSBFUlJPUlM7XG5cbmV4cG9ydCBjb25zdCBNdWx0aXBseSA9IChnbG9iYWxDb25maWc6IE11bHRpcGx5Q29uZmlnKTogUGx1Z2luSW50ZXJmYWNlID0+IHtcbiAgY29uc3QgZXJyb3JCdWlsZGVyID0gYnVpbGRFcnJvck1lc3NhZ2UoTXVsdGlwbHkubmFtZSk7XG4gIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgIGtpbmQ6ICdleGVjdXRlJyxcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGdsb2JhbCBjb25maWcgdmFsdWUgYXJlIHZhbGlkLlxuICAgKi9cbiAgY29uc3QgdmFsaWRhdGVHbG9iYWxDb25maWcgPSAoKSA9PiB7XG4gICAgY29uc3QgZ2xvYmFsQ29uZmlnU2NoZW1hID0gei5vYmplY3Qoe1xuICAgICAgJ2lucHV0LXBhcmFtZXRlcnMnOiB6LmFycmF5KHouc3RyaW5nKCkpLFxuICAgICAgJ291dHB1dC1wYXJhbWV0ZXInOiB6LnN0cmluZygpLm1pbigxKSxcbiAgICB9KTtcblxuICAgIHJldHVybiB2YWxpZGF0ZTx6LmluZmVyPHR5cGVvZiBnbG9iYWxDb25maWdTY2hlbWE+PihcbiAgICAgIGdsb2JhbENvbmZpZ1NjaGVtYSxcbiAgICAgIGdsb2JhbENvbmZpZ1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3IgcmVxdWlyZWQgZmllbGRzIGluIGlucHV0LlxuICAgKi9cbiAgY29uc3QgdmFsaWRhdGVTaW5nbGVJbnB1dCA9IChcbiAgICBpbnB1dDogUGx1Z2luUGFyYW1zLFxuICAgIGlucHV0UGFyYW1ldGVyczogc3RyaW5nW11cbiAgKSA9PiB7XG4gICAgaW5wdXRQYXJhbWV0ZXJzLmZvckVhY2gobWV0cmljVG9NdWx0aXBseSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGlucHV0W21ldHJpY1RvTXVsdGlwbHldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgaXNOYU4oaW5wdXRbbWV0cmljVG9NdWx0aXBseV0pXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IElucHV0VmFsaWRhdGlvbkVycm9yKFxuICAgICAgICAgIGVycm9yQnVpbGRlcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBgJHttZXRyaWNUb011bHRpcGx5fSBpcyBtaXNzaW5nIGZyb20gdGhlIGlucHV0IGFycmF5YCxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlucHV0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHByb2R1Y3Qgb2YgZWFjaCBpbnB1dCBwYXJhbWV0ZXIuXG4gICAqL1xuICBjb25zdCBleGVjdXRlID0gYXN5bmMgKGlucHV0czogUGx1Z2luUGFyYW1zW10pOiBQcm9taXNlPFBsdWdpblBhcmFtc1tdPiA9PiB7XG4gICAgY29uc3Qgc2FmZUdsb2JhbENvbmZpZyA9IHZhbGlkYXRlR2xvYmFsQ29uZmlnKCk7XG4gICAgY29uc3QgaW5wdXRQYXJhbWV0ZXJzID0gc2FmZUdsb2JhbENvbmZpZ1snaW5wdXQtcGFyYW1ldGVycyddO1xuICAgIGNvbnN0IG91dHB1dFBhcmFtZXRlciA9IHNhZmVHbG9iYWxDb25maWdbJ291dHB1dC1wYXJhbWV0ZXInXTtcblxuICAgIHJldHVybiBpbnB1dHMubWFwKGlucHV0ID0+IHtcbiAgICAgIGNvbnN0IHNhZmVJbnB1dCA9IHZhbGlkYXRlU2luZ2xlSW5wdXQoaW5wdXQsIGlucHV0UGFyYW1ldGVycyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmlucHV0LFxuICAgICAgICBbb3V0cHV0UGFyYW1ldGVyXTogY2FsY3VsYXRlUHJvZHVjdChzYWZlSW5wdXQsIGlucHV0UGFyYW1ldGVycyksXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBwcm9kdWN0IG9mIHRoZSBlbmVyZ3kgY29tcG9uZW50cy5cbiAgICovXG4gIGNvbnN0IGNhbGN1bGF0ZVByb2R1Y3QgPSAoaW5wdXQ6IFBsdWdpblBhcmFtcywgaW5wdXRQYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT5cbiAgICBpbnB1dFBhcmFtZXRlcnMucmVkdWNlKFxuICAgICAgKGFjY3VtdWxhdG9yLCBtZXRyaWNUb011bHRpcGx5KSA9PiBhY2N1bXVsYXRvciAqIGlucHV0W21ldHJpY1RvTXVsdGlwbHldLFxuICAgICAgMVxuICAgICk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRhZGF0YSxcbiAgICBleGVjdXRlLFxuICB9O1xufTtcbiJdfQ==