"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudMetadata = void 0;
const path = require("path");
const fs = require("fs");
const zod_1 = require("zod");
const csv_parse_1 = require("csv-parse");
const validations_1 = require("../../util/validations");
const helpers_1 = require("../../util/helpers");
const errors_1 = require("../../util/errors");
const config_1 = require("./config");
const AWS_INSTANCES = path.resolve(__dirname, './aws-instances.csv');
const AZURE_INSTANCES = path.resolve(__dirname, './azure-instances.csv');
const GSF_DATA = path.resolve(__dirname, './GSF-data.csv');
const { UnsupportedValueError } = errors_1.ERRORS;
const CloudMetadata = () => {
    const SUPPORTED_CLOUDS = ['aws', 'azure'];
    const errorBuilder = (0, helpers_1.buildErrorMessage)(exports.CloudMetadata.name);
    const metadata = {
        kind: 'execute',
    };
    /**
     * Get provided cloud data into input.
     */
    const execute = async (inputs, config) => {
        const results = [];
        for await (const input of inputs) {
            const safeInput = Object.assign({}, input, validateInput(input));
            const outputParameters = (config && config['fields']) || [];
            const region = input['cloud/region'];
            const draftInput = {};
            // Process instance metadata based on cloud vendor
            if (safeInput['cloud/instance-type']) {
                Object.assign(draftInput, await processInstanceTypeData(safeInput));
            }
            // Process region metadata based on cloud vendor
            if (region) {
                Object.assign(draftInput, await processRegionData(safeInput));
            }
            const configuredParmeters = configureOutput(draftInput, outputParameters);
            Object.assign(safeInput, configuredParmeters);
            results.push(safeInput);
        }
        return results;
    };
    /**
     * Processes region data based on input parameters.
     */
    const processRegionData = async (input) => {
        const region = input['cloud/region'];
        const vendor = input['cloud/vendor'];
        const regionInput = await getVendorRegion(vendor, region);
        if (!regionInput) {
            throw new UnsupportedValueError(errorBuilder({
                message: `'${region}' region is not supported in '${vendor}' cloud vendor`,
            }));
        }
        return {
            'cloud/region-cfe': regionInput['cfe-region'],
            'cloud/region-em-zone-id': regionInput['em-zone-id'],
            'cloud/region-wt-id': regionInput['wt-region-id'],
            'cloud/region-location': regionInput['location'],
            'cloud/region-geolocation': regionInput['geolocation'].trim(),
        };
    };
    /**
     * Processes instance type based on input parameters.
     */
    const processInstanceTypeData = async (input) => {
        const vendor = input['cloud/vendor'];
        const instanceType = input['cloud/instance-type'];
        const instance = await getVendorInstance(vendor, instanceType);
        if (!instance) {
            throw new UnsupportedValueError(errorBuilder({
                scope: 'cloud/instance-type',
                message: `'${instanceType}' instance type is not supported in '${vendor}' cloud vendor`,
            }));
        }
        return {
            'vcpus-allocated': parseInt(instance['cpu-cores-utilized']),
            'vcpus-total': parseInt(instance['cpu-cores-available']),
            'memory-available': parseInt(instance['memory-available']),
            'physical-processor': instance['cpu-model-name'],
            'cpu/thermal-design-power': parseFloat(instance['cpu-tdp']),
        };
    };
    /**
     * Configures parameters for output.
     */
    const configureOutput = (input, outputParameters) => {
        if (outputParameters.length === 0) {
            return input;
        }
        return Object.fromEntries(Object.entries(input).filter(([key]) => outputParameters.includes(key)));
    };
    /**
     * Executes the function associated with the specified vendor type and region.
     */
    const getVendorRegion = async (vendor, region) => {
        const cloudProvider = {
            aws: 'Amazon Web Services',
            azure: 'Microsoft Azure',
            gcp: 'Google Cloud',
        };
        const result = await readCSVFile(GSF_DATA, config_1.GSF_HEADERS);
        const filteredResult = result.find(item => item['cloud-provider'] === cloudProvider[vendor] &&
            (item['cloud-region'] === region || item['cfe-region'] === region));
        return filteredResult;
    };
    /**
     * Execute the function associated with the specified vendor type and get the instance.
     */
    const getVendorInstance = async (vendor, instanceType) => {
        const vendorType = {
            aws: async () => {
                const result = await readCSVFile(AWS_INSTANCES, config_1.AWS_HEADERS);
                return result.find(instance => instance['instance-class'] === instanceType);
            },
            azure: async () => {
                if (instanceType.includes('-')) {
                    const [instanceFamily, instanceSize] = instanceType.split('-');
                    const sizeNumberIndex = instanceSize.search(/\D/);
                    const instanceSizeNumber = sizeNumberIndex !== -1
                        ? instanceSize.slice(sizeNumberIndex)
                        : instanceSize;
                    instanceType = `${instanceFamily}${instanceSizeNumber}`;
                }
                const result = await readCSVFile(AZURE_INSTANCES, config_1.AZURE_HEADERS);
                return result.find(instance => instance['instance-class'] === instanceType);
            },
        };
        return vendorType[vendor]();
    };
    const readCSVFile = async (file, headers) => {
        const result = [];
        const parser = fs
            .createReadStream(file)
            .pipe((0, csv_parse_1.parse)({ delimiter: ',', columns: headers }));
        for await (const record of parser) {
            result.push(record);
        }
        result.shift();
        return result;
    };
    /**
     * Checks for required fields in input.
     */
    const validateInput = (input) => {
        const schema = zod_1.z.object({
            'cloud/vendor': zod_1.z.enum(SUPPORTED_CLOUDS, {
                required_error: `Only ${SUPPORTED_CLOUDS} is currently supported`,
            }),
            'cloud/instance-type': zod_1.z.string(),
            'cloud/region': zod_1.z.string().optional(),
        });
        return (0, validations_1.validate)(schema, input);
    };
    return {
        metadata,
        execute,
    };
};
exports.CloudMetadata = CloudMetadata;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2Nsb3VkLW1ldGFkYXRhL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsNkJBQXNCO0FBQ3RCLHlDQUFnQztBQUtoQyx3REFBZ0Q7QUFDaEQsZ0RBQXFEO0FBQ3JELDhDQUF5QztBQUd6QyxxQ0FBaUU7QUFFakUsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUscUJBQXFCLENBQUMsQ0FBQztBQUNyRSxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0FBQ3pFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUM7QUFFM0QsTUFBTSxFQUFDLHFCQUFxQixFQUFDLEdBQUcsZUFBTSxDQUFDO0FBRWhDLE1BQU0sYUFBYSxHQUFHLEdBQW9CLEVBQUU7SUFDakQsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQVUsQ0FBQztJQUNuRCxNQUFNLFlBQVksR0FBRyxJQUFBLDJCQUFpQixFQUFDLHFCQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0QsTUFBTSxRQUFRLEdBQUc7UUFDZixJQUFJLEVBQUUsU0FBUztLQUNoQixDQUFDO0lBRUY7O09BRUc7SUFDSCxNQUFNLE9BQU8sR0FBRyxLQUFLLEVBQUUsTUFBc0IsRUFBRSxNQUFxQixFQUFFLEVBQUU7UUFDdEUsTUFBTSxPQUFPLEdBQW1CLEVBQUUsQ0FBQztRQUVuQyxJQUFJLEtBQUssRUFBRSxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUUsQ0FBQztZQUNqQyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsYUFBYSxDQUFD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ICdwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7en0gZnJvbSAnem9kJztcbmltcG9ydCB7cGFyc2V9IGZyb20gJ2Nzdi1wYXJzZSc7XG5cbmltcG9ydCB7UGx1Z2luSW50ZXJmYWNlfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7Q29uZmlnUGFyYW1zLCBQbHVnaW5QYXJhbXN9IGZyb20gJy4uLy4uL3R5cGVzL2NvbW1vbic7XG5cbmltcG9ydCB7dmFsaWRhdGV9IGZyb20gJy4uLy4uL3V0aWwvdmFsaWRhdGlvbnMnO1xuaW1wb3J0IHtidWlsZEVycm9yTWVzc2FnZX0gZnJvbSAnLi4vLi4vdXRpbC9oZWxwZXJzJztcbmltcG9ydCB7RVJST1JTfSBmcm9tICcuLi8uLi91dGlsL2Vycm9ycyc7XG5cbmltcG9ydCB7SW5zdGFuY2VJbnB1dCwgUmVnaW9uSW5wdXR9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtBV1NfSEVBREVSUywgQVpVUkVfSEVBREVSUywgR1NGX0hFQURFUlN9IGZyb20gJy4vY29uZmlnJztcblxuY29uc3QgQVdTX0lOU1RBTkNFUyA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuL2F3cy1pbnN0YW5jZXMuY3N2Jyk7XG5jb25zdCBBWlVSRV9JTlNUQU5DRVMgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi9henVyZS1pbnN0YW5jZXMuY3N2Jyk7XG5jb25zdCBHU0ZfREFUQSA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuL0dTRi1kYXRhLmNzdicpO1xuXG5jb25zdCB7VW5zdXBwb3J0ZWRWYWx1ZUVycm9yfSA9IEVSUk9SUztcblxuZXhwb3J0IGNvbnN0IENsb3VkTWV0YWRhdGEgPSAoKTogUGx1Z2luSW50ZXJmYWNlID0+IHtcbiAgY29uc3QgU1VQUE9SVEVEX0NMT1VEUyA9IFsnYXdzJywgJ2F6dXJlJ10gYXMgY29uc3Q7XG4gIGNvbnN0IGVycm9yQnVpbGRlciA9IGJ1aWxkRXJyb3JNZXNzYWdlKENsb3VkTWV0YWRhdGEubmFtZSk7XG4gIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgIGtpbmQ6ICdleGVjdXRlJyxcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHByb3ZpZGVkIGNsb3VkIGRhdGEgaW50byBpbnB1dC5cbiAgICovXG4gIGNvbnN0IGV4ZWN1dGUgPSBhc3luYyAoaW5wdXRzOiBQbHVnaW5QYXJhbXNbXSwgY29uZmlnPzogQ29uZmlnUGFyYW1zKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogUGx1Z2luUGFyYW1zW10gPSBbXTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBjb25zdCBzYWZlSW5wdXQgPSBPYmplY3QuYXNzaWduKHt9LCBpbnB1dCwgdmFsaWRhdGVJbnB1dChpbnB1dCkpO1xuICAgICAgY29uc3Qgb3V0cHV0UGFyYW1ldGVycyA9IChjb25maWcgJiYgY29uZmlnWydmaWVsZHMnXSkgfHwgW107XG4gICAgICBjb25zdCByZWdpb24gPSBpbnB1dFsnY2xvdWQvcmVnaW9uJ107XG4gICAgICBjb25zdCBkcmFmdElucHV0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG5cbiAgICAgIC8vIFByb2Nlc3MgaW5zdGFuY2UgbWV0YWRhdGEgYmFzZWQgb24gY2xvdWQgdmVuZG9yXG4gICAgICBpZiAoc2FmZUlucHV0WydjbG91ZC9pbnN0YW5jZS10eXBlJ10pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihkcmFmdElucHV0LCBhd2FpdCBwcm9jZXNzSW5zdGFuY2VUeXBlRGF0YShzYWZlSW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJvY2VzcyByZWdpb24gbWV0YWRhdGEgYmFzZWQgb24gY2xvdWQgdmVuZG9yXG4gICAgICBpZiAocmVnaW9uKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZHJhZnRJbnB1dCwgYXdhaXQgcHJvY2Vzc1JlZ2lvbkRhdGEoc2FmZUlucHV0KSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbmZpZ3VyZWRQYXJtZXRlcnMgPSBjb25maWd1cmVPdXRwdXQoZHJhZnRJbnB1dCwgb3V0cHV0UGFyYW1ldGVycyk7XG4gICAgICBPYmplY3QuYXNzaWduKHNhZmVJbnB1dCwgY29uZmlndXJlZFBhcm1ldGVycyk7XG5cbiAgICAgIHJlc3VsdHMucHVzaChzYWZlSW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgcmVnaW9uIGRhdGEgYmFzZWQgb24gaW5wdXQgcGFyYW1ldGVycy5cbiAgICovXG4gIGNvbnN0IHByb2Nlc3NSZWdpb25EYXRhID0gYXN5bmMgKGlucHV0OiBQbHVnaW5QYXJhbXMpID0+IHtcbiAgICBjb25zdCByZWdpb24gPSBpbnB1dFsnY2xvdWQvcmVnaW9uJ107XG4gICAgY29uc3QgdmVuZG9yID0gaW5wdXRbJ2Nsb3VkL3ZlbmRvciddO1xuXG4gICAgY29uc3QgcmVnaW9uSW5wdXQ6IFJlZ2lvbklucHV0ID0gYXdhaXQgZ2V0VmVuZG9yUmVnaW9uKHZlbmRvciwgcmVnaW9uKTtcblxuICAgIGlmICghcmVnaW9uSW5wdXQpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFZhbHVlRXJyb3IoXG4gICAgICAgIGVycm9yQnVpbGRlcih7XG4gICAgICAgICAgbWVzc2FnZTogYCcke3JlZ2lvbn0nIHJlZ2lvbiBpcyBub3Qgc3VwcG9ydGVkIGluICcke3ZlbmRvcn0nIGNsb3VkIHZlbmRvcmAsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgJ2Nsb3VkL3JlZ2lvbi1jZmUnOiByZWdpb25JbnB1dFsnY2ZlLXJlZ2lvbiddLFxuICAgICAgJ2Nsb3VkL3JlZ2lvbi1lbS16b25lLWlkJzogcmVnaW9uSW5wdXRbJ2VtLXpvbmUtaWQnXSxcbiAgICAgICdjbG91ZC9yZWdpb24td3QtaWQnOiByZWdpb25JbnB1dFsnd3QtcmVnaW9uLWlkJ10sXG4gICAgICAnY2xvdWQvcmVnaW9uLWxvY2F0aW9uJzogcmVnaW9uSW5wdXRbJ2xvY2F0aW9uJ10sXG4gICAgICAnY2xvdWQvcmVnaW9uLWdlb2xvY2F0aW9uJzogcmVnaW9uSW5wdXRbJ2dlb2xvY2F0aW9uJ10udHJpbSgpLFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBpbnN0YW5jZSB0eXBlIGJhc2VkIG9uIGlucHV0IHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdCBwcm9jZXNzSW5zdGFuY2VUeXBlRGF0YSA9IGFzeW5jIChpbnB1dDogUGx1Z2luUGFyYW1zKSA9PiB7XG4gICAgY29uc3QgdmVuZG9yID0gaW5wdXRbJ2Nsb3VkL3ZlbmRvciddO1xuICAgIGNvbnN0IGluc3RhbmNlVHlwZSA9IGlucHV0WydjbG91ZC9pbnN0YW5jZS10eXBlJ107XG5cbiAgICBjb25zdCBpbnN0YW5jZTogSW5zdGFuY2VJbnB1dCA9IGF3YWl0IGdldFZlbmRvckluc3RhbmNlKFxuICAgICAgdmVuZG9yLFxuICAgICAgaW5zdGFuY2VUeXBlXG4gICAgKTtcblxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFZhbHVlRXJyb3IoXG4gICAgICAgIGVycm9yQnVpbGRlcih7XG4gICAgICAgICAgc2NvcGU6ICdjbG91ZC9pbnN0YW5jZS10eXBlJyxcbiAgICAgICAgICBtZXNzYWdlOiBgJyR7aW5zdGFuY2VUeXBlfScgaW5zdGFuY2UgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGluICcke3ZlbmRvcn0nIGNsb3VkIHZlbmRvcmAsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAndmNwdXMtYWxsb2NhdGVkJzogcGFyc2VJbnQoaW5zdGFuY2VbJ2NwdS1jb3Jlcy11dGlsaXplZCddKSxcbiAgICAgICd2Y3B1cy10b3RhbCc6IHBhcnNlSW50KGluc3RhbmNlWydjcHUtY29yZXMtYXZhaWxhYmxlJ10pLFxuICAgICAgJ21lbW9yeS1hdmFpbGFibGUnOiBwYXJzZUludChpbnN0YW5jZVsnbWVtb3J5LWF2YWlsYWJsZSddKSxcbiAgICAgICdwaHlzaWNhbC1wcm9jZXNzb3InOiBpbnN0YW5jZVsnY3B1LW1vZGVsLW5hbWUnXSxcbiAgICAgICdjcHUvdGhlcm1hbC1kZXNpZ24tcG93ZXInOiBwYXJzZUZsb2F0KGluc3RhbmNlWydjcHUtdGRwJ10pLFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgcGFyYW1ldGVycyBmb3Igb3V0cHV0LlxuICAgKi9cbiAgY29uc3QgY29uZmlndXJlT3V0cHV0ID0gKFxuICAgIGlucHV0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIG91dHB1dFBhcmFtZXRlcnM6IHN0cmluZ1tdXG4gICk6IFJlY29yZDxzdHJpbmcsIGFueT4gPT4ge1xuICAgIGlmIChvdXRwdXRQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMoaW5wdXQpLmZpbHRlcigoW2tleV0pID0+IG91dHB1dFBhcmFtZXRlcnMuaW5jbHVkZXMoa2V5KSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmVuZG9yIHR5cGUgYW5kIHJlZ2lvbi5cbiAgICovXG4gIGNvbnN0IGdldFZlbmRvclJlZ2lvbiA9IGFzeW5jICh2ZW5kb3I6IHN0cmluZywgcmVnaW9uOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBjbG91ZFByb3ZpZGVyOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgICAgIGF3czogJ0FtYXpvbiBXZWIgU2VydmljZXMnLFxuICAgICAgYXp1cmU6ICdNaWNyb3NvZnQgQXp1cmUnLFxuICAgICAgZ2NwOiAnR29vZ2xlIENsb3VkJyxcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZENTVkZpbGUoR1NGX0RBVEEsIEdTRl9IRUFERVJTKTtcblxuICAgIGNvbnN0IGZpbHRlcmVkUmVzdWx0ID0gcmVzdWx0LmZpbmQoXG4gICAgICBpdGVtID0+XG4gICAgICAgIGl0ZW1bJ2Nsb3VkLXByb3ZpZGVyJ10gPT09IGNsb3VkUHJvdmlkZXJbdmVuZG9yXSAmJlxuICAgICAgICAoaXRlbVsnY2xvdWQtcmVnaW9uJ10gPT09IHJlZ2lvbiB8fCBpdGVtWydjZmUtcmVnaW9uJ10gPT09IHJlZ2lvbilcbiAgICApO1xuXG4gICAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBmdW5jdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB2ZW5kb3IgdHlwZSBhbmQgZ2V0IHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0IGdldFZlbmRvckluc3RhbmNlID0gYXN5bmMgKHZlbmRvcjogc3RyaW5nLCBpbnN0YW5jZVR5cGU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHZlbmRvclR5cGU6IFJlY29yZDxzdHJpbmcsICgpID0+IFByb21pc2U8YW55Pj4gPSB7XG4gICAgICBhd3M6IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZENTVkZpbGUoQVdTX0lOU1RBTkNFUywgQVdTX0hFQURFUlMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmZpbmQoXG4gICAgICAgICAgaW5zdGFuY2UgPT4gaW5zdGFuY2VbJ2luc3RhbmNlLWNsYXNzJ10gPT09IGluc3RhbmNlVHlwZVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGF6dXJlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZVR5cGUuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgIGNvbnN0IFtpbnN0YW5jZUZhbWlseSwgaW5zdGFuY2VTaXplXSA9IGluc3RhbmNlVHlwZS5zcGxpdCgnLScpO1xuICAgICAgICAgIGNvbnN0IHNpemVOdW1iZXJJbmRleCA9IGluc3RhbmNlU2l6ZS5zZWFyY2goL1xcRC8pO1xuICAgICAgICAgIGNvbnN0IGluc3RhbmNlU2l6ZU51bWJlciA9XG4gICAgICAgICAgICBzaXplTnVtYmVySW5kZXggIT09IC0xXG4gICAgICAgICAgICAgID8gaW5zdGFuY2VTaXplLnNsaWNlKHNpemVOdW1iZXJJbmRleClcbiAgICAgICAgICAgICAgOiBpbnN0YW5jZVNpemU7XG5cbiAgICAgICAgICBpbnN0YW5jZVR5cGUgPSBgJHtpbnN0YW5jZUZhbWlseX0ke2luc3RhbmNlU2l6ZU51bWJlcn1gO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZENTVkZpbGUoQVpVUkVfSU5TVEFOQ0VTLCBBWlVSRV9IRUFERVJTKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5maW5kKFxuICAgICAgICAgIGluc3RhbmNlID0+IGluc3RhbmNlWydpbnN0YW5jZS1jbGFzcyddID09PSBpbnN0YW5jZVR5cGVcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiB2ZW5kb3JUeXBlW3ZlbmRvcl0oKTtcbiAgfTtcblxuICBjb25zdCByZWFkQ1NWRmlsZSA9IGFzeW5jIChmaWxlOiBzdHJpbmcsIGhlYWRlcnM6IHN0cmluZ1tdKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgcGFyc2VyID0gZnNcbiAgICAgIC5jcmVhdGVSZWFkU3RyZWFtKGZpbGUpXG4gICAgICAucGlwZShwYXJzZSh7ZGVsaW1pdGVyOiAnLCcsIGNvbHVtbnM6IGhlYWRlcnN9KSk7XG4gICAgZm9yIGF3YWl0IChjb25zdCByZWNvcmQgb2YgcGFyc2VyKSB7XG4gICAgICByZXN1bHQucHVzaChyZWNvcmQpO1xuICAgIH1cblxuICAgIHJlc3VsdC5zaGlmdCgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGZvciByZXF1aXJlZCBmaWVsZHMgaW4gaW5wdXQuXG4gICAqL1xuICBjb25zdCB2YWxpZGF0ZUlucHV0ID0gKGlucHV0OiBQbHVnaW5QYXJhbXMpID0+IHtcbiAgICBjb25zdCBzY2hlbWEgPSB6Lm9iamVjdCh7XG4gICAgICAnY2xvdWQvdmVuZG9yJzogei5lbnVtKFNVUFBPUlRFRF9DTE9VRFMsIHtcbiAgICAgICAgcmVxdWlyZWRfZXJyb3I6IGBPbmx5ICR7U1VQUE9SVEVEX0NMT1VEU30gaXMgY3VycmVudGx5IHN1cHBvcnRlZGAsXG4gICAgICB9KSxcbiAgICAgICdjbG91ZC9pbnN0YW5jZS10eXBlJzogei5zdHJpbmcoKSxcbiAgICAgICdjbG91ZC9yZWdpb24nOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmFsaWRhdGU8ei5pbmZlcjx0eXBlb2Ygc2NoZW1hPj4oc2NoZW1hLCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRhZGF0YSxcbiAgICBleGVjdXRlLFxuICB9O1xufTtcbiJdfQ==