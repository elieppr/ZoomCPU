"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EMem = void 0;
const zod_1 = require("zod");
const validations_1 = require("../../util/validations");
const EMem = (globalConfig) => {
    const metadata = {
        kind: 'execute',
    };
    /**
     * Calculate the total emissions for a list of inputs.
     */
    const execute = async (inputs) => {
        const validatedGlobalConfig = validateConfig();
        return inputs.map((input) => {
            const safeInput = validateSingleInput(input);
            const inputWithConfigs = Object.assign({}, safeInput, validatedGlobalConfig);
            return {
                ...input,
                'memory/energy': calculateEnergy(inputWithConfigs),
            };
        });
    };
    /**
     * Calculates the energy consumption for a single input.
     */
    const calculateEnergy = (input) => {
        const { 'memory/capacity': totalMemory, 'memory/utilization': memoryUtil, 'energy-per-gb': energyPerGB, } = input;
        // GB * kWh/GB == kWh
        return totalMemory * (memoryUtil / 100) * energyPerGB;
    };
    const validateConfig = () => {
        const schema = zod_1.z.object({
            'energy-per-gb': zod_1.z.number().gt(0),
        });
        //Manually add default value from CCF: https://www.cloudcarbonfootprint.org/docs/methodology/#memory
        const energyPerGB = globalConfig['energy-per-gb'] ?? 0.000392;
        return (0, validations_1.validate)(schema, {
            ...globalConfig,
            'energy-per-gb': energyPerGB,
        });
    };
    /**
     * Checks for required fields in input.
     */
    const validateSingleInput = (input) => {
        const schema = zod_1.z
            .object({
            'memory/capacity': zod_1.z.number().gt(0),
            'memory/utilization': zod_1.z.number().min(0).max(100),
        })
            .refine(validations_1.allDefined, {
            message: 'All metrics, including memory/utilization, memory/capacity, energy-per-gb, and mem_util-out should be present.',
        });
        return (0, validations_1.validate)(schema, input);
    };
    return {
        metadata,
        execute,
    };
};
exports.EMem = EMem;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2UtbWVtL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUFzQjtBQUt0Qix3REFBNEQ7QUFFckQsTUFBTSxJQUFJLEdBQUcsQ0FBQyxZQUEwQixFQUFtQixFQUFFO0lBQ2xFLE1BQU0sUUFBUSxHQUFHO1FBQ2YsSUFBSSxFQUFFLFNBQVM7S0FDaEIsQ0FBQztJQUVGOztPQUVHO0lBQ0gsTUFBTSxPQUFPLEdBQUcsS0FBSyxFQUFFLE1BQXNCLEVBQUUsRUFBRTtRQUMvQyxNQUFNLHFCQUFxQixHQUFHLGNBQWMsRUFBRSxDQUFDO1FBRS9DLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQW1CLEVBQUUsRUFBRTtZQUN4QyxNQUFNLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM3QyxNQUFNLGdCQUFnQixHQUFpQixNQUFNLENBQUMsTUFBTSxDQUNsRCxFQUFFLEVBQ0YsU0FBUyxFQUNULHFCQUFxQixDQUN0QixDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEtBQUs7Z0JBQ1IsZUFBZSxFQUFFLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQzthQUNuRCxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7SUFFRjs7T0FFRztJQUNILE1BQU0sZUFBZSxHQUFHLENBQUMsS0FBbUIsRUFBRSxFQUFFO1FBQzlDLE1BQU0sRUFDSixpQkFBaUIsRUFBRSxXQUFXLEVBQzlCLG9CQUFvQixFQUFFLFVBQVUsRUFDaEMsZUFBZSxFQUFFLFdBQVcsR0FDN0IsR0FBRyxLQUFLLENBQUM7UUFFVixxQkFBcUI7UUFDckIsT0FBTyxXQUFXLEdBQUcsQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDLEdBQUcsV0FBVyxDQUFDO0lBQ3hELENBQUMsQ0FBQztJQUVGLE1BQU0sY0FBYyxHQUFHLEdBQUcsRUFBRTtRQUMxQixNQUFNLE1BQU0sR0FBRyxPQUFDLENBQUMsTUFBTSxDQUFDO1lBQ3RCLGVBQWUsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNsQyxDQUFDLENBQUM7UUFFSCxvR0FBb0c7UUFDcEcsTUFBTSxXQUFXLEdBQUcsWUFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLFFBQVEsQ0FBQztRQUU5RCxPQUFPLElBQUEsc0JBQVEsRUFBeUIsTUFBTSxFQUFFO1lBQzlDLEdBQUcsWUFBWTtZQUNmLGVBQWUsRUFBRSxXQUFXO1NBQzdCLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztJQUVGOztPQUVHO0lBQ0gsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLEtBQW1CLEVBQUUsRUFBRTtRQUNsRCxNQUFNLE1BQU0sR0FBRyxPQUFDO2FBQ2IsTUFBTSxDQUFDO1lBQ04saUJBQWlCLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkMsb0JBQW9CLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1NBQ2pELENBQUM7YUFDRCxNQUFNLENBQUMsd0JBQVUsRUFBRTtZQUNsQixPQUFPLEVBQ0wsZ0hBQWdIO1NBQ25ILENBQUMsQ0FBQztRQUVMLE9BQU8sSUFBQSxzQkFBUSxFQUF5QixNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDekQsQ0FBQyxDQUFDO0lBRUYsT0FBTztRQUNMLFFBQVE7UUFDUixPQUFPO0tBQ1IsQ0FBQztBQUNKLENBQUMsQ0FBQztBQTNFVyxRQUFBLElBQUksUUEyRWYiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3p9IGZyb20gJ3pvZCc7XG5cbmltcG9ydCB7UGx1Z2luSW50ZXJmYWNlfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7Q29uZmlnUGFyYW1zLCBQbHVnaW5QYXJhbXN9IGZyb20gJy4uLy4uL3R5cGVzL2NvbW1vbic7XG5cbmltcG9ydCB7dmFsaWRhdGUsIGFsbERlZmluZWR9IGZyb20gJy4uLy4uL3V0aWwvdmFsaWRhdGlvbnMnO1xuXG5leHBvcnQgY29uc3QgRU1lbSA9IChnbG9iYWxDb25maWc6IENvbmZpZ1BhcmFtcyk6IFBsdWdpbkludGVyZmFjZSA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgIGtpbmQ6ICdleGVjdXRlJyxcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB0b3RhbCBlbWlzc2lvbnMgZm9yIGEgbGlzdCBvZiBpbnB1dHMuXG4gICAqL1xuICBjb25zdCBleGVjdXRlID0gYXN5bmMgKGlucHV0czogUGx1Z2luUGFyYW1zW10pID0+IHtcbiAgICBjb25zdCB2YWxpZGF0ZWRHbG9iYWxDb25maWcgPSB2YWxpZGF0ZUNvbmZpZygpO1xuXG4gICAgcmV0dXJuIGlucHV0cy5tYXAoKGlucHV0OiBQbHVnaW5QYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IHNhZmVJbnB1dCA9IHZhbGlkYXRlU2luZ2xlSW5wdXQoaW5wdXQpO1xuICAgICAgY29uc3QgaW5wdXRXaXRoQ29uZmlnczogUGx1Z2luUGFyYW1zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIHNhZmVJbnB1dCxcbiAgICAgICAgdmFsaWRhdGVkR2xvYmFsQ29uZmlnXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbnB1dCxcbiAgICAgICAgJ21lbW9yeS9lbmVyZ3knOiBjYWxjdWxhdGVFbmVyZ3koaW5wdXRXaXRoQ29uZmlncyksXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBlbmVyZ3kgY29uc3VtcHRpb24gZm9yIGEgc2luZ2xlIGlucHV0LlxuICAgKi9cbiAgY29uc3QgY2FsY3VsYXRlRW5lcmd5ID0gKGlucHV0OiBQbHVnaW5QYXJhbXMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAnbWVtb3J5L2NhcGFjaXR5JzogdG90YWxNZW1vcnksXG4gICAgICAnbWVtb3J5L3V0aWxpemF0aW9uJzogbWVtb3J5VXRpbCxcbiAgICAgICdlbmVyZ3ktcGVyLWdiJzogZW5lcmd5UGVyR0IsXG4gICAgfSA9IGlucHV0O1xuXG4gICAgLy8gR0IgKiBrV2gvR0IgPT0ga1doXG4gICAgcmV0dXJuIHRvdGFsTWVtb3J5ICogKG1lbW9yeVV0aWwgLyAxMDApICogZW5lcmd5UGVyR0I7XG4gIH07XG5cbiAgY29uc3QgdmFsaWRhdGVDb25maWcgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2NoZW1hID0gei5vYmplY3Qoe1xuICAgICAgJ2VuZXJneS1wZXItZ2InOiB6Lm51bWJlcigpLmd0KDApLFxuICAgIH0pO1xuXG4gICAgLy9NYW51YWxseSBhZGQgZGVmYXVsdCB2YWx1ZSBmcm9tIENDRjogaHR0cHM6Ly93d3cuY2xvdWRjYXJib25mb290cHJpbnQub3JnL2RvY3MvbWV0aG9kb2xvZ3kvI21lbW9yeVxuICAgIGNvbnN0IGVuZXJneVBlckdCID0gZ2xvYmFsQ29uZmlnWydlbmVyZ3ktcGVyLWdiJ10gPz8gMC4wMDAzOTI7XG5cbiAgICByZXR1cm4gdmFsaWRhdGU8ei5pbmZlcjx0eXBlb2Ygc2NoZW1hPj4oc2NoZW1hLCB7XG4gICAgICAuLi5nbG9iYWxDb25maWcsXG4gICAgICAnZW5lcmd5LXBlci1nYic6IGVuZXJneVBlckdCLFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgZm9yIHJlcXVpcmVkIGZpZWxkcyBpbiBpbnB1dC5cbiAgICovXG4gIGNvbnN0IHZhbGlkYXRlU2luZ2xlSW5wdXQgPSAoaW5wdXQ6IFBsdWdpblBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHNjaGVtYSA9IHpcbiAgICAgIC5vYmplY3Qoe1xuICAgICAgICAnbWVtb3J5L2NhcGFjaXR5Jzogei5udW1iZXIoKS5ndCgwKSxcbiAgICAgICAgJ21lbW9yeS91dGlsaXphdGlvbic6IHoubnVtYmVyKCkubWluKDApLm1heCgxMDApLFxuICAgICAgfSlcbiAgICAgIC5yZWZpbmUoYWxsRGVmaW5lZCwge1xuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdBbGwgbWV0cmljcywgaW5jbHVkaW5nIG1lbW9yeS91dGlsaXphdGlvbiwgbWVtb3J5L2NhcGFjaXR5LCBlbmVyZ3ktcGVyLWdiLCBhbmQgbWVtX3V0aWwtb3V0IHNob3VsZCBiZSBwcmVzZW50LicsXG4gICAgICB9KTtcblxuICAgIHJldHVybiB2YWxpZGF0ZTx6LmluZmVyPHR5cGVvZiBzY2hlbWE+PihzY2hlbWEsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1ldGFkYXRhLFxuICAgIGV4ZWN1dGUsXG4gIH07XG59O1xuIl19