"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aggregate = void 0;
const aggregation_helper_1 = require("../util/aggregation-helper");
/**
 * Gets `i`th element from all children outputs and collects them in single array.
 */
const getIthElementsFromChildren = (children, i) => {
    const values = Object.values(children);
    return values.map((value) => {
        const output = value.outputs;
        return output[i];
    });
};
/**
 * 1. Gets the i'th element from each childrens outputs (treating children as rows and we are after a column of data).
 * 2. Now we just aggregate over the `ithSliceOfOutputs` the same as we did for the normal outputs.
 */
const temporalAggregation = (node, metrics) => {
    const outputs = [];
    const values = Object.values(node.children);
    for (let i = 0; i < values[0].outputs.length; i++) {
        const ithSliceOfOutputs = getIthElementsFromChildren(node.children, i);
        outputs.push((0, aggregation_helper_1.aggregateInputsIntoOne)(ithSliceOfOutputs, metrics, true));
    }
    return outputs;
};
/**
 * Navigates the tree depth first, bottom up,
 *  left to right aggregating the component nodes and then the grouping nodes will be aggregated
 *  only when all their child nodes have been aggregated.
 * 1. Aggregates all the children.
 * 2. At this point you can be positive all your children have been aggregated and so you can now work on aggregating yourself.
 * 3. It's component node, Ð°ggregates just the outputs of THIS component node (horizontal/component aggregation).
 * 4. Else it's grouping node, first does temporal aggregation. This assumes everything is on the same time-grid.
 *    The outputs of the grouping node are the aggregated time bucketed outputs of it's children.
 * 5. Now a grouping node has it's own outputs, it can horizotnally aggregate them.
 */
const aggregateNode = (node, aggregationParams) => {
    const metrics = aggregationParams.metrics;
    const type = aggregationParams.type;
    if (node.children) {
        for (const child in node.children) {
            aggregateNode(node.children[child], aggregationParams);
        }
    }
    if (!node.children) {
        if (type === 'horizontal' || type === 'both') {
            node.aggregated = (0, aggregation_helper_1.aggregateInputsIntoOne)(node.outputs, metrics);
        }
    }
    else {
        if (type === 'vertical' || type === 'both') {
            const outputs = temporalAggregation(node, metrics);
            node.outputs = outputs;
            node.aggregated = (0, aggregation_helper_1.aggregateInputsIntoOne)(outputs, metrics);
        }
    }
};
/**
 * If aggregation is disabled, then returns given `tree`.
 * Otherwise creates copy of the tree, then applies aggregation to it.
 */
const aggregate = (tree, aggregationParams) => {
    if (!aggregationParams || !aggregationParams.type) {
        return tree;
    }
    const copyOfTree = structuredClone(tree);
    aggregateNode(copyOfTree, aggregationParams);
    return copyOfTree;
};
exports.aggregate = aggregate;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWdncmVnYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9hZ2dyZWdhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUVBQWtFO0FBS2xFOztHQUVHO0FBQ0gsTUFBTSwwQkFBMEIsR0FBRyxDQUFDLFFBQWEsRUFBRSxDQUFTLEVBQUUsRUFBRTtJQUM5RCxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBRXZDLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQVUsRUFBRSxFQUFFO1FBQy9CLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7UUFFN0IsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkIsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUM7QUFFRjs7O0dBR0c7QUFDSCxNQUFNLG1CQUFtQixHQUFHLENBQUMsSUFBUyxFQUFFLE9BQWlCLEVBQUUsRUFBRTtJQUMzRCxNQUFNLE9BQU8sR0FBbUIsRUFBRSxDQUFDO0lBQ25DLE1BQU0sTUFBTSxHQUFRLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBRWpELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNqRCxNQUFNLGlCQUFpQixHQUFHLDBCQUEwQixDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdkUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFBLDJDQUFzQixFQUFDLGlCQUFpQixFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQ3hFO0lBRUQsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQyxDQUFDO0FBRUY7Ozs7Ozs7Ozs7R0FVRztBQUNILE1BQU0sYUFBYSxHQUFHLENBQUMsSUFBUyxFQUFFLGlCQUF3QyxFQUFFLEVBQUU7SUFDNUUsTUFBTSxPQUFPLEdBQUcsaUJBQWtCLENBQUMsT0FBTyxDQUFDO0lBQzNDLE1BQU0sSUFBSSxHQUFHLGlCQUFrQixDQUFDLElBQUksQ0FBQztJQUVyQyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDakIsS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLGlCQUFpQixDQUFDLENBQUM7U0FDeEQ7S0FDRjtJQUVELElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1FBQ2xCLElBQUksSUFBSSxLQUFLLFlBQVksSUFBSSxJQUFJLEtBQUssTUFBTSxFQUFFO1lBQzVDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBQSwyQ0FBc0IsRUFBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2pFO0tBQ0Y7U0FBTTtRQUNMLElBQUksSUFBSSxLQUFLLFVBQVUsSUFBSSxJQUFJLEtBQUssTUFBTSxFQUFFO1lBQzFDLE1BQU0sT0FBTyxHQUFHLG1CQUFtQixDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztZQUN2QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUEsMkNBQXNCLEVBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQzVEO0tBQ0Y7QUFDSCxDQUFDLENBQUM7QUFFRjs7O0dBR0c7QUFDSSxNQUFNLFNBQVMsR0FBRyxDQUFDLElBQVMsRUFBRSxpQkFBb0MsRUFBRSxFQUFFO0lBQzNFLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRTtRQUNqRCxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pDLGFBQWEsQ0FBQyxVQUFVLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUU3QyxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDLENBQUM7QUFUVyxRQUFBLFNBQVMsYUFTcEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2FnZ3JlZ2F0ZUlucHV0c0ludG9PbmV9IGZyb20gJy4uL3V0aWwvYWdncmVnYXRpb24taGVscGVyJztcblxuaW1wb3J0IHtQbHVnaW5QYXJhbXN9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZSc7XG5pbXBvcnQge0FnZ3JlZ2F0aW9uUGFyYW1zLCBBZ2dyZWdhdGlvblBhcmFtc1N1cmV9IGZyb20gJy4uL3R5cGVzL21hbmlmZXN0JztcblxuLyoqXG4gKiBHZXRzIGBpYHRoIGVsZW1lbnQgZnJvbSBhbGwgY2hpbGRyZW4gb3V0cHV0cyBhbmQgY29sbGVjdHMgdGhlbSBpbiBzaW5nbGUgYXJyYXkuXG4gKi9cbmNvbnN0IGdldEl0aEVsZW1lbnRzRnJvbUNoaWxkcmVuID0gKGNoaWxkcmVuOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoaWxkcmVuKTtcblxuICByZXR1cm4gdmFsdWVzLm1hcCgodmFsdWU6IGFueSkgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IHZhbHVlLm91dHB1dHM7XG5cbiAgICByZXR1cm4gb3V0cHV0W2ldO1xuICB9KTtcbn07XG5cbi8qKlxuICogMS4gR2V0cyB0aGUgaSd0aCBlbGVtZW50IGZyb20gZWFjaCBjaGlsZHJlbnMgb3V0cHV0cyAodHJlYXRpbmcgY2hpbGRyZW4gYXMgcm93cyBhbmQgd2UgYXJlIGFmdGVyIGEgY29sdW1uIG9mIGRhdGEpLlxuICogMi4gTm93IHdlIGp1c3QgYWdncmVnYXRlIG92ZXIgdGhlIGBpdGhTbGljZU9mT3V0cHV0c2AgdGhlIHNhbWUgYXMgd2UgZGlkIGZvciB0aGUgbm9ybWFsIG91dHB1dHMuXG4gKi9cbmNvbnN0IHRlbXBvcmFsQWdncmVnYXRpb24gPSAobm9kZTogYW55LCBtZXRyaWNzOiBzdHJpbmdbXSkgPT4ge1xuICBjb25zdCBvdXRwdXRzOiBQbHVnaW5QYXJhbXNbXSA9IFtdO1xuICBjb25zdCB2YWx1ZXM6IGFueSA9IE9iamVjdC52YWx1ZXMobm9kZS5jaGlsZHJlbik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXNbMF0ub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGl0aFNsaWNlT2ZPdXRwdXRzID0gZ2V0SXRoRWxlbWVudHNGcm9tQ2hpbGRyZW4obm9kZS5jaGlsZHJlbiwgaSk7XG4gICAgb3V0cHV0cy5wdXNoKGFnZ3JlZ2F0ZUlucHV0c0ludG9PbmUoaXRoU2xpY2VPZk91dHB1dHMsIG1ldHJpY3MsIHRydWUpKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRzO1xufTtcblxuLyoqXG4gKiBOYXZpZ2F0ZXMgdGhlIHRyZWUgZGVwdGggZmlyc3QsIGJvdHRvbSB1cCxcbiAqICBsZWZ0IHRvIHJpZ2h0IGFnZ3JlZ2F0aW5nIHRoZSBjb21wb25lbnQgbm9kZXMgYW5kIHRoZW4gdGhlIGdyb3VwaW5nIG5vZGVzIHdpbGwgYmUgYWdncmVnYXRlZFxuICogIG9ubHkgd2hlbiBhbGwgdGhlaXIgY2hpbGQgbm9kZXMgaGF2ZSBiZWVuIGFnZ3JlZ2F0ZWQuXG4gKiAxLiBBZ2dyZWdhdGVzIGFsbCB0aGUgY2hpbGRyZW4uXG4gKiAyLiBBdCB0aGlzIHBvaW50IHlvdSBjYW4gYmUgcG9zaXRpdmUgYWxsIHlvdXIgY2hpbGRyZW4gaGF2ZSBiZWVuIGFnZ3JlZ2F0ZWQgYW5kIHNvIHlvdSBjYW4gbm93IHdvcmsgb24gYWdncmVnYXRpbmcgeW91cnNlbGYuXG4gKiAzLiBJdCdzIGNvbXBvbmVudCBub2RlLCDQsGdncmVnYXRlcyBqdXN0IHRoZSBvdXRwdXRzIG9mIFRISVMgY29tcG9uZW50IG5vZGUgKGhvcml6b250YWwvY29tcG9uZW50IGFnZ3JlZ2F0aW9uKS5cbiAqIDQuIEVsc2UgaXQncyBncm91cGluZyBub2RlLCBmaXJzdCBkb2VzIHRlbXBvcmFsIGFnZ3JlZ2F0aW9uLiBUaGlzIGFzc3VtZXMgZXZlcnl0aGluZyBpcyBvbiB0aGUgc2FtZSB0aW1lLWdyaWQuXG4gKiAgICBUaGUgb3V0cHV0cyBvZiB0aGUgZ3JvdXBpbmcgbm9kZSBhcmUgdGhlIGFnZ3JlZ2F0ZWQgdGltZSBidWNrZXRlZCBvdXRwdXRzIG9mIGl0J3MgY2hpbGRyZW4uXG4gKiA1LiBOb3cgYSBncm91cGluZyBub2RlIGhhcyBpdCdzIG93biBvdXRwdXRzLCBpdCBjYW4gaG9yaXpvdG5hbGx5IGFnZ3JlZ2F0ZSB0aGVtLlxuICovXG5jb25zdCBhZ2dyZWdhdGVOb2RlID0gKG5vZGU6IGFueSwgYWdncmVnYXRpb25QYXJhbXM6IEFnZ3JlZ2F0aW9uUGFyYW1zU3VyZSkgPT4ge1xuICBjb25zdCBtZXRyaWNzID0gYWdncmVnYXRpb25QYXJhbXMhLm1ldHJpY3M7XG4gIGNvbnN0IHR5cGUgPSBhZ2dyZWdhdGlvblBhcmFtcyEudHlwZTtcblxuICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgIGZvciAoY29uc3QgY2hpbGQgaW4gbm9kZS5jaGlsZHJlbikge1xuICAgICAgYWdncmVnYXRlTm9kZShub2RlLmNoaWxkcmVuW2NoaWxkXSwgYWdncmVnYXRpb25QYXJhbXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgIGlmICh0eXBlID09PSAnaG9yaXpvbnRhbCcgfHwgdHlwZSA9PT0gJ2JvdGgnKSB7XG4gICAgICBub2RlLmFnZ3JlZ2F0ZWQgPSBhZ2dyZWdhdGVJbnB1dHNJbnRvT25lKG5vZGUub3V0cHV0cywgbWV0cmljcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlID09PSAndmVydGljYWwnIHx8IHR5cGUgPT09ICdib3RoJykge1xuICAgICAgY29uc3Qgb3V0cHV0cyA9IHRlbXBvcmFsQWdncmVnYXRpb24obm9kZSwgbWV0cmljcyk7XG4gICAgICBub2RlLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgbm9kZS5hZ2dyZWdhdGVkID0gYWdncmVnYXRlSW5wdXRzSW50b09uZShvdXRwdXRzLCBtZXRyaWNzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSWYgYWdncmVnYXRpb24gaXMgZGlzYWJsZWQsIHRoZW4gcmV0dXJucyBnaXZlbiBgdHJlZWAuXG4gKiBPdGhlcndpc2UgY3JlYXRlcyBjb3B5IG9mIHRoZSB0cmVlLCB0aGVuIGFwcGxpZXMgYWdncmVnYXRpb24gdG8gaXQuXG4gKi9cbmV4cG9ydCBjb25zdCBhZ2dyZWdhdGUgPSAodHJlZTogYW55LCBhZ2dyZWdhdGlvblBhcmFtczogQWdncmVnYXRpb25QYXJhbXMpID0+IHtcbiAgaWYgKCFhZ2dyZWdhdGlvblBhcmFtcyB8fCAhYWdncmVnYXRpb25QYXJhbXMudHlwZSkge1xuICAgIHJldHVybiB0cmVlO1xuICB9XG5cbiAgY29uc3QgY29weU9mVHJlZSA9IHN0cnVjdHVyZWRDbG9uZSh0cmVlKTtcbiAgYWdncmVnYXRlTm9kZShjb3B5T2ZUcmVlLCBhZ2dyZWdhdGlvblBhcmFtcyk7XG5cbiAgcmV0dXJuIGNvcHlPZlRyZWU7XG59O1xuIl19