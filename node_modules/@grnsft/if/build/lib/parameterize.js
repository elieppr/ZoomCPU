"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parameterize = void 0;
const logger_1 = require("../util/logger");
const config_1 = require("../config");
const log_memoize_1 = require("../util/log-memoize");
const { REJECTING_OVERRIDE, UNKNOWN_PARAM } = config_1.STRINGS;
/**
 * Parameters manager. Provides get aggregation method and combine functionality.
 */
const Parametrize = () => {
    let parametersStorage = config_1.PARAMETERS;
    /**
     * Returns aggregation method for given `unitName`. If doesn't exist then returns value `sum`.
     */
    const getAggregationMethod = (unitName) => {
        if (`${unitName}` in parametersStorage) {
            return config_1.PARAMETERS[unitName].aggregation;
        }
        (0, log_memoize_1.memoizedLog)(logger_1.logger.warn, UNKNOWN_PARAM(unitName));
        return 'sum';
    };
    /**
     * Checks if additional parameters are provided in context.
     * If so, then checks if they are coincident with default ones and exits with warning message.
     * Otherwise appends context based parameters to defaults.
     */
    const combine = (contextParameters, parameters) => {
        if (contextParameters) {
            contextParameters.forEach(param => {
                if (`${param.name}` in parameters) {
                    logger_1.logger.warn(REJECTING_OVERRIDE);
                    return;
                }
                const { description, unit, aggregation, name } = param;
                parameters[name] = {
                    description,
                    unit,
                    aggregation,
                };
            });
        }
        parametersStorage = parameters;
    };
    return {
        combine,
        getAggregationMethod,
    };
};
exports.parameterize = Parametrize();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyYW1ldGVyaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9wYXJhbWV0ZXJpemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMkNBQXNDO0FBRXRDLHNDQUE4QztBQUc5QyxxREFBZ0Q7QUFFaEQsTUFBTSxFQUFDLGtCQUFrQixFQUFFLGFBQWEsRUFBQyxHQUFHLGdCQUFPLENBQUM7QUFFcEQ7O0dBRUc7QUFDSCxNQUFNLFdBQVcsR0FBRyxHQUFHLEVBQUU7SUFDdkIsSUFBSSxpQkFBaUIsR0FBRyxtQkFBVSxDQUFDO0lBRW5DOztPQUVHO0lBQ0gsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLFFBQWdCLEVBQUUsRUFBRTtRQUNoRCxJQUFJLEdBQUcsUUFBUSxFQUFFLElBQUksaUJBQWlCLEVBQUU7WUFDdEMsT0FBTyxtQkFBVSxDQUFDLFFBQW1DLENBQUMsQ0FBQyxXQUFXLENBQUM7U0FDcEU7UUFFRCxJQUFBLHlCQUFXLEVBQUMsZUFBTSxDQUFDLElBQUksRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUVsRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUMsQ0FBQztJQUVGOzs7O09BSUc7SUFDSCxNQUFNLE9BQU8sR0FBRyxDQUNkLGlCQUF5RCxFQUN6RCxVQUFlLEVBQ2YsRUFBRTtRQUNGLElBQUksaUJBQWlCLEVBQUU7WUFDckIsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUNoQyxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLFVBQVUsRUFBRTtvQkFDakMsZUFBTSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO29CQUVoQyxPQUFPO2lCQUNSO2dCQUVELE1BQU0sRUFBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUMsR0FBRyxLQUFLLENBQUM7Z0JBRXJELFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRztvQkFDakIsV0FBVztvQkFDWCxJQUFJO29CQUNKLFdBQVc7aUJBQ1osQ0FBQztZQUNKLENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxpQkFBaUIsR0FBRyxVQUFVLENBQUM7SUFDakMsQ0FBQyxDQUFDO0lBRUYsT0FBTztRQUNMLE9BQU87UUFDUCxvQkFBb0I7S0FDckIsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVXLFFBQUEsWUFBWSxHQUFHLFdBQVcsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWwvbG9nZ2VyJztcblxuaW1wb3J0IHtTVFJJTkdTLCBQQVJBTUVURVJTfSBmcm9tICcuLi9jb25maWcnO1xuXG5pbXBvcnQge01hbmlmZXN0UGFyYW1ldGVyfSBmcm9tICcuLi90eXBlcy9tYW5pZmVzdCc7XG5pbXBvcnQge21lbW9pemVkTG9nfSBmcm9tICcuLi91dGlsL2xvZy1tZW1vaXplJztcblxuY29uc3Qge1JFSkVDVElOR19PVkVSUklERSwgVU5LTk9XTl9QQVJBTX0gPSBTVFJJTkdTO1xuXG4vKipcbiAqIFBhcmFtZXRlcnMgbWFuYWdlci4gUHJvdmlkZXMgZ2V0IGFnZ3JlZ2F0aW9uIG1ldGhvZCBhbmQgY29tYmluZSBmdW5jdGlvbmFsaXR5LlxuICovXG5jb25zdCBQYXJhbWV0cml6ZSA9ICgpID0+IHtcbiAgbGV0IHBhcmFtZXRlcnNTdG9yYWdlID0gUEFSQU1FVEVSUztcblxuICAvKipcbiAgICogUmV0dXJucyBhZ2dyZWdhdGlvbiBtZXRob2QgZm9yIGdpdmVuIGB1bml0TmFtZWAuIElmIGRvZXNuJ3QgZXhpc3QgdGhlbiByZXR1cm5zIHZhbHVlIGBzdW1gLlxuICAgKi9cbiAgY29uc3QgZ2V0QWdncmVnYXRpb25NZXRob2QgPSAodW5pdE5hbWU6IHN0cmluZykgPT4ge1xuICAgIGlmIChgJHt1bml0TmFtZX1gIGluIHBhcmFtZXRlcnNTdG9yYWdlKSB7XG4gICAgICByZXR1cm4gUEFSQU1FVEVSU1t1bml0TmFtZSBhcyBrZXlvZiB0eXBlb2YgUEFSQU1FVEVSU10uYWdncmVnYXRpb247XG4gICAgfVxuXG4gICAgbWVtb2l6ZWRMb2cobG9nZ2VyLndhcm4sIFVOS05PV05fUEFSQU0odW5pdE5hbWUpKTtcblxuICAgIHJldHVybiAnc3VtJztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQgaW4gY29udGV4dC5cbiAgICogSWYgc28sIHRoZW4gY2hlY2tzIGlmIHRoZXkgYXJlIGNvaW5jaWRlbnQgd2l0aCBkZWZhdWx0IG9uZXMgYW5kIGV4aXRzIHdpdGggd2FybmluZyBtZXNzYWdlLlxuICAgKiBPdGhlcndpc2UgYXBwZW5kcyBjb250ZXh0IGJhc2VkIHBhcmFtZXRlcnMgdG8gZGVmYXVsdHMuXG4gICAqL1xuICBjb25zdCBjb21iaW5lID0gKFxuICAgIGNvbnRleHRQYXJhbWV0ZXJzOiBNYW5pZmVzdFBhcmFtZXRlcltdIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBwYXJhbWV0ZXJzOiBhbnlcbiAgKSA9PiB7XG4gICAgaWYgKGNvbnRleHRQYXJhbWV0ZXJzKSB7XG4gICAgICBjb250ZXh0UGFyYW1ldGVycy5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgICAgaWYgKGAke3BhcmFtLm5hbWV9YCBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oUkVKRUNUSU5HX09WRVJSSURFKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtkZXNjcmlwdGlvbiwgdW5pdCwgYWdncmVnYXRpb24sIG5hbWV9ID0gcGFyYW07XG5cbiAgICAgICAgcGFyYW1ldGVyc1tuYW1lXSA9IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICB1bml0LFxuICAgICAgICAgIGFnZ3JlZ2F0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGFyYW1ldGVyc1N0b3JhZ2UgPSBwYXJhbWV0ZXJzO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY29tYmluZSxcbiAgICBnZXRBZ2dyZWdhdGlvbk1ldGhvZCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJhbWV0ZXJpemUgPSBQYXJhbWV0cml6ZSgpO1xuIl19