"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exhaust = void 0;
/**
 * @todo This is temporary solution, will be refactored to support dynamic plugins.
 */
const export_csv_1 = require("../builtins/export-csv");
const export_csv_raw_1 = require("../builtins/export-csv-raw");
const export_log_1 = require("../builtins/export-log");
const export_yaml_1 = require("../builtins/export-yaml");
const errors_1 = require("../util/errors");
const config_1 = require("../config");
const { ModuleInitializationError } = errors_1.ERRORS;
const { INVALID_EXHAUST_PLUGIN } = config_1.STRINGS;
/**
 * Initialize exhaust plugins based on the provided config
 */
const initializeExhaustPlugins = (plugins) => plugins.map(initializeExhaustPlugin);
/**
 * factory method for exhaust plugins
 */
const initializeExhaustPlugin = (name) => {
    switch (name) {
        case 'yaml':
            return (0, export_yaml_1.ExportYaml)();
        case 'csv':
            return (0, export_csv_1.ExportCSV)();
        case 'csv-raw':
            return (0, export_csv_raw_1.ExportCSVRaw)();
        case 'log':
            return (0, export_log_1.ExportLog)();
        default:
            throw new ModuleInitializationError(INVALID_EXHAUST_PLUGIN(name));
    }
};
/**
 * Output manager - Exhaust.
 * Grabs output plugins from context, executes every.
 */
const exhaust = (tree, context, outputPath) => {
    const outputPlugins = context.initialize.outputs;
    if (!outputPlugins) {
        (0, export_log_1.ExportLog)().execute(tree, context);
        return;
    }
    const exhaustPlugins = initializeExhaustPlugins(outputPlugins);
    exhaustPlugins.forEach(plugin => plugin.execute(tree, context, outputPath));
};
exports.exhaust = exhaust;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhoYXVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZXhoYXVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILHVEQUFpRDtBQUNqRCwrREFBd0Q7QUFDeEQsdURBQWlEO0FBQ2pELHlEQUFtRDtBQUVuRCwyQ0FBc0M7QUFFdEMsc0NBQWtDO0FBS2xDLE1BQU0sRUFBQyx5QkFBeUIsRUFBQyxHQUFHLGVBQU0sQ0FBQztBQUMzQyxNQUFNLEVBQUMsc0JBQXNCLEVBQUMsR0FBRyxnQkFBTyxDQUFDO0FBRXpDOztHQUVHO0FBQ0gsTUFBTSx3QkFBd0IsR0FBRyxDQUFDLE9BQWlCLEVBQUUsRUFBRSxDQUNyRCxPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFFdkM7O0dBRUc7QUFDSCxNQUFNLHVCQUF1QixHQUFHLENBQUMsSUFBWSxFQUEwQixFQUFFO0lBQ3ZFLFFBQVEsSUFBSSxFQUFFO1FBQ1osS0FBSyxNQUFNO1lBQ1QsT0FBTyxJQUFBLHdCQUFVLEdBQUUsQ0FBQztRQUN0QixLQUFLLEtBQUs7WUFDUixPQUFPLElBQUEsc0JBQVMsR0FBRSxDQUFDO1FBQ3JCLEtBQUssU0FBUztZQUNaLE9BQU8sSUFBQSw2QkFBWSxHQUFFLENBQUM7UUFDeEIsS0FBSyxLQUFLO1lBQ1IsT0FBTyxJQUFBLHNCQUFTLEdBQUUsQ0FBQztRQUNyQjtZQUNFLE1BQU0sSUFBSSx5QkFBeUIsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQ3JFO0FBQ0gsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0ksTUFBTSxPQUFPLEdBQUcsQ0FBQyxJQUFTLEVBQUUsT0FBZ0IsRUFBRSxVQUFtQixFQUFFLEVBQUU7SUFDMUUsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUM7SUFFakQsSUFBSSxDQUFDLGFBQWEsRUFBRTtRQUNsQixJQUFBLHNCQUFTLEdBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRW5DLE9BQU87S0FDUjtJQUVELE1BQU0sY0FBYyxHQUFHLHdCQUF3QixDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQy9ELGNBQWMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUM5RSxDQUFDLENBQUM7QUFYVyxRQUFBLE9BQU8sV0FXbEIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0b2RvIFRoaXMgaXMgdGVtcG9yYXJ5IHNvbHV0aW9uLCB3aWxsIGJlIHJlZmFjdG9yZWQgdG8gc3VwcG9ydCBkeW5hbWljIHBsdWdpbnMuXG4gKi9cbmltcG9ydCB7RXhwb3J0Q1NWfSBmcm9tICcuLi9idWlsdGlucy9leHBvcnQtY3N2JztcbmltcG9ydCB7RXhwb3J0Q1NWUmF3fSBmcm9tICcuLi9idWlsdGlucy9leHBvcnQtY3N2LXJhdyc7XG5pbXBvcnQge0V4cG9ydExvZ30gZnJvbSAnLi4vYnVpbHRpbnMvZXhwb3J0LWxvZyc7XG5pbXBvcnQge0V4cG9ydFlhbWx9IGZyb20gJy4uL2J1aWx0aW5zL2V4cG9ydC15YW1sJztcblxuaW1wb3J0IHtFUlJPUlN9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcblxuaW1wb3J0IHtTVFJJTkdTfSBmcm9tICcuLi9jb25maWcnO1xuXG5pbXBvcnQge0V4aGF1c3RQbHVnaW5JbnRlcmZhY2V9IGZyb20gJy4uL3R5cGVzL2V4aGF1c3QtcGx1Z2luLWludGVyZmFjZSc7XG5pbXBvcnQge0NvbnRleHR9IGZyb20gJy4uL3R5cGVzL21hbmlmZXN0JztcblxuY29uc3Qge01vZHVsZUluaXRpYWxpemF0aW9uRXJyb3J9ID0gRVJST1JTO1xuY29uc3Qge0lOVkFMSURfRVhIQVVTVF9QTFVHSU59ID0gU1RSSU5HUztcblxuLyoqXG4gKiBJbml0aWFsaXplIGV4aGF1c3QgcGx1Z2lucyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29uZmlnXG4gKi9cbmNvbnN0IGluaXRpYWxpemVFeGhhdXN0UGx1Z2lucyA9IChwbHVnaW5zOiBzdHJpbmdbXSkgPT5cbiAgcGx1Z2lucy5tYXAoaW5pdGlhbGl6ZUV4aGF1c3RQbHVnaW4pO1xuXG4vKipcbiAqIGZhY3RvcnkgbWV0aG9kIGZvciBleGhhdXN0IHBsdWdpbnNcbiAqL1xuY29uc3QgaW5pdGlhbGl6ZUV4aGF1c3RQbHVnaW4gPSAobmFtZTogc3RyaW5nKTogRXhoYXVzdFBsdWdpbkludGVyZmFjZSA9PiB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3lhbWwnOlxuICAgICAgcmV0dXJuIEV4cG9ydFlhbWwoKTtcbiAgICBjYXNlICdjc3YnOlxuICAgICAgcmV0dXJuIEV4cG9ydENTVigpO1xuICAgIGNhc2UgJ2Nzdi1yYXcnOlxuICAgICAgcmV0dXJuIEV4cG9ydENTVlJhdygpO1xuICAgIGNhc2UgJ2xvZyc6XG4gICAgICByZXR1cm4gRXhwb3J0TG9nKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBNb2R1bGVJbml0aWFsaXphdGlvbkVycm9yKElOVkFMSURfRVhIQVVTVF9QTFVHSU4obmFtZSkpO1xuICB9XG59O1xuXG4vKipcbiAqIE91dHB1dCBtYW5hZ2VyIC0gRXhoYXVzdC5cbiAqIEdyYWJzIG91dHB1dCBwbHVnaW5zIGZyb20gY29udGV4dCwgZXhlY3V0ZXMgZXZlcnkuXG4gKi9cbmV4cG9ydCBjb25zdCBleGhhdXN0ID0gKHRyZWU6IGFueSwgY29udGV4dDogQ29udGV4dCwgb3V0cHV0UGF0aD86IHN0cmluZykgPT4ge1xuICBjb25zdCBvdXRwdXRQbHVnaW5zID0gY29udGV4dC5pbml0aWFsaXplLm91dHB1dHM7XG5cbiAgaWYgKCFvdXRwdXRQbHVnaW5zKSB7XG4gICAgRXhwb3J0TG9nKCkuZXhlY3V0ZSh0cmVlLCBjb250ZXh0KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGV4aGF1c3RQbHVnaW5zID0gaW5pdGlhbGl6ZUV4aGF1c3RQbHVnaW5zKG91dHB1dFBsdWdpbnMpO1xuICBleGhhdXN0UGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uZXhlY3V0ZSh0cmVlLCBjb250ZXh0LCBvdXRwdXRQYXRoKSk7XG59O1xuIl19