"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compute = void 0;
const helpers_1 = require("../util/helpers");
const interface_1 = require("../types/interface");
/**
 * Traverses all child nodes based on children grouping.
 */
const traverse = async (children, params) => {
    for (const child in children) {
        await computeNode(children[child], params);
    }
};
/**
 * Appends `default` values to `inputs`.
 */
const mergeDefaults = (inputs, defaults) => {
    if (inputs) {
        const response = defaults
            ? inputs.map(input => (0, helpers_1.mergeObjects)(input, defaults))
            : inputs;
        return response;
    }
    return defaults ? [defaults] : [];
};
/**
 * 1. If the node has it's own pipeline, defaults or config then use that,
 *    otherwise use whatever has been passed down from further up the tree.
 * 2. If it's a grouping node, then first of all computes all it's children.
 *    This is doing a depth first traversal.
 * 3. Otherwise merges the defaults into the inputs.
 * 4. Goes through the pipeline plugins, by checking if it's `execute` plugin. If so sets outputs.
 *    If is a `groupby` plugin, it will return child components rather than outputs.
 * 5. Since after `groupby`, there are new child components, then computes them.
 *    Note: `pipeline` now equals the remaining plu.gins to apply to each child
 */
const computeNode = async (node, params) => {
    const pipeline = (node.pipeline || params.pipeline);
    const config = node.config || params.config;
    const defaults = node.defaults || params.defaults;
    if (node.children) {
        return traverse(node.children, {
            ...params,
            pipeline,
            defaults,
            config,
        });
    }
    let storage = node.inputs;
    storage = mergeDefaults(storage, defaults);
    const pipelineCopy = structuredClone(pipeline);
    while (pipelineCopy.length !== 0) {
        const pluginName = pipelineCopy.shift();
        const plugin = params.plugins.get(pluginName);
        const nodeConfig = config && config[pluginName];
        if ((0, interface_1.isExecute)(plugin)) {
            storage = await plugin.execute(storage, nodeConfig);
            node.outputs = storage;
        }
        if ((0, interface_1.isGroupBy)(plugin)) {
            node.children = await plugin.execute(storage, nodeConfig);
            delete node.inputs;
            delete node.outputs;
            await traverse(node.children, {
                ...params,
                pipeline: pipelineCopy,
                defaults,
                config,
            });
            break;
        }
    }
};
/**
 * Creates copy of existing tree, then applies computing strategy.
 */
const compute = async (tree, params) => {
    const copyOfTree = structuredClone(tree);
    await computeNode(copyOfTree, params);
    return copyOfTree;
};
exports.compute = compute;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcHV0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29tcHV0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2Q0FBNkM7QUFHN0Msa0RBQXNFO0FBR3RFOztHQUVHO0FBQ0gsTUFBTSxRQUFRLEdBQUcsS0FBSyxFQUFFLFFBQWEsRUFBRSxNQUFjLEVBQUUsRUFBRTtJQUN2RCxLQUFLLE1BQU0sS0FBSyxJQUFJLFFBQVEsRUFBRTtRQUM1QixNQUFNLFdBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDNUM7QUFDSCxDQUFDLENBQUM7QUFFRjs7R0FFRztBQUNILE1BQU0sYUFBYSxHQUFHLENBQ3BCLE1BQXNCLEVBQ3RCLFFBQWtDLEVBQ2xDLEVBQUU7SUFDRixJQUFJLE1BQU0sRUFBRTtRQUNWLE1BQU0sUUFBUSxHQUFHLFFBQVE7WUFDdkIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFBLHNCQUFZLEVBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3BELENBQUMsQ0FBQyxNQUFNLENBQUM7UUFFWCxPQUFPLFFBQVEsQ0FBQztLQUNqQjtJQUVELE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDcEMsQ0FBQyxDQUFDO0FBRUY7Ozs7Ozs7Ozs7R0FVRztBQUNILE1BQU0sV0FBVyxHQUFHLEtBQUssRUFBRSxJQUFVLEVBQUUsTUFBYyxFQUFnQixFQUFFO0lBQ3JFLE1BQU0sUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFhLENBQUM7SUFDaEUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzVDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUVsRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDakIsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUM3QixHQUFHLE1BQU07WUFDVCxRQUFRO1lBQ1IsUUFBUTtZQUNSLE1BQU07U0FDUCxDQUFDLENBQUM7S0FDSjtJQUVELElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxNQUF3QixDQUFDO0lBQzVDLE9BQU8sR0FBRyxhQUFhLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzNDLE1BQU0sWUFBWSxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUUvQyxPQUFPLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ2hDLE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxLQUFLLEVBQVksQ0FBQztRQUNsRCxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM5QyxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRWhELElBQUksSUFBQSxxQkFBUyxFQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3JCLE9BQU8sR0FBRyxNQUFNLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQ3BELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1NBQ3hCO1FBRUQsSUFBSSxJQUFBLHFCQUFTLEVBQUMsTUFBTSxDQUFDLEVBQUU7WUFDckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLE1BQU0sQ0FBQyxPQUFPLENBQ2xDLE9BQU8sRUFDUCxVQUEyQixDQUM1QixDQUFDO1lBQ0YsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ25CLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUVwQixNQUFNLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUM1QixHQUFHLE1BQU07Z0JBQ1QsUUFBUSxFQUFFLFlBQVk7Z0JBQ3RCLFFBQVE7Z0JBQ1IsTUFBTTthQUNQLENBQUMsQ0FBQztZQUVILE1BQU07U0FDUDtLQUNGO0FBQ0gsQ0FBQyxDQUFDO0FBRUY7O0dBRUc7QUFDSSxNQUFNLE9BQU8sR0FBRyxLQUFLLEVBQUUsSUFBUyxFQUFFLE1BQXFCLEVBQUUsRUFBRTtJQUNoRSxNQUFNLFVBQVUsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFekMsTUFBTSxXQUFXLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRXRDLE9BQU8sVUFBVSxDQUFDO0FBQ3BCLENBQUMsQ0FBQztBQU5XLFFBQUEsT0FBTyxXQU1sQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7bWVyZ2VPYmplY3RzfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xuXG5pbXBvcnQge0NvbXB1dGVQYXJhbXMsIE5vZGUsIFBhcmFtc30gZnJvbSAnLi4vdHlwZXMvY29tcHV0ZSc7XG5pbXBvcnQge1BsdWdpblBhcmFtcywgaXNFeGVjdXRlLCBpc0dyb3VwQnl9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZSc7XG5pbXBvcnQge0dyb3VwQnlDb25maWd9IGZyb20gJy4uL3R5cGVzL2dyb3VwLWJ5JztcblxuLyoqXG4gKiBUcmF2ZXJzZXMgYWxsIGNoaWxkIG5vZGVzIGJhc2VkIG9uIGNoaWxkcmVuIGdyb3VwaW5nLlxuICovXG5jb25zdCB0cmF2ZXJzZSA9IGFzeW5jIChjaGlsZHJlbjogYW55LCBwYXJhbXM6IFBhcmFtcykgPT4ge1xuICBmb3IgKGNvbnN0IGNoaWxkIGluIGNoaWxkcmVuKSB7XG4gICAgYXdhaXQgY29tcHV0ZU5vZGUoY2hpbGRyZW5bY2hpbGRdLCBwYXJhbXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYGRlZmF1bHRgIHZhbHVlcyB0byBgaW5wdXRzYC5cbiAqL1xuY29uc3QgbWVyZ2VEZWZhdWx0cyA9IChcbiAgaW5wdXRzOiBQbHVnaW5QYXJhbXNbXSxcbiAgZGVmYXVsdHM6IFBsdWdpblBhcmFtcyB8IHVuZGVmaW5lZFxuKSA9PiB7XG4gIGlmIChpbnB1dHMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGRlZmF1bHRzXG4gICAgICA/IGlucHV0cy5tYXAoaW5wdXQgPT4gbWVyZ2VPYmplY3RzKGlucHV0LCBkZWZhdWx0cykpXG4gICAgICA6IGlucHV0cztcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0cyA/IFtkZWZhdWx0c10gOiBbXTtcbn07XG5cbi8qKlxuICogMS4gSWYgdGhlIG5vZGUgaGFzIGl0J3Mgb3duIHBpcGVsaW5lLCBkZWZhdWx0cyBvciBjb25maWcgdGhlbiB1c2UgdGhhdCxcbiAqICAgIG90aGVyd2lzZSB1c2Ugd2hhdGV2ZXIgaGFzIGJlZW4gcGFzc2VkIGRvd24gZnJvbSBmdXJ0aGVyIHVwIHRoZSB0cmVlLlxuICogMi4gSWYgaXQncyBhIGdyb3VwaW5nIG5vZGUsIHRoZW4gZmlyc3Qgb2YgYWxsIGNvbXB1dGVzIGFsbCBpdCdzIGNoaWxkcmVuLlxuICogICAgVGhpcyBpcyBkb2luZyBhIGRlcHRoIGZpcnN0IHRyYXZlcnNhbC5cbiAqIDMuIE90aGVyd2lzZSBtZXJnZXMgdGhlIGRlZmF1bHRzIGludG8gdGhlIGlucHV0cy5cbiAqIDQuIEdvZXMgdGhyb3VnaCB0aGUgcGlwZWxpbmUgcGx1Z2lucywgYnkgY2hlY2tpbmcgaWYgaXQncyBgZXhlY3V0ZWAgcGx1Z2luLiBJZiBzbyBzZXRzIG91dHB1dHMuXG4gKiAgICBJZiBpcyBhIGBncm91cGJ5YCBwbHVnaW4sIGl0IHdpbGwgcmV0dXJuIGNoaWxkIGNvbXBvbmVudHMgcmF0aGVyIHRoYW4gb3V0cHV0cy5cbiAqIDUuIFNpbmNlIGFmdGVyIGBncm91cGJ5YCwgdGhlcmUgYXJlIG5ldyBjaGlsZCBjb21wb25lbnRzLCB0aGVuIGNvbXB1dGVzIHRoZW0uXG4gKiAgICBOb3RlOiBgcGlwZWxpbmVgIG5vdyBlcXVhbHMgdGhlIHJlbWFpbmluZyBwbHUuZ2lucyB0byBhcHBseSB0byBlYWNoIGNoaWxkXG4gKi9cbmNvbnN0IGNvbXB1dGVOb2RlID0gYXN5bmMgKG5vZGU6IE5vZGUsIHBhcmFtczogUGFyYW1zKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgY29uc3QgcGlwZWxpbmUgPSAobm9kZS5waXBlbGluZSB8fCBwYXJhbXMucGlwZWxpbmUpIGFzIHN0cmluZ1tdO1xuICBjb25zdCBjb25maWcgPSBub2RlLmNvbmZpZyB8fCBwYXJhbXMuY29uZmlnO1xuICBjb25zdCBkZWZhdWx0cyA9IG5vZGUuZGVmYXVsdHMgfHwgcGFyYW1zLmRlZmF1bHRzO1xuXG4gIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlKG5vZGUuY2hpbGRyZW4sIHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIHBpcGVsaW5lLFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBjb25maWcsXG4gICAgfSk7XG4gIH1cblxuICBsZXQgc3RvcmFnZSA9IG5vZGUuaW5wdXRzIGFzIFBsdWdpblBhcmFtc1tdO1xuICBzdG9yYWdlID0gbWVyZ2VEZWZhdWx0cyhzdG9yYWdlLCBkZWZhdWx0cyk7XG4gIGNvbnN0IHBpcGVsaW5lQ29weSA9IHN0cnVjdHVyZWRDbG9uZShwaXBlbGluZSk7XG5cbiAgd2hpbGUgKHBpcGVsaW5lQ29weS5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBwbHVnaW5OYW1lID0gcGlwZWxpbmVDb3B5LnNoaWZ0KCkgYXMgc3RyaW5nO1xuICAgIGNvbnN0IHBsdWdpbiA9IHBhcmFtcy5wbHVnaW5zLmdldChwbHVnaW5OYW1lKTtcbiAgICBjb25zdCBub2RlQ29uZmlnID0gY29uZmlnICYmIGNvbmZpZ1twbHVnaW5OYW1lXTtcblxuICAgIGlmIChpc0V4ZWN1dGUocGx1Z2luKSkge1xuICAgICAgc3RvcmFnZSA9IGF3YWl0IHBsdWdpbi5leGVjdXRlKHN0b3JhZ2UsIG5vZGVDb25maWcpO1xuICAgICAgbm9kZS5vdXRwdXRzID0gc3RvcmFnZTtcbiAgICB9XG5cbiAgICBpZiAoaXNHcm91cEJ5KHBsdWdpbikpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBhd2FpdCBwbHVnaW4uZXhlY3V0ZShcbiAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgbm9kZUNvbmZpZyBhcyBHcm91cEJ5Q29uZmlnXG4gICAgICApO1xuICAgICAgZGVsZXRlIG5vZGUuaW5wdXRzO1xuICAgICAgZGVsZXRlIG5vZGUub3V0cHV0cztcblxuICAgICAgYXdhaXQgdHJhdmVyc2Uobm9kZS5jaGlsZHJlbiwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHBpcGVsaW5lOiBwaXBlbGluZUNvcHksXG4gICAgICAgIGRlZmF1bHRzLFxuICAgICAgICBjb25maWcsXG4gICAgICB9KTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgY29weSBvZiBleGlzdGluZyB0cmVlLCB0aGVuIGFwcGxpZXMgY29tcHV0aW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgY29tcHV0ZSA9IGFzeW5jICh0cmVlOiBhbnksIHBhcmFtczogQ29tcHV0ZVBhcmFtcykgPT4ge1xuICBjb25zdCBjb3B5T2ZUcmVlID0gc3RydWN0dXJlZENsb25lKHRyZWUpO1xuXG4gIGF3YWl0IGNvbXB1dGVOb2RlKGNvcHlPZlRyZWUsIHBhcmFtcyk7XG5cbiAgcmV0dXJuIGNvcHlPZlRyZWU7XG59O1xuIl19