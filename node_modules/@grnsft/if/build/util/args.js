"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseArgs = void 0;
const path = __importStar(require("path"));
const ts_command_line_args_1 = require("ts-command-line-args");
const yaml_1 = require("./yaml");
const errors_1 = require("./errors");
const config_1 = require("../config");
const { CliInputError } = errors_1.ERRORS;
const { impact } = config_1.CONFIG;
const { ARGS, HELP } = impact;
const { FILE_IS_NOT_YAML, MANIFEST_IS_MISSING } = config_1.STRINGS;
/**
 * Validates process arguments
 */
const validateAndParseProcessArgs = () => {
    try {
        return (0, ts_command_line_args_1.parse)(ARGS);
    }
    catch (error) {
        if (error instanceof Error) {
            throw new CliInputError(error.message);
        }
        throw error;
    }
};
/**
 * Prepends process path to given `filePath`.
 */
const prependFullFilePath = (filePath) => {
    const processRunningPath = process.cwd();
    if (path.isAbsolute(filePath)) {
        return filePath;
    }
    return path.normalize(`${processRunningPath}/${filePath}`);
};
/**
 * 1. Parses process arguments like `manifest`, `output`, `override-params` and `help`.
 * 2. Checks if `help` param is provided, then logs help message and exits.
 * 3. Otherwise checks if `manifest` param is there, then processes with checking if it's a yaml file.
 *    If it is, then returns object containing full path.
 * 4. If params are missing or invalid, then rejects with `CliInputError`.
 */
const parseArgs = () => {
    const { manifest, output, 'override-params': overrideParams, help, } = validateAndParseProcessArgs();
    if (help) {
        console.info(HELP);
        return;
    }
    if (manifest) {
        if ((0, yaml_1.checkIfFileIsYaml)(manifest)) {
            return {
                inputPath: prependFullFilePath(manifest),
                ...(output && { outputPath: prependFullFilePath(output) }),
                ...(overrideParams && { paramPath: overrideParams }),
            };
        }
        throw new CliInputError(FILE_IS_NOT_YAML);
    }
    throw new CliInputError(MANIFEST_IS_MISSING);
};
exports.parseArgs = parseArgs;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJncy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2FyZ3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBNkI7QUFDN0IsK0RBQTJDO0FBRTNDLGlDQUF5QztBQUN6QyxxQ0FBZ0M7QUFFaEMsc0NBQTBDO0FBSTFDLE1BQU0sRUFBQyxhQUFhLEVBQUMsR0FBRyxlQUFNLENBQUM7QUFFL0IsTUFBTSxFQUFDLE1BQU0sRUFBQyxHQUFHLGVBQU0sQ0FBQztBQUN4QixNQUFNLEVBQUMsSUFBSSxFQUFFLElBQUksRUFBQyxHQUFHLE1BQU0sQ0FBQztBQUU1QixNQUFNLEVBQUMsZ0JBQWdCLEVBQUUsbUJBQW1CLEVBQUMsR0FBRyxnQkFBTyxDQUFDO0FBRXhEOztHQUVHO0FBQ0gsTUFBTSwyQkFBMkIsR0FBRyxHQUFHLEVBQUU7SUFDdkMsSUFBSTtRQUNGLE9BQU8sSUFBQSw0QkFBSyxFQUFzQixJQUFJLENBQUMsQ0FBQztLQUN6QztJQUFDLE9BQU8sS0FBSyxFQUFFO1FBQ2QsSUFBSSxLQUFLLFlBQVksS0FBSyxFQUFFO1lBQzFCLE1BQU0sSUFBSSxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3hDO1FBRUQsTUFBTSxLQUFLLENBQUM7S0FDYjtBQUNILENBQUMsQ0FBQztBQUVGOztHQUVHO0FBQ0gsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLFFBQWdCLEVBQUUsRUFBRTtJQUMvQyxNQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUV6QyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDN0IsT0FBTyxRQUFRLENBQUM7S0FDakI7SUFFRCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxrQkFBa0IsSUFBSSxRQUFRLEVBQUUsQ0FBQyxDQUFDO0FBQzdELENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNJLE1BQU0sU0FBUyxHQUFHLEdBQUcsRUFBRTtJQUM1QixNQUFNLEVBQ0osUUFBUSxFQUNSLE1BQU0sRUFDTixpQkFBaUIsRUFBRSxjQUFjLEVBQ2pDLElBQUksR0FDTCxHQUFHLDJCQUEyQixFQUFFLENBQUM7SUFFbEMsSUFBSSxJQUFJLEVBQUU7UUFDUixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25CLE9BQU87S0FDUjtJQUVELElBQUksUUFBUSxFQUFFO1FBQ1osSUFBSSxJQUFBLHdCQUFpQixFQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQy9CLE9BQU87Z0JBQ0wsU0FBUyxFQUFFLG1CQUFtQixDQUFDLFFBQVEsQ0FBQztnQkFDeEMsR0FBRyxDQUFDLE1BQU0sSUFBSSxFQUFDLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsRUFBQyxDQUFDO2dCQUN4RCxHQUFHLENBQUMsY0FBYyxJQUFJLEVBQUMsU0FBUyxFQUFFLGNBQWMsRUFBQyxDQUFDO2FBQ25ELENBQUM7U0FDSDtRQUVELE1BQU0sSUFBSSxhQUFhLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztLQUMzQztJQUVELE1BQU0sSUFBSSxhQUFhLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUMvQyxDQUFDLENBQUM7QUExQlcsUUFBQSxTQUFTLGFBMEJwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge3BhcnNlfSBmcm9tICd0cy1jb21tYW5kLWxpbmUtYXJncyc7XG5cbmltcG9ydCB7Y2hlY2tJZkZpbGVJc1lhbWx9IGZyb20gJy4veWFtbCc7XG5pbXBvcnQge0VSUk9SU30gZnJvbSAnLi9lcnJvcnMnO1xuXG5pbXBvcnQge0NPTkZJRywgU1RSSU5HU30gZnJvbSAnLi4vY29uZmlnJztcblxuaW1wb3J0IHtNYW5pZmVzdFByb2Nlc3NBcmdzfSBmcm9tICcuLi90eXBlcy9wcm9jZXNzLWFyZ3MnO1xuXG5jb25zdCB7Q2xpSW5wdXRFcnJvcn0gPSBFUlJPUlM7XG5cbmNvbnN0IHtpbXBhY3R9ID0gQ09ORklHO1xuY29uc3Qge0FSR1MsIEhFTFB9ID0gaW1wYWN0O1xuXG5jb25zdCB7RklMRV9JU19OT1RfWUFNTCwgTUFOSUZFU1RfSVNfTUlTU0lOR30gPSBTVFJJTkdTO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBwcm9jZXNzIGFyZ3VtZW50c1xuICovXG5jb25zdCB2YWxpZGF0ZUFuZFBhcnNlUHJvY2Vzc0FyZ3MgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBhcnNlPE1hbmlmZXN0UHJvY2Vzc0FyZ3M+KEFSR1MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgQ2xpSW5wdXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBQcmVwZW5kcyBwcm9jZXNzIHBhdGggdG8gZ2l2ZW4gYGZpbGVQYXRoYC5cbiAqL1xuY29uc3QgcHJlcGVuZEZ1bGxGaWxlUGF0aCA9IChmaWxlUGF0aDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHByb2Nlc3NSdW5uaW5nUGF0aCA9IHByb2Nlc3MuY3dkKCk7XG5cbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShmaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gZmlsZVBhdGg7XG4gIH1cblxuICByZXR1cm4gcGF0aC5ub3JtYWxpemUoYCR7cHJvY2Vzc1J1bm5pbmdQYXRofS8ke2ZpbGVQYXRofWApO1xufTtcblxuLyoqXG4gKiAxLiBQYXJzZXMgcHJvY2VzcyBhcmd1bWVudHMgbGlrZSBgbWFuaWZlc3RgLCBgb3V0cHV0YCwgYG92ZXJyaWRlLXBhcmFtc2AgYW5kIGBoZWxwYC5cbiAqIDIuIENoZWNrcyBpZiBgaGVscGAgcGFyYW0gaXMgcHJvdmlkZWQsIHRoZW4gbG9ncyBoZWxwIG1lc3NhZ2UgYW5kIGV4aXRzLlxuICogMy4gT3RoZXJ3aXNlIGNoZWNrcyBpZiBgbWFuaWZlc3RgIHBhcmFtIGlzIHRoZXJlLCB0aGVuIHByb2Nlc3NlcyB3aXRoIGNoZWNraW5nIGlmIGl0J3MgYSB5YW1sIGZpbGUuXG4gKiAgICBJZiBpdCBpcywgdGhlbiByZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGZ1bGwgcGF0aC5cbiAqIDQuIElmIHBhcmFtcyBhcmUgbWlzc2luZyBvciBpbnZhbGlkLCB0aGVuIHJlamVjdHMgd2l0aCBgQ2xpSW5wdXRFcnJvcmAuXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUFyZ3MgPSAoKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBtYW5pZmVzdCxcbiAgICBvdXRwdXQsXG4gICAgJ292ZXJyaWRlLXBhcmFtcyc6IG92ZXJyaWRlUGFyYW1zLFxuICAgIGhlbHAsXG4gIH0gPSB2YWxpZGF0ZUFuZFBhcnNlUHJvY2Vzc0FyZ3MoKTtcblxuICBpZiAoaGVscCkge1xuICAgIGNvbnNvbGUuaW5mbyhIRUxQKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobWFuaWZlc3QpIHtcbiAgICBpZiAoY2hlY2tJZkZpbGVJc1lhbWwobWFuaWZlc3QpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dFBhdGg6IHByZXBlbmRGdWxsRmlsZVBhdGgobWFuaWZlc3QpLFxuICAgICAgICAuLi4ob3V0cHV0ICYmIHtvdXRwdXRQYXRoOiBwcmVwZW5kRnVsbEZpbGVQYXRoKG91dHB1dCl9KSxcbiAgICAgICAgLi4uKG92ZXJyaWRlUGFyYW1zICYmIHtwYXJhbVBhdGg6IG92ZXJyaWRlUGFyYW1zfSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBDbGlJbnB1dEVycm9yKEZJTEVfSVNfTk9UX1lBTUwpO1xuICB9XG5cbiAgdGhyb3cgbmV3IENsaUlucHV0RXJyb3IoTUFOSUZFU1RfSVNfTUlTU0lORyk7XG59O1xuIl19