"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aggregateInputsIntoOne = void 0;
const errors_1 = require("../util/errors");
const parameterize_1 = require("../lib/parameterize");
const config_1 = require("../config");
const { InvalidAggregationParams } = errors_1.ERRORS;
const { INVALID_AGGREGATION_METHOD, METRIC_MISSING } = config_1.STRINGS;
const { AGGREGATION_ADDITIONAL_PARAMS } = config_1.CONFIG;
/**
 * Validates metrics array before applying aggregator.
 * If aggregation method is `none`, then throws error.
 */
const checkIfMetricsAreValid = (metrics) => {
    metrics.forEach(metric => {
        const method = parameterize_1.parameterize.getAggregationMethod(metric);
        if (method === 'none') {
            throw new InvalidAggregationParams(INVALID_AGGREGATION_METHOD(metric));
        }
    });
};
/**
 * Aggregates child node level metrics. Validates if metric aggregation type is `none`, then rejects with error.
 * Appends aggregation additional params to metrics. Otherwise iterates over inputs by aggregating per given `metrics`.
 */
const aggregateInputsIntoOne = (inputs, metrics, isTemporal) => {
    checkIfMetricsAreValid(metrics);
    const extendedMetrics = [...metrics, ...AGGREGATION_ADDITIONAL_PARAMS];
    return inputs.reduce((acc, input, index) => {
        for (const metric of extendedMetrics) {
            if (!(metric in input)) {
                throw new InvalidAggregationParams(METRIC_MISSING(metric, index));
            }
            /** Checks if metric is timestamp or duration, then adds to aggregated value. */
            if (AGGREGATION_ADDITIONAL_PARAMS.includes(metric)) {
                if (isTemporal) {
                    acc[metric] = input[metric];
                }
            }
            else {
                acc[metric] = acc[metric] ?? 0;
                acc[metric] += parseFloat(input[metric]);
                /** Checks for the last iteration. */
                if (index === inputs.length - 1) {
                    if (parameterize_1.parameterize.getAggregationMethod(metric) === 'avg') {
                        acc[metric] /= inputs.length;
                    }
                }
            }
        }
        return acc;
    }, {});
};
exports.aggregateInputsIntoOne = aggregateInputsIntoOne;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWdncmVnYXRpb24taGVscGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWwvYWdncmVnYXRpb24taGVscGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJDQUFzQztBQUN0QyxzREFBaUQ7QUFFakQsc0NBQTBDO0FBSzFDLE1BQU0sRUFBQyx3QkFBd0IsRUFBQyxHQUFHLGVBQU0sQ0FBQztBQUMxQyxNQUFNLEVBQUMsMEJBQTBCLEVBQUUsY0FBYyxFQUFDLEdBQUcsZ0JBQU8sQ0FBQztBQUM3RCxNQUFNLEVBQUMsNkJBQTZCLEVBQUMsR0FBRyxlQUFNLENBQUM7QUFFL0M7OztHQUdHO0FBQ0gsTUFBTSxzQkFBc0IsR0FBRyxDQUFDLE9BQWlCLEVBQUUsRUFBRTtJQUNuRCxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ3ZCLE1BQU0sTUFBTSxHQUFHLDJCQUFZLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFekQsSUFBSSxNQUFNLEtBQUssTUFBTSxFQUFFO1lBQ3JCLE1BQU0sSUFBSSx3QkFBd0IsQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQ3hFO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUM7QUFFRjs7O0dBR0c7QUFDSSxNQUFNLHNCQUFzQixHQUFHLENBQ3BDLE1BQXNCLEVBQ3RCLE9BQWlCLEVBQ2pCLFVBQW9CLEVBQ3BCLEVBQUU7SUFDRixzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNoQyxNQUFNLGVBQWUsR0FBRyxDQUFDLEdBQUcsT0FBTyxFQUFFLEdBQUcsNkJBQTZCLENBQUMsQ0FBQztJQUV2RSxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFO1FBQ3pDLEtBQUssTUFBTSxNQUFNLElBQUksZUFBZSxFQUFFO1lBQ3BDLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsRUFBRTtnQkFDdEIsTUFBTSxJQUFJLHdCQUF3QixDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUNuRTtZQUVELGdGQUFnRjtZQUNoRixJQUFJLDZCQUE2QixDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDbEQsSUFBSSxVQUFVLEVBQUU7b0JBQ2QsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDN0I7YUFDRjtpQkFBTTtnQkFDTCxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDL0IsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFFekMscUNBQXFDO2dCQUNyQyxJQUFJLEtBQUssS0FBSyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDL0IsSUFBSSwyQkFBWSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssRUFBRTt3QkFDdkQsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUM7cUJBQzlCO2lCQUNGO2FBQ0Y7U0FDRjtRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQyxFQUFFLEVBQXVCLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUM7QUFsQ1csUUFBQSxzQkFBc0IsMEJBa0NqQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RVJST1JTfSBmcm9tICcuLi91dGlsL2Vycm9ycyc7XG5pbXBvcnQge3BhcmFtZXRlcml6ZX0gZnJvbSAnLi4vbGliL3BhcmFtZXRlcml6ZSc7XG5cbmltcG9ydCB7Q09ORklHLCBTVFJJTkdTfSBmcm9tICcuLi9jb25maWcnO1xuXG5pbXBvcnQge0FnZ3JlZ2F0aW9uUmVzdWx0fSBmcm9tICcuLi90eXBlcy9hZ2dyZWdhdGlvbic7XG5pbXBvcnQge1BsdWdpblBhcmFtc30gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlJztcblxuY29uc3Qge0ludmFsaWRBZ2dyZWdhdGlvblBhcmFtc30gPSBFUlJPUlM7XG5jb25zdCB7SU5WQUxJRF9BR0dSRUdBVElPTl9NRVRIT0QsIE1FVFJJQ19NSVNTSU5HfSA9IFNUUklOR1M7XG5jb25zdCB7QUdHUkVHQVRJT05fQURESVRJT05BTF9QQVJBTVN9ID0gQ09ORklHO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBtZXRyaWNzIGFycmF5IGJlZm9yZSBhcHBseWluZyBhZ2dyZWdhdG9yLlxuICogSWYgYWdncmVnYXRpb24gbWV0aG9kIGlzIGBub25lYCwgdGhlbiB0aHJvd3MgZXJyb3IuXG4gKi9cbmNvbnN0IGNoZWNrSWZNZXRyaWNzQXJlVmFsaWQgPSAobWV0cmljczogc3RyaW5nW10pID0+IHtcbiAgbWV0cmljcy5mb3JFYWNoKG1ldHJpYyA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gcGFyYW1ldGVyaXplLmdldEFnZ3JlZ2F0aW9uTWV0aG9kKG1ldHJpYyk7XG5cbiAgICBpZiAobWV0aG9kID09PSAnbm9uZScpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWdncmVnYXRpb25QYXJhbXMoSU5WQUxJRF9BR0dSRUdBVElPTl9NRVRIT0QobWV0cmljKSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQWdncmVnYXRlcyBjaGlsZCBub2RlIGxldmVsIG1ldHJpY3MuIFZhbGlkYXRlcyBpZiBtZXRyaWMgYWdncmVnYXRpb24gdHlwZSBpcyBgbm9uZWAsIHRoZW4gcmVqZWN0cyB3aXRoIGVycm9yLlxuICogQXBwZW5kcyBhZ2dyZWdhdGlvbiBhZGRpdGlvbmFsIHBhcmFtcyB0byBtZXRyaWNzLiBPdGhlcndpc2UgaXRlcmF0ZXMgb3ZlciBpbnB1dHMgYnkgYWdncmVnYXRpbmcgcGVyIGdpdmVuIGBtZXRyaWNzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IGFnZ3JlZ2F0ZUlucHV0c0ludG9PbmUgPSAoXG4gIGlucHV0czogUGx1Z2luUGFyYW1zW10sXG4gIG1ldHJpY3M6IHN0cmluZ1tdLFxuICBpc1RlbXBvcmFsPzogYm9vbGVhblxuKSA9PiB7XG4gIGNoZWNrSWZNZXRyaWNzQXJlVmFsaWQobWV0cmljcyk7XG4gIGNvbnN0IGV4dGVuZGVkTWV0cmljcyA9IFsuLi5tZXRyaWNzLCAuLi5BR0dSRUdBVElPTl9BRERJVElPTkFMX1BBUkFNU107XG5cbiAgcmV0dXJuIGlucHV0cy5yZWR1Y2UoKGFjYywgaW5wdXQsIGluZGV4KSA9PiB7XG4gICAgZm9yIChjb25zdCBtZXRyaWMgb2YgZXh0ZW5kZWRNZXRyaWNzKSB7XG4gICAgICBpZiAoIShtZXRyaWMgaW4gaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWdncmVnYXRpb25QYXJhbXMoTUVUUklDX01JU1NJTkcobWV0cmljLCBpbmRleCkpO1xuICAgICAgfVxuXG4gICAgICAvKiogQ2hlY2tzIGlmIG1ldHJpYyBpcyB0aW1lc3RhbXAgb3IgZHVyYXRpb24sIHRoZW4gYWRkcyB0byBhZ2dyZWdhdGVkIHZhbHVlLiAqL1xuICAgICAgaWYgKEFHR1JFR0FUSU9OX0FERElUSU9OQUxfUEFSQU1TLmluY2x1ZGVzKG1ldHJpYykpIHtcbiAgICAgICAgaWYgKGlzVGVtcG9yYWwpIHtcbiAgICAgICAgICBhY2NbbWV0cmljXSA9IGlucHV0W21ldHJpY107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjY1ttZXRyaWNdID0gYWNjW21ldHJpY10gPz8gMDtcbiAgICAgICAgYWNjW21ldHJpY10gKz0gcGFyc2VGbG9hdChpbnB1dFttZXRyaWNdKTtcblxuICAgICAgICAvKiogQ2hlY2tzIGZvciB0aGUgbGFzdCBpdGVyYXRpb24uICovXG4gICAgICAgIGlmIChpbmRleCA9PT0gaW5wdXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpZiAocGFyYW1ldGVyaXplLmdldEFnZ3JlZ2F0aW9uTWV0aG9kKG1ldHJpYykgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICBhY2NbbWV0cmljXSAvPSBpbnB1dHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9IGFzIEFnZ3JlZ2F0aW9uUmVzdWx0KTtcbn07XG4iXX0=