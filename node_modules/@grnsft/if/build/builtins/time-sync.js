"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeSync = void 0;
const types_1 = require("node:util/types");
const luxon_1 = require("luxon");
const zod_1 = require("zod");
const parameterize_1 = require("../lib/parameterize");
const errors_1 = require("../util/errors");
const config_1 = require("../config");
const validations_1 = require("../util/validations");
const { InputValidationError } = errors_1.ERRORS;
const { INVALID_TIME_NORMALIZATION, INVALID_OBSERVATION_OVERLAP, AVOIDING_PADDING_BY_EDGES, } = config_1.STRINGS;
const TimeSync = (globalConfig) => {
    const metadata = {
        kind: 'execute',
    };
    /**
     * Take input array and return time-synchronized input array.
     */
    const execute = (inputs) => {
        const validatedConfig = validateGlobalConfig();
        const timeParams = {
            startTime: luxon_1.DateTime.fromISO(validatedConfig['start-time']),
            endTime: luxon_1.DateTime.fromISO(validatedConfig['end-time']),
            interval: validatedConfig.interval,
            allowPadding: validatedConfig['allow-padding'],
        };
        const pad = checkForPadding(inputs, timeParams);
        validatePadding(pad, timeParams);
        const paddedInputs = padInputs(inputs, pad, timeParams);
        const flattenInputs = paddedInputs.reduce((acc, input, index) => {
            const safeInput = Object.assign({}, input, validateInput(input, index));
            const currentMoment = parseDate(safeInput.timestamp);
            /** Checks if not the first input, then check consistency with previous ones. */
            if (index > 0) {
                const previousInput = paddedInputs[index - 1];
                const previousInputTimestamp = parseDate(previousInput.timestamp);
                /** Checks for timestamps overlap. */
                if (parseDate(previousInput.timestamp).plus({
                    seconds: previousInput.duration,
                }) > currentMoment) {
                    throw new InputValidationError(INVALID_OBSERVATION_OVERLAP);
                }
                const compareableTime = previousInputTimestamp.plus({
                    seconds: previousInput.duration,
                });
                const timelineGapSize = currentMoment
                    .diff(compareableTime)
                    .as('seconds');
                /** Checks if there is gap in timeline. */
                if (timelineGapSize > 1) {
                    acc.push(...getZeroishInputPerSecondBetweenRange(compareableTime, currentMoment, safeInput));
                }
            }
            /** Break down current observation. */
            for (let i = 0; i < safeInput.duration; i++) {
                const normalizedInput = breakDownInput(safeInput, i);
                acc.push(normalizedInput);
            }
            return trimInputsByGlobalTimeline(acc, timeParams);
        }, []);
        const sortedInputs = flattenInputs.sort((a, b) => parseDate(a.timestamp).diff(parseDate(b.timestamp)).as('seconds'));
        return resampleInputs(sortedInputs, timeParams);
    };
    const parseDate = (date) => {
        if (!date)
            return luxon_1.DateTime.invalid('Invalid date');
        // dates are passed to time-sync.ts both in ISO 8601 format
        // and as a Date object (from the deserialization of a YAML file)
        // if the YAML parser fails to identify as a date, it passes as a string
        if ((0, types_1.isDate)(date)) {
            return luxon_1.DateTime.fromJSDate(date);
        }
        if (typeof date === 'string') {
            return luxon_1.DateTime.fromISO(date);
        }
        throw new InputValidationError(`Unexpected date datatype: ${typeof date}: ${date}`);
    };
    /**
     * Validates input parameters.
     */
    const validateInput = (input, index) => {
        const schema = zod_1.z.object({
            timestamp: zod_1.z
                .string({
                required_error: `required in input[${index}]`,
            })
                .datetime({
                message: `invalid datetime in input[${index}]`,
            })
                .or(zod_1.z.date()),
            duration: zod_1.z.number(),
        });
        return (0, validations_1.validate)(schema, input);
    };
    /**
     * Validates global config parameters.
     */
    const validateGlobalConfig = () => {
        if (globalConfig === undefined) {
            throw new InputValidationError(INVALID_TIME_NORMALIZATION);
        }
        const schema = zod_1.z
            .object({
            'start-time': zod_1.z.string().datetime(),
            'end-time': zod_1.z.string().datetime(),
            interval: zod_1.z.number(),
            'allow-padding': zod_1.z.boolean(),
        })
            .refine(data => data['start-time'] < data['end-time'], {
            message: '`start-time` should be lower than `end-time`',
        });
        return (0, validations_1.validate)(schema, globalConfig);
    };
    /**
     * Calculates minimal factor.
     */
    const convertPerInterval = (value, duration) => value / duration;
    /**
     * Normalize time per given second.
     */
    const normalizeTimePerSecond = (currentRoundMoment, i) => {
        const thisMoment = parseDate(currentRoundMoment).startOf('second');
        return thisMoment.plus({ seconds: i });
    };
    /**
     * Breaks down input per minimal time unit.
     */
    const breakDownInput = (input, i) => {
        const inputKeys = Object.keys(input);
        return inputKeys.reduce((acc, key) => {
            const method = parameterize_1.parameterize.getAggregationMethod(key);
            if (key === 'timestamp') {
                const perSecond = normalizeTimePerSecond(input.timestamp, i);
                acc[key] = perSecond.toUTC().toISO() ?? '';
                return acc;
            }
            /** @todo use user defined resolution later */
            if (key === 'duration') {
                acc[key] = 1;
                return acc;
            }
            acc[key] =
                method === 'sum'
                    ? convertPerInterval(input[key], input['duration'])
                    : input[key];
            return acc;
        }, {});
    };
    /**
     * Populates object to fill the gaps in observational timeline using zeroish values.
     */
    const fillWithZeroishInput = (input, missingTimestamp) => {
        const metrics = Object.keys(input);
        return metrics.reduce((acc, metric) => {
            if (metric === 'timestamp') {
                acc[metric] = missingTimestamp.startOf('second').toUTC().toISO() ?? '';
                return acc;
            }
            /** @todo later will be changed to user defined interval */
            if (metric === 'duration') {
                acc[metric] = 1;
                return acc;
            }
            if (metric === 'time-reserved') {
                acc[metric] = acc['duration'];
                return acc;
            }
            const method = parameterize_1.parameterize.getAggregationMethod(metric);
            if (method === 'avg' || method === 'sum') {
                acc[metric] = 0;
                return acc;
            }
            acc[metric] = input[metric];
            return acc;
        }, {});
    };
    /**
     * Checks if `error on padding` is enabled and padding is needed. If so, then throws error.
     */
    const validatePadding = (pad, params) => {
        const { start, end } = pad;
        const isPaddingNeeded = start || end;
        if (!params.allowPadding && isPaddingNeeded) {
            throw new InputValidationError(AVOIDING_PADDING_BY_EDGES(start, end));
        }
    };
    /**
     * Checks if padding is needed either at start of the timeline or the end and returns status.
     */
    const checkForPadding = (inputs, params) => {
        const startDiffInSeconds = parseDate(inputs[0].timestamp)
            .diff(params.startTime)
            .as('seconds');
        const lastInput = inputs[inputs.length - 1];
        const endDiffInSeconds = parseDate(lastInput.timestamp)
            .plus({ second: lastInput.duration })
            .diff(params.endTime)
            .as('seconds');
        return {
            start: startDiffInSeconds > 0,
            end: endDiffInSeconds < 0,
        };
    };
    /**
     * Iterates over given inputs frame, meanwhile checking if aggregation method is `sum`, then calculates it.
     * For methods is `avg` and `none` calculating average of the frame.
     */
    const resampleInputFrame = (inputsInTimeslot) => {
        return inputsInTimeslot.reduce((acc, input, index, inputs) => {
            const metrics = Object.keys(input);
            metrics.forEach(metric => {
                const method = parameterize_1.parameterize.getAggregationMethod(metric);
                acc[metric] = acc[metric] ?? 0;
                if (metric === 'timestamp') {
                    acc[metric] = inputs[0][metric];
                    return;
                }
                if (method === 'sum') {
                    acc[metric] += input[metric];
                    return;
                }
                if (method === 'none') {
                    acc[metric] = input[metric];
                    return;
                }
                /**
                 * If timeslot contains records more than one, then divide each metric by the timeslot length,
                 *  so that their sum yields the timeslot average.
                 */
                if (inputsInTimeslot.length > 1 &&
                    index === inputsInTimeslot.length - 1) {
                    acc[metric] /= inputsInTimeslot.length;
                    return;
                }
                acc[metric] += input[metric];
            });
            return acc;
        }, {});
    };
    /**
     * Takes each array frame with interval length, then aggregating them together as from units.yaml file.
     */
    const resampleInputs = (inputs, params) => {
        return inputs.reduce((acc, _input, index, inputs) => {
            const frameStart = index * params.interval;
            const frameEnd = (index + 1) * params.interval;
            const inputsFrame = inputs.slice(frameStart, frameEnd);
            const resampledInput = resampleInputFrame(inputsFrame);
            /** Checks if resampled input is not empty, then includes in result. */
            if (Object.keys(resampledInput).length > 0) {
                acc.push(resampledInput);
            }
            return acc;
        }, []);
    };
    /**
     * Pads zeroish inputs from the beginning or at the end of the inputs if needed.
     */
    const padInputs = (inputs, pad, params) => {
        const { start, end } = pad;
        const paddedFromBeginning = [];
        if (start) {
            paddedFromBeginning.push(...getZeroishInputPerSecondBetweenRange(params.startTime, parseDate(inputs[0].timestamp), inputs[0]));
        }
        const paddedArray = paddedFromBeginning.concat(inputs);
        if (end) {
            const lastInput = inputs[inputs.length - 1];
            const lastInputEnd = parseDate(lastInput.timestamp).plus({
                seconds: lastInput.duration,
            });
            paddedArray.push(...getZeroishInputPerSecondBetweenRange(lastInputEnd, params.endTime.plus({ seconds: 1 }), lastInput));
        }
        return paddedArray;
    };
    const getZeroishInputPerSecondBetweenRange = (startDate, endDate, templateInput) => {
        const array = [];
        const dateRange = luxon_1.Interval.fromDateTimes(startDate, endDate);
        for (const interval of dateRange.splitBy({ second: 1 })) {
            array.push(fillWithZeroishInput(templateInput, 
            // as far as I can tell, start will never be null
            // because if we pass an invalid start/endDate to
            // Interval, we get a zero length array as the range
            interval.start || luxon_1.DateTime.invalid('not expected - start is null')));
        }
        return array;
    };
    /*
     * Checks if input's timestamp is included in global specified period then leaves it, otherwise.
     */
    const trimInputsByGlobalTimeline = (inputs, params) => {
        return inputs.reduce((acc, item) => {
            const { timestamp } = item;
            if (parseDate(timestamp) >= params.startTime &&
                parseDate(timestamp) <= params.endTime) {
                acc.push(item);
            }
            return acc;
        }, []);
    };
    return { metadata, execute };
};
exports.TimeSync = TimeSync;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS1zeW5jLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2J1aWx0aW5zL3RpbWUtc3luYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQ0FBdUM7QUFDdkMsaUNBQTZEO0FBQzdELDZCQUFzQjtBQUV0QixzREFBaUQ7QUFFakQsMkNBQXNDO0FBRXRDLHNDQUFrQztBQVFsQyxxREFBNkM7QUFFN0MsTUFBTSxFQUFDLG9CQUFvQixFQUFDLEdBQUcsZUFBTSxDQUFDO0FBRXRDLE1BQU0sRUFDSiwwQkFBMEIsRUFDMUIsMkJBQTJCLEVBQzNCLHlCQUF5QixHQUMxQixHQUFHLGdCQUFPLENBQUM7QUFFTCxNQUFNLFFBQVEsR0FBRyxDQUFDLFlBQWtDLEVBQWlCLEVBQUU7SUFDNUUsTUFBTSxRQUFRLEdBQUc7UUFDZixJQUFJLEVBQUUsU0FBUztLQUNoQixDQUFDO0lBRUY7O09BRUc7SUFDSCxNQUFNLE9BQU8sR0FBRyxDQUFDLE1BQXNCLEVBQWtCLEVBQUU7UUFDekQsTUFBTSxlQUFlLEdBQUcsb0JBQW9CLEVBQUUsQ0FBQztRQUMvQyxNQUFNLFVBQVUsR0FBRztZQUNqQixTQUFTLEVBQUUsZ0JBQVEsQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzFELE9BQU8sRUFBRSxnQkFBUSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEQsUUFBUSxFQUFFLGVBQWUsQ0FBQyxRQUFRO1lBQ2xDLFlBQVksRUFBRSxlQUFlLENBQUMsZUFBZSxDQUFDO1NBQy9DLENBQUM7UUFFRixNQUFNLEdBQUcsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ2hELGVBQWUsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFFakMsTUFBTSxZQUFZLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFF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USxDQUFDLGFBQWEsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDN0QsS0FBSyxNQUFNLFFBQVEsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUMsTUFBTSxFQUFFLENBQUMsRUFBQyxDQUFDLEVBQUU7WUFDckQsS0FBSyxDQUFDLElBQUksQ0FDUixvQkFBb0IsQ0FDbEIsYUFBYTtZQUNiLGlEQUFpRDtZQUNqRCxpREFBaUQ7WUFDakQsb0RBQW9EO1lBQ3BELFFBQVEsQ0FBQyxLQUFLLElBQUksZ0JBQVEsQ0FBQyxPQUFPLENBQUMsOEJBQThCLENBQUMsQ0FDbkUsQ0FDRixDQUFDO1NBQ0g7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUMsQ0FBQztJQUVGOztPQUVHO0lBQ0gsTUFBTSwwQkFBMEIsR0FBRyxDQUNqQyxNQUFzQixFQUN0QixNQUFrQixFQUNGLEVBQUU7UUFDbEIsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBbUIsRUFBRSxJQUFJLEVBQUUsRUFBRTtZQUNqRCxNQUFNLEVBQUMsU0FBUyxFQUFDLEdBQUcsSUFBSSxDQUFDO1lBRXpCLElBQ0UsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxTQUFTO2dCQUN4QyxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sRUFDdEM7Z0JBQ0EsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNoQjtZQUVELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxFQUFFLEVBQW9CLENBQUMsQ0FBQztJQUMzQixDQUFDLENBQUM7SUFFRixPQUFPLEVBQUMsUUFBUSxFQUFFLE9BQU8sRUFBQyxDQUFDO0FBQzdCLENBQUMsQ0FBQztBQTlaVyxRQUFBLFFBQVEsWUE4Wm5CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtpc0RhdGV9IGZyb20gJ25vZGU6dXRpbC90eXBlcyc7XG5pbXBvcnQge0RhdGVUaW1lLCBEYXRlVGltZU1heWJlVmFsaWQsIEludGVydmFsfSBmcm9tICdsdXhvbic7XG5pbXBvcnQge3p9IGZyb20gJ3pvZCc7XG5cbmltcG9ydCB7cGFyYW1ldGVyaXplfSBmcm9tICcuLi9saWIvcGFyYW1ldGVyaXplJztcblxuaW1wb3J0IHtFUlJPUlN9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcblxuaW1wb3J0IHtTVFJJTkdTfSBmcm9tICcuLi9jb25maWcnO1xuXG5pbXBvcnQge0V4ZWN1dGVQbHVnaW4sIFBsdWdpblBhcmFtc30gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlJztcbmltcG9ydCB7XG4gIFBhZGRpbmdSZWNlaXB0LFxuICBUaW1lTm9ybWFsaXplckNvbmZpZyxcbiAgVGltZVBhcmFtcyxcbn0gZnJvbSAnLi4vdHlwZXMvdGltZS1zeW5jJztcbmltcG9ydCB7dmFsaWRhdGV9IGZyb20gJy4uL3V0aWwvdmFsaWRhdGlvbnMnO1xuXG5jb25zdCB7SW5wdXRWYWxpZGF0aW9uRXJyb3J9ID0gRVJST1JTO1xuXG5jb25zdCB7XG4gIElOVkFMSURfVElNRV9OT1JNQUxJWkFUSU9OLFxuICBJTlZBTElEX09CU0VSVkFUSU9OX09WRVJMQVAsXG4gIEFWT0lESU5HX1BBRERJTkdfQllfRURHRVMsXG59ID0gU1RSSU5HUztcblxuZXhwb3J0IGNvbnN0IFRpbWVTeW5jID0gKGdsb2JhbENvbmZpZzogVGltZU5vcm1hbGl6ZXJDb25maWcpOiBFeGVjdXRlUGx1Z2luID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAga2luZDogJ2V4ZWN1dGUnLFxuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlIGlucHV0IGFycmF5IGFuZCByZXR1cm4gdGltZS1zeW5jaHJvbml6ZWQgaW5wdXQgYXJyYXkuXG4gICAqL1xuICBjb25zdCBleGVjdXRlID0gKGlucHV0czogUGx1Z2luUGFyYW1zW10pOiBQbHVnaW5QYXJhbXNbXSA9PiB7XG4gICAgY29uc3QgdmFsaWRhdGVkQ29uZmlnID0gdmFsaWRhdGVHbG9iYWxDb25maWcoKTtcbiAgICBjb25zdCB0aW1lUGFyYW1zID0ge1xuICAgICAgc3RhcnRUaW1lOiBEYXRlVGltZS5mcm9tSVNPKHZhbGlkYXRlZENvbmZpZ1snc3RhcnQtdGltZSddKSxcbiAgICAgIGVuZFRpbWU6IERhdGVUaW1lLmZyb21JU08odmFsaWRhdGVkQ29uZmlnWydlbmQtdGltZSddKSxcbiAgICAgIGludGVydmFsOiB2YWxpZGF0ZWRDb25maWcuaW50ZXJ2YWwsXG4gICAgICBhbGxvd1BhZGRpbmc6IHZhbGlkYXRlZENvbmZpZ1snYWxsb3ctcGFkZGluZyddLFxuICAgIH07XG5cbiAgICBjb25zdCBwYWQgPSBjaGVja0ZvclBhZGRpbmcoaW5wdXRzLCB0aW1lUGFyYW1zKTtcbiAgICB2YWxpZGF0ZVBhZGRpbmcocGFkLCB0aW1lUGFyYW1zKTtcblxuICAgIGNvbnN0IHBhZGRlZElucHV0cyA9IHBhZElucHV0cyhpbnB1dHMsIHBhZCwgdGltZVBhcmFtcyk7XG5cbiAgICBjb25zdCBmbGF0dGVuSW5wdXRzID0gcGFkZGVkSW5wdXRzLnJlZHVjZShcbiAgICAgIChhY2M6IFBsdWdpblBhcmFtc1tdLCBpbnB1dCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qgc2FmZUlucHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgaW5wdXQsIHZhbGlkYXRlSW5wdXQoaW5wdXQsIGluZGV4KSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNb21lbnQgPSBwYXJzZURhdGUoc2FmZUlucHV0LnRpbWVzdGFtcCk7XG5cbiAgICAgICAgLyoqIENoZWNrcyBpZiBub3QgdGhlIGZpcnN0IGlucHV0LCB0aGVuIGNoZWNrIGNvbnNpc3RlbmN5IHdpdGggcHJldmlvdXMgb25lcy4gKi9cbiAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzSW5wdXQgPSBwYWRkZWRJbnB1dHNbaW5kZXggLSAxXTtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c0lucHV0VGltZXN0YW1wID0gcGFyc2VEYXRlKHByZXZpb3VzSW5wdXQudGltZXN0YW1wKTtcblxuICAgICAgICAgIC8qKiBDaGVja3MgZm9yIHRpbWVzdGFtcHMgb3ZlcmxhcC4gKi9cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwYXJzZURhdGUocHJldmlvdXNJbnB1dC50aW1lc3RhbXApLnBsdXMoe1xuICAgICAgICAgICAgICBzZWNvbmRzOiBwcmV2aW91c0lucHV0LmR1cmF0aW9uLFxuICAgICAgICAgICAgfSkgPiBjdXJyZW50TW9tZW50XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW5wdXRWYWxpZGF0aW9uRXJyb3IoSU5WQUxJRF9PQlNFUlZBVElPTl9PVkVSTEFQKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjb21wYXJlYWJsZVRpbWUgPSBwcmV2aW91c0lucHV0VGltZXN0YW1wLnBsdXMoe1xuICAgICAgICAgICAgc2Vjb25kczogcHJldmlvdXNJbnB1dC5kdXJhdGlvbixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHRpbWVsaW5lR2FwU2l6ZSA9IGN1cnJlbnRNb21lbnRcbiAgICAgICAgICAgIC5kaWZmKGNvbXBhcmVhYmxlVGltZSlcbiAgICAgICAgICAgIC5hcygnc2Vjb25kcycpO1xuXG4gICAgICAgICAgLyoqIENoZWNrcyBpZiB0aGVyZSBpcyBnYXAgaW4gdGltZWxpbmUuICovXG4gICAgICAgICAgaWYgKHRpbWVsaW5lR2FwU2l6ZSA+IDEpIHtcbiAgICAgICAgICAgIGFjYy5wdXNoKFxuICAgICAgICAgICAgICAuLi5nZXRaZXJvaXNoSW5wdXRQZXJTZWNvbmRCZXR3ZWVuUmFuZ2UoXG4gICAgICAgICAgICAgICAgY29tcGFyZWFibGVUaW1lLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRNb21lbnQsXG4gICAgICAgICAgICAgICAgc2FmZUlucHV0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKiBCcmVhayBkb3duIGN1cnJlbnQgb2JzZXJ2YXRpb24uICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FmZUlucHV0LmR1cmF0aW9uOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkSW5wdXQgPSBicmVha0Rvd25JbnB1dChzYWZlSW5wdXQsIGkpO1xuXG4gICAgICAgICAgYWNjLnB1c2gobm9ybWFsaXplZElucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmltSW5wdXRzQnlHbG9iYWxUaW1lbGluZShhY2MsIHRpbWVQYXJhbXMpO1xuICAgICAgfSxcbiAgICAgIFtdIGFzIFBsdWdpblBhcmFtc1tdXG4gICAgKTtcblxuICAgIGNvbnN0IHNvcnRlZElucHV0cyA9IGZsYXR0ZW5JbnB1dHMuc29ydCgoYSwgYikgPT5cbiAgICAgIHBhcnNlRGF0ZShhLnRpbWVzdGFtcCkuZGlmZihwYXJzZURhdGUoYi50aW1lc3RhbXApKS5hcygnc2Vjb25kcycpXG4gICAgKTtcblxuICAgIHJldHVybiByZXNhbXBsZUlucHV0cyhzb3J0ZWRJbnB1dHMsIHRpbWVQYXJhbXMpIGFzIFBsdWdpblBhcmFtc1tdO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlRGF0ZSA9IChkYXRlOiBEYXRlIHwgc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFkYXRlKSByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCgnSW52YWxpZCBkYXRlJyk7XG4gICAgLy8gZGF0ZXMgYXJlIHBhc3NlZCB0byB0aW1lLXN5bmMudHMgYm90aCBpbiBJU08gODYwMSBmb3JtYXRcbiAgICAvLyBhbmQgYXMgYSBEYXRlIG9iamVjdCAoZnJvbSB0aGUgZGVzZXJpYWxpemF0aW9uIG9mIGEgWUFNTCBmaWxlKVxuICAgIC8vIGlmIHRoZSBZQU1MIHBhcnNlciBmYWlscyB0byBpZGVudGlmeSBhcyBhIGRhdGUsIGl0IHBhc3NlcyBhcyBhIHN0cmluZ1xuICAgIGlmIChpc0RhdGUoZGF0ZSkpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5mcm9tSlNEYXRlKGRhdGUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUlTTyhkYXRlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IElucHV0VmFsaWRhdGlvbkVycm9yKFxuICAgICAgYFVuZXhwZWN0ZWQgZGF0ZSBkYXRhdHlwZTogJHt0eXBlb2YgZGF0ZX06ICR7ZGF0ZX1gXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGVzIGlucHV0IHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdCB2YWxpZGF0ZUlucHV0ID0gKGlucHV0OiBQbHVnaW5QYXJhbXMsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBzY2hlbWEgPSB6Lm9iamVjdCh7XG4gICAgICB0aW1lc3RhbXA6IHpcbiAgICAgICAgLnN0cmluZyh7XG4gICAgICAgICAgcmVxdWlyZWRfZXJyb3I6IGByZXF1aXJlZCBpbiBpbnB1dFske2luZGV4fV1gLFxuICAgICAgICB9KVxuICAgICAgICAuZGF0ZXRpbWUoe1xuICAgICAgICAgIG1lc3NhZ2U6IGBpbnZhbGlkIGRhdGV0aW1lIGluIGlucHV0WyR7aW5kZXh9XWAsXG4gICAgICAgIH0pXG4gICAgICAgIC5vcih6LmRhdGUoKSksXG4gICAgICBkdXJhdGlvbjogei5udW1iZXIoKSxcbiAgICB9KTtcblxuICAgIHJldHVybiB2YWxpZGF0ZTx6LmluZmVyPHR5cGVvZiBzY2hlbWE+PihzY2hlbWEsIGlucHV0KTtcbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGVzIGdsb2JhbCBjb25maWcgcGFyYW1ldGVycy5cbiAgICovXG4gIGNvbnN0IHZhbGlkYXRlR2xvYmFsQ29uZmlnID0gKCkgPT4ge1xuICAgIGlmIChnbG9iYWxDb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IElucHV0VmFsaWRhdGlvbkVycm9yKElOVkFMSURfVElNRV9OT1JNQUxJWkFUSU9OKTtcbiAgICB9XG5cbiAgICBjb25zdCBzY2hlbWEgPSB6XG4gICAgICAub2JqZWN0KHtcbiAgICAgICAgJ3N0YXJ0LXRpbWUnOiB6LnN0cmluZygpLmRhdGV0aW1lKCksXG4gICAgICAgICdlbmQtdGltZSc6IHouc3RyaW5nKCkuZGF0ZXRpbWUoKSxcbiAgICAgICAgaW50ZXJ2YWw6IHoubnVtYmVyKCksXG4gICAgICAgICdhbGxvdy1wYWRkaW5nJzogei5ib29sZWFuKCksXG4gICAgICB9KVxuICAgICAgLnJlZmluZShkYXRhID0+IGRhdGFbJ3N0YXJ0LXRpbWUnXSA8IGRhdGFbJ2VuZC10aW1lJ10sIHtcbiAgICAgICAgbWVzc2FnZTogJ2BzdGFydC10aW1lYCBzaG91bGQgYmUgbG93ZXIgdGhhbiBgZW5kLXRpbWVgJyxcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHZhbGlkYXRlPHouaW5mZXI8dHlwZW9mIHNjaGVtYT4+KHNjaGVtYSwgZ2xvYmFsQ29uZmlnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBtaW5pbWFsIGZhY3Rvci5cbiAgICovXG4gIGNvbnN0IGNvbnZlcnRQZXJJbnRlcnZhbCA9ICh2YWx1ZTogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyKSA9PlxuICAgIHZhbHVlIC8gZHVyYXRpb247XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSB0aW1lIHBlciBnaXZlbiBzZWNvbmQuXG4gICAqL1xuICBjb25zdCBub3JtYWxpemVUaW1lUGVyU2Vjb25kID0gKFxuICAgIGN1cnJlbnRSb3VuZE1vbWVudDogRGF0ZSB8IHN0cmluZyxcbiAgICBpOiBudW1iZXJcbiAgKSA9PiB7XG4gICAgY29uc3QgdGhpc01vbWVudCA9IHBhcnNlRGF0ZShjdXJyZW50Um91bmRNb21lbnQpLnN0YXJ0T2YoJ3NlY29uZCcpO1xuICAgIHJldHVybiB0aGlzTW9tZW50LnBsdXMoe3NlY29uZHM6IGl9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEJyZWFrcyBkb3duIGlucHV0IHBlciBtaW5pbWFsIHRpbWUgdW5pdC5cbiAgICovXG4gIGNvbnN0IGJyZWFrRG93bklucHV0ID0gKGlucHV0OiBQbHVnaW5QYXJhbXMsIGk6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0S2V5cyA9IE9iamVjdC5rZXlzKGlucHV0KTtcblxuICAgIHJldHVybiBpbnB1dEtleXMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgY29uc3QgbWV0aG9kID0gcGFyYW1ldGVyaXplLmdldEFnZ3JlZ2F0aW9uTWV0aG9kKGtleSk7XG5cbiAgICAgIGlmIChrZXkgPT09ICd0aW1lc3RhbXAnKSB7XG4gICAgICAgIGNvbnN0IHBlclNlY29uZCA9IG5vcm1hbGl6ZVRpbWVQZXJTZWNvbmQoaW5wdXQudGltZXN0YW1wLCBpKTtcbiAgICAgICAgYWNjW2tleV0gPSBwZXJTZWNvbmQudG9VVEMoKS50b0lTTygpID8/ICcnO1xuXG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAdG9kbyB1c2UgdXNlciBkZWZpbmVkIHJlc29sdXRpb24gbGF0ZXIgKi9cbiAgICAgIGlmIChrZXkgPT09ICdkdXJhdGlvbicpIHtcbiAgICAgICAgYWNjW2tleV0gPSAxO1xuXG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG5cbiAgICAgIGFjY1trZXldID1cbiAgICAgICAgbWV0aG9kID09PSAnc3VtJ1xuICAgICAgICAgID8gY29udmVydFBlckludGVydmFsKGlucHV0W2tleV0sIGlucHV0WydkdXJhdGlvbiddKVxuICAgICAgICAgIDogaW5wdXRba2V5XTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSBhcyBQbHVnaW5QYXJhbXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgb2JqZWN0IHRvIGZpbGwgdGhlIGdhcHMgaW4gb2JzZXJ2YXRpb25hbCB0aW1lbGluZSB1c2luZyB6ZXJvaXNoIHZhbHVlcy5cbiAgICovXG4gIGNvbnN0IGZpbGxXaXRoWmVyb2lzaElucHV0ID0gKFxuICAgIGlucHV0OiBQbHVnaW5QYXJhbXMsXG4gICAgbWlzc2luZ1RpbWVzdGFtcDogRGF0ZVRpbWVNYXliZVZhbGlkXG4gICkgPT4ge1xuICAgIGNvbnN0IG1ldHJpY3MgPSBPYmplY3Qua2V5cyhpbnB1dCk7XG5cbiAgICByZXR1cm4gbWV0cmljcy5yZWR1Y2UoKGFjYywgbWV0cmljKSA9PiB7XG4gICAgICBpZiAobWV0cmljID09PSAndGltZXN0YW1wJykge1xuICAgICAgICBhY2NbbWV0cmljXSA9IG1pc3NpbmdUaW1lc3RhbXAuc3RhcnRPZignc2Vjb25kJykudG9VVEMoKS50b0lTTygpID8/ICcnO1xuXG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAdG9kbyBsYXRlciB3aWxsIGJlIGNoYW5nZWQgdG8gdXNlciBkZWZpbmVkIGludGVydmFsICovXG4gICAgICBpZiAobWV0cmljID09PSAnZHVyYXRpb24nKSB7XG4gICAgICAgIGFjY1ttZXRyaWNdID0gMTtcblxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuXG4gICAgICBpZiAobWV0cmljID09PSAndGltZS1yZXNlcnZlZCcpIHtcbiAgICAgICAgYWNjW21ldHJpY10gPSBhY2NbJ2R1cmF0aW9uJ107XG5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWV0aG9kID0gcGFyYW1ldGVyaXplLmdldEFnZ3JlZ2F0aW9uTWV0aG9kKG1ldHJpYyk7XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICdhdmcnIHx8IG1ldGhvZCA9PT0gJ3N1bScpIHtcbiAgICAgICAgYWNjW21ldHJpY10gPSAwO1xuXG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG5cbiAgICAgIGFjY1ttZXRyaWNdID0gaW5wdXRbbWV0cmljXTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSBhcyBQbHVnaW5QYXJhbXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYGVycm9yIG9uIHBhZGRpbmdgIGlzIGVuYWJsZWQgYW5kIHBhZGRpbmcgaXMgbmVlZGVkLiBJZiBzbywgdGhlbiB0aHJvd3MgZXJyb3IuXG4gICAqL1xuICBjb25zdCB2YWxpZGF0ZVBhZGRpbmcgPSAocGFkOiBQYWRkaW5nUmVjZWlwdCwgcGFyYW1zOiBUaW1lUGFyYW1zKTogdm9pZCA9PiB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gcGFkO1xuICAgIGNvbnN0IGlzUGFkZGluZ05lZWRlZCA9IHN0YXJ0IHx8IGVuZDtcbiAgICBpZiAoIXBhcmFtcy5hbGxvd1BhZGRpbmcgJiYgaXNQYWRkaW5nTmVlZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW5wdXRWYWxpZGF0aW9uRXJyb3IoQVZPSURJTkdfUEFERElOR19CWV9FREdFUyhzdGFydCwgZW5kKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcGFkZGluZyBpcyBuZWVkZWQgZWl0aGVyIGF0IHN0YXJ0IG9mIHRoZSB0aW1lbGluZSBvciB0aGUgZW5kIGFuZCByZXR1cm5zIHN0YXR1cy5cbiAgICovXG4gIGNvbnN0IGNoZWNrRm9yUGFkZGluZyA9IChcbiAgICBpbnB1dHM6IFBsdWdpblBhcmFtc1tdLFxuICAgIHBhcmFtczogVGltZVBhcmFtc1xuICApOiBQYWRkaW5nUmVjZWlwdCA9PiB7XG4gICAgY29uc3Qgc3RhcnREaWZmSW5TZWNvbmRzID0gcGFyc2VEYXRlKGlucHV0c1swXS50aW1lc3RhbXApXG4gICAgICAuZGlmZihwYXJhbXMuc3RhcnRUaW1lKVxuICAgICAgLmFzKCdzZWNvbmRzJyk7XG5cbiAgICBjb25zdCBsYXN0SW5wdXQgPSBpbnB1dHNbaW5wdXRzLmxlbmd0aCAtIDFdO1xuXG4gICAgY29uc3QgZW5kRGlmZkluU2Vjb25kcyA9IHBhcnNlRGF0ZShsYXN0SW5wdXQudGltZXN0YW1wKVxuICAgICAgLnBsdXMoe3NlY29uZDogbGFzdElucHV0LmR1cmF0aW9ufSlcbiAgICAgIC5kaWZmKHBhcmFtcy5lbmRUaW1lKVxuICAgICAgLmFzKCdzZWNvbmRzJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHN0YXJ0RGlmZkluU2Vjb25kcyA+IDAsXG4gICAgICBlbmQ6IGVuZERpZmZJblNlY29uZHMgPCAwLFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgZ2l2ZW4gaW5wdXRzIGZyYW1lLCBtZWFud2hpbGUgY2hlY2tpbmcgaWYgYWdncmVnYXRpb24gbWV0aG9kIGlzIGBzdW1gLCB0aGVuIGNhbGN1bGF0ZXMgaXQuXG4gICAqIEZvciBtZXRob2RzIGlzIGBhdmdgIGFuZCBgbm9uZWAgY2FsY3VsYXRpbmcgYXZlcmFnZSBvZiB0aGUgZnJhbWUuXG4gICAqL1xuICBjb25zdCByZXNhbXBsZUlucHV0RnJhbWUgPSAoaW5wdXRzSW5UaW1lc2xvdDogUGx1Z2luUGFyYW1zW10pID0+IHtcbiAgICByZXR1cm4gaW5wdXRzSW5UaW1lc2xvdC5yZWR1Y2UoKGFjYywgaW5wdXQsIGluZGV4LCBpbnB1dHMpID0+IHtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBPYmplY3Qua2V5cyhpbnB1dCk7XG5cbiAgICAgIG1ldHJpY3MuZm9yRWFjaChtZXRyaWMgPT4ge1xuICAgICAgICBjb25zdCBtZXRob2QgPSBwYXJhbWV0ZXJpemUuZ2V0QWdncmVnYXRpb25NZXRob2QobWV0cmljKTtcbiAgICAgICAgYWNjW21ldHJpY10gPSBhY2NbbWV0cmljXSA/PyAwO1xuXG4gICAgICAgIGlmIChtZXRyaWMgPT09ICd0aW1lc3RhbXAnKSB7XG4gICAgICAgICAgYWNjW21ldHJpY10gPSBpbnB1dHNbMF1bbWV0cmljXTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdzdW0nKSB7XG4gICAgICAgICAgYWNjW21ldHJpY10gKz0gaW5wdXRbbWV0cmljXTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdub25lJykge1xuICAgICAgICAgIGFjY1ttZXRyaWNdID0gaW5wdXRbbWV0cmljXTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aW1lc2xvdCBjb250YWlucyByZWNvcmRzIG1vcmUgdGhhbiBvbmUsIHRoZW4gZGl2aWRlIGVhY2ggbWV0cmljIGJ5IHRoZSB0aW1lc2xvdCBsZW5ndGgsXG4gICAgICAgICAqICBzbyB0aGF0IHRoZWlyIHN1bSB5aWVsZHMgdGhlIHRpbWVzbG90IGF2ZXJhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaW5wdXRzSW5UaW1lc2xvdC5sZW5ndGggPiAxICYmXG4gICAgICAgICAgaW5kZXggPT09IGlucHV0c0luVGltZXNsb3QubGVuZ3RoIC0gMVxuICAgICAgICApIHtcbiAgICAgICAgICBhY2NbbWV0cmljXSAvPSBpbnB1dHNJblRpbWVzbG90Lmxlbmd0aDtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjY1ttZXRyaWNdICs9IGlucHV0W21ldHJpY107XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSBhcyBQbHVnaW5QYXJhbXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlcyBlYWNoIGFycmF5IGZyYW1lIHdpdGggaW50ZXJ2YWwgbGVuZ3RoLCB0aGVuIGFnZ3JlZ2F0aW5nIHRoZW0gdG9nZXRoZXIgYXMgZnJvbSB1bml0cy55YW1sIGZpbGUuXG4gICAqL1xuICBjb25zdCByZXNhbXBsZUlucHV0cyA9IChpbnB1dHM6IFBsdWdpblBhcmFtc1tdLCBwYXJhbXM6IFRpbWVQYXJhbXMpID0+IHtcbiAgICByZXR1cm4gaW5wdXRzLnJlZHVjZSgoYWNjOiBQbHVnaW5QYXJhbXNbXSwgX2lucHV0LCBpbmRleCwgaW5wdXRzKSA9PiB7XG4gICAgICBjb25zdCBmcmFtZVN0YXJ0ID0gaW5kZXggKiBwYXJhbXMuaW50ZXJ2YWw7XG4gICAgICBjb25zdCBmcmFtZUVuZCA9IChpbmRleCArIDEpICogcGFyYW1zLmludGVydmFsO1xuICAgICAgY29uc3QgaW5wdXRzRnJhbWUgPSBpbnB1dHMuc2xpY2UoZnJhbWVTdGFydCwgZnJhbWVFbmQpO1xuXG4gICAgICBjb25zdCByZXNhbXBsZWRJbnB1dCA9IHJlc2FtcGxlSW5wdXRGcmFtZShpbnB1dHNGcmFtZSk7XG5cbiAgICAgIC8qKiBDaGVja3MgaWYgcmVzYW1wbGVkIGlucHV0IGlzIG5vdCBlbXB0eSwgdGhlbiBpbmNsdWRlcyBpbiByZXN1bHQuICovXG4gICAgICBpZiAoT2JqZWN0LmtleXMocmVzYW1wbGVkSW5wdXQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWNjLnB1c2gocmVzYW1wbGVkSW5wdXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdIGFzIFBsdWdpblBhcmFtc1tdKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFkcyB6ZXJvaXNoIGlucHV0cyBmcm9tIHRoZSBiZWdpbm5pbmcgb3IgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXRzIGlmIG5lZWRlZC5cbiAgICovXG4gIGNvbnN0IHBhZElucHV0cyA9IChcbiAgICBpbnB1dHM6IFBsdWdpblBhcmFtc1tdLFxuICAgIHBhZDogUGFkZGluZ1JlY2VpcHQsXG4gICAgcGFyYW1zOiBUaW1lUGFyYW1zXG4gICk6IFBsdWdpblBhcmFtc1tdID0+IHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBwYWQ7XG4gICAgY29uc3QgcGFkZGVkRnJvbUJlZ2lubmluZyA9IFtdO1xuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBwYWRkZWRGcm9tQmVnaW5uaW5nLnB1c2goXG4gICAgICAgIC4uLmdldFplcm9pc2hJbnB1dFBlclNlY29uZEJldHdlZW5SYW5nZShcbiAgICAgICAgICBwYXJhbXMuc3RhcnRUaW1lLFxuICAgICAgICAgIHBhcnNlRGF0ZShpbnB1dHNbMF0udGltZXN0YW1wKSxcbiAgICAgICAgICBpbnB1dHNbMF1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRkZWRBcnJheSA9IHBhZGRlZEZyb21CZWdpbm5pbmcuY29uY2F0KGlucHV0cyk7XG5cbiAgICBpZiAoZW5kKSB7XG4gICAgICBjb25zdCBsYXN0SW5wdXQgPSBpbnB1dHNbaW5wdXRzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbGFzdElucHV0RW5kID0gcGFyc2VEYXRlKGxhc3RJbnB1dC50aW1lc3RhbXApLnBsdXMoe1xuICAgICAgICBzZWNvbmRzOiBsYXN0SW5wdXQuZHVyYXRpb24sXG4gICAgICB9KTtcbiAgICAgIHBhZGRlZEFycmF5LnB1c2goXG4gICAgICAgIC4uLmdldFplcm9pc2hJbnB1dFBlclNlY29uZEJldHdlZW5SYW5nZShcbiAgICAgICAgICBsYXN0SW5wdXRFbmQsXG4gICAgICAgICAgcGFyYW1zLmVuZFRpbWUucGx1cyh7c2Vjb25kczogMX0pLFxuICAgICAgICAgIGxhc3RJbnB1dFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcGFkZGVkQXJyYXk7XG4gIH07XG5cbiAgY29uc3QgZ2V0WmVyb2lzaElucHV0UGVyU2Vjb25kQmV0d2VlblJhbmdlID0gKFxuICAgIHN0YXJ0RGF0ZTogRGF0ZVRpbWVNYXliZVZhbGlkLFxuICAgIGVuZERhdGU6IERhdGVUaW1lTWF5YmVWYWxpZCxcbiAgICB0ZW1wbGF0ZUlucHV0OiBQbHVnaW5QYXJhbXNcbiAgKSA9PiB7XG4gICAgY29uc3QgYXJyYXk6IFBsdWdpblBhcmFtc1tdID0gW107XG4gICAgY29uc3QgZGF0ZVJhbmdlID0gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydERhdGUsIGVuZERhdGUpO1xuICAgIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgZGF0ZVJhbmdlLnNwbGl0Qnkoe3NlY29uZDogMX0pKSB7XG4gICAgICBhcnJheS5wdXNoKFxuICAgICAgICBmaWxsV2l0aFplcm9pc2hJbnB1dChcbiAgICAgICAgICB0ZW1wbGF0ZUlucHV0LFxuICAgICAgICAgIC8vIGFzIGZhciBhcyBJIGNhbiB0ZWxsLCBzdGFydCB3aWxsIG5ldmVyIGJlIG51bGxcbiAgICAgICAgICAvLyBiZWNhdXNlIGlmIHdlIHBhc3MgYW4gaW52YWxpZCBzdGFydC9lbmREYXRlIHRvXG4gICAgICAgICAgLy8gSW50ZXJ2YWwsIHdlIGdldCBhIHplcm8gbGVuZ3RoIGFycmF5IGFzIHRoZSByYW5nZVxuICAgICAgICAgIGludGVydmFsLnN0YXJ0IHx8IERhdGVUaW1lLmludmFsaWQoJ25vdCBleHBlY3RlZCAtIHN0YXJ0IGlzIG51bGwnKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgLypcbiAgICogQ2hlY2tzIGlmIGlucHV0J3MgdGltZXN0YW1wIGlzIGluY2x1ZGVkIGluIGdsb2JhbCBzcGVjaWZpZWQgcGVyaW9kIHRoZW4gbGVhdmVzIGl0LCBvdGhlcndpc2UuXG4gICAqL1xuICBjb25zdCB0cmltSW5wdXRzQnlHbG9iYWxUaW1lbGluZSA9IChcbiAgICBpbnB1dHM6IFBsdWdpblBhcmFtc1tdLFxuICAgIHBhcmFtczogVGltZVBhcmFtc1xuICApOiBQbHVnaW5QYXJhbXNbXSA9PiB7XG4gICAgcmV0dXJuIGlucHV0cy5yZWR1Y2UoKGFjYzogUGx1Z2luUGFyYW1zW10sIGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHt0aW1lc3RhbXB9ID0gaXRlbTtcblxuICAgICAgaWYgKFxuICAgICAgICBwYXJzZURhdGUodGltZXN0YW1wKSA+PSBwYXJhbXMuc3RhcnRUaW1lICYmXG4gICAgICAgIHBhcnNlRGF0ZSh0aW1lc3RhbXApIDw9IHBhcmFtcy5lbmRUaW1lXG4gICAgICApIHtcbiAgICAgICAgYWNjLnB1c2goaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10gYXMgUGx1Z2luUGFyYW1zW10pO1xuICB9O1xuXG4gIHJldHVybiB7bWV0YWRhdGEsIGV4ZWN1dGV9O1xufTtcbiJdfQ==