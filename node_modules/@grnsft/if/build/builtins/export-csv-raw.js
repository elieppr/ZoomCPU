"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportCSVRaw = void 0;
const fs = __importStar(require("fs/promises"));
const errors_1 = require("../util/errors");
const { WriteFileError, CliInputError } = errors_1.ERRORS;
const ExportCSVRaw = () => {
    /**
     * handle a tree leaf, where there are no child nodes, by adding it as key->value pair to the flat map
     * and capturing key as a header
     */
    const handleLeafValue = (value, fullPath, key, flatMap, headers) => {
        if (fullPath.includes('outputs')) {
            headers.add(key);
            flatMap[fullPath] = value;
        }
    };
    /**
     * handle a tree node, recursively traverse the children and append their results to the flat map and captured headers
     */
    const handleNodeValue = (value, fullPath, flatMap, headers) => {
        const [subFlatMap, subHeaders] = extractFlatMapAndHeaders(value, fullPath);
        if (Object.keys(subFlatMap).length > 0) {
            Object.entries(subFlatMap).forEach(([subKey, value]) => {
                flatMap[subKey] = value;
            });
            subHeaders.forEach(subHeader => {
                headers.add(subHeader);
            });
        }
    };
    /**
     * Handles a key at the top level of the tree
     */
    const handleKey = (value, key, prefix, flatMap, headers) => {
        const fullPath = prefix ? `${prefix}.${key}` : key;
        if (value !== null && typeof value === 'object') {
            return handleNodeValue(value, fullPath, flatMap, headers);
        }
        return handleLeafValue(value, fullPath, key, flatMap, headers);
    };
    /**
     * Recursively extract a flat map and headers from the hierarcial tree.
     */
    const extractFlatMapAndHeaders = (tree, prefix = '') => {
        const headers = new Set();
        const flatMap = [];
        for (const key in tree) {
            if (key in tree) {
                handleKey(tree[key], key, prefix, flatMap, headers);
            }
        }
        return [flatMap, headers];
    };
    /**
     * extract the id of the key, that is removing the last token (which is the index).
     * in this manner, multiple keys that identical besides their index share the same id.
     */
    const extractIdHelper = (key) => {
        const parts = key.split('.');
        parts.pop();
        return parts.join('.');
    };
    /**
     * generate a CSV formatted string based on a flat key->value map, headers and ids
     */
    const getCsvString = (map, headers, ids) => {
        const csvRows = [];
        csvRows.push(['id', ...headers].join(','));
        ids.forEach(id => {
            const rowData = [id];
            headers.forEach(header => {
                const value = map[`${id}.${header}`] ?? '';
                rowData.push(value.toString());
            });
            csvRows.push(rowData.join(','));
        });
        return csvRows.join('\n');
    };
    /**
     * write the given string content to a file at the provided path
     */
    const writeOutputFile = async (content, outputPath) => {
        try {
            await fs.writeFile(`${outputPath}.csv`, content);
        }
        catch (error) {
            throw new WriteFileError(`Failed to write CSV to ${outputPath}: ${error}`);
        }
    };
    /**
     * export the provided tree content to a CSV file, represented in a flat structure
     */
    const execute = async (tree, _context, outputPath) => {
        if (!outputPath) {
            throw new CliInputError('Output path is required.');
        }
        const [extractredFlatMap, extractedHeaders] = extractFlatMapAndHeaders(tree);
        const ids = new Set(Object.keys(extractredFlatMap).map(key => extractIdHelper(key)));
        const csvString = getCsvString(extractredFlatMap, extractedHeaders, ids);
        writeOutputFile(csvString, outputPath);
    };
    return { execute };
};
exports.ExportCSVRaw = ExportCSVRaw;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb3J0LWNzdi1yYXcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYnVpbHRpbnMvZXhwb3J0LWNzdi1yYXcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxnREFBa0M7QUFFbEMsMkNBQXNDO0FBS3RDLE1BQU0sRUFBQyxjQUFjLEVBQUUsYUFBYSxFQUFDLEdBQUcsZUFBTSxDQUFDO0FBRXhDLE1BQU0sWUFBWSxHQUFHLEdBQTJCLEVBQUU7SUFDdkQ7OztPQUdHO0lBQ0gsTUFBTSxlQUFlLEdBQUcsQ0FDdEIsS0FBVSxFQUNWLFFBQWdCLEVBQ2hCLEdBQVEsRUFDUixPQUE2QixFQUM3QixPQUFvQixFQUNwQixFQUFFO1FBQ0YsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ2hDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUMzQjtJQUNILENBQUMsQ0FBQztJQUVGOztPQUVHO0lBQ0gsTUFBTSxlQUFlLEdBQUcsQ0FDdEIsS0FBVSxFQUNWLFFBQWdCLEVBQ2hCLE9BQTRCLEVBQzVCLE9BQW9CLEVBQ3BCLEVBQUU7UUFDRixNQUFNLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxHQUFHLHdCQUF3QixDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztRQUUzRSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUN0QyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7Z0JBQ3JELE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUM7WUFDMUIsQ0FBQyxDQUFDLENBQUM7WUFF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QUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxVQUFVLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNsRDtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ2QsTUFBTSxJQUFJLGNBQWMsQ0FDdEIsMEJBQTBCLFVBQVUsS0FBSyxLQUFLLEVBQUUsQ0FDakQsQ0FBQztTQUNIO0lBQ0gsQ0FBQyxDQUFDO0lBRUY7O09BRUc7SUFDSCxNQUFNLE9BQU8sR0FBRyxLQUFLLEVBQUUsSUFBUyxFQUFFLFFBQWlCLEVBQUUsVUFBa0IsRUFBRSxFQUFFO1FBQ3pFLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDZixNQUFNLElBQUksYUFBYSxDQUFDLDBCQUEwQixDQUFDLENBQUM7U0FDckQ7UUFFRCxNQUFNLENBQUMsaUJBQWlCLEVBQUUsZ0JBQWdCLENBQUMsR0FDekMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakMsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDaEUsQ0FBQztRQUNGLE1BQU0sU0FBUyxHQUFHLFlBQVksQ0FBQyxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUV6RSxlQUFlLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLENBQUMsQ0FBQztJQUVGLE9BQU8sRUFBQyxPQUFPLEVBQUMsQ0FBQztBQUNuQixDQUFDLENBQUM7QUFqSlcsUUFBQSxZQUFZLGdCQWlKdkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcy9wcm9taXNlcyc7XG5cbmltcG9ydCB7RVJST1JTfSBmcm9tICcuLi91dGlsL2Vycm9ycyc7XG5cbmltcG9ydCB7RXhoYXVzdFBsdWdpbkludGVyZmFjZX0gZnJvbSAnLi4vdHlwZXMvZXhoYXVzdC1wbHVnaW4taW50ZXJmYWNlJztcbmltcG9ydCB7Q29udGV4dH0gZnJvbSAnLi4vdHlwZXMvbWFuaWZlc3QnO1xuXG5jb25zdCB7V3JpdGVGaWxlRXJyb3IsIENsaUlucHV0RXJyb3J9ID0gRVJST1JTO1xuXG5leHBvcnQgY29uc3QgRXhwb3J0Q1NWUmF3ID0gKCk6IEV4aGF1c3RQbHVnaW5JbnRlcmZhY2UgPT4ge1xuICAvKipcbiAgICogaGFuZGxlIGEgdHJlZSBsZWFmLCB3aGVyZSB0aGVyZSBhcmUgbm8gY2hpbGQgbm9kZXMsIGJ5IGFkZGluZyBpdCBhcyBrZXktPnZhbHVlIHBhaXIgdG8gdGhlIGZsYXQgbWFwXG4gICAqIGFuZCBjYXB0dXJpbmcga2V5IGFzIGEgaGVhZGVyXG4gICAqL1xuICBjb25zdCBoYW5kbGVMZWFmVmFsdWUgPSAoXG4gICAgdmFsdWU6IGFueSxcbiAgICBmdWxsUGF0aDogc3RyaW5nLFxuICAgIGtleTogYW55LFxuICAgIGZsYXRNYXA6IHtba2V5OiBzdHJpbmddOiBhbnl9LFxuICAgIGhlYWRlcnM6IFNldDxzdHJpbmc+XG4gICkgPT4ge1xuICAgIGlmIChmdWxsUGF0aC5pbmNsdWRlcygnb3V0cHV0cycpKSB7XG4gICAgICBoZWFkZXJzLmFkZChrZXkpO1xuICAgICAgZmxhdE1hcFtmdWxsUGF0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGhhbmRsZSBhIHRyZWUgbm9kZSwgcmVjdXJzaXZlbHkgdHJhdmVyc2UgdGhlIGNoaWxkcmVuIGFuZCBhcHBlbmQgdGhlaXIgcmVzdWx0cyB0byB0aGUgZmxhdCBtYXAgYW5kIGNhcHR1cmVkIGhlYWRlcnNcbiAgICovXG4gIGNvbnN0IGhhbmRsZU5vZGVWYWx1ZSA9IChcbiAgICB2YWx1ZTogYW55LFxuICAgIGZ1bGxQYXRoOiBzdHJpbmcsXG4gICAgZmxhdE1hcDogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICBoZWFkZXJzOiBTZXQ8c3RyaW5nPlxuICApID0+IHtcbiAgICBjb25zdCBbc3ViRmxhdE1hcCwgc3ViSGVhZGVyc10gPSBleHRyYWN0RmxhdE1hcEFuZEhlYWRlcnModmFsdWUsIGZ1bGxQYXRoKTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhzdWJGbGF0TWFwKS5sZW5ndGggPiAwKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhzdWJGbGF0TWFwKS5mb3JFYWNoKChbc3ViS2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgZmxhdE1hcFtzdWJLZXldID0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgc3ViSGVhZGVycy5mb3JFYWNoKHN1YkhlYWRlciA9PiB7XG4gICAgICAgIGhlYWRlcnMuYWRkKHN1YkhlYWRlcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBrZXkgYXQgdGhlIHRvcCBsZXZlbCBvZiB0aGUgdHJlZVxuICAgKi9cbiAgY29uc3QgaGFuZGxlS2V5ID0gKFxuICAgIHZhbHVlOiBhbnksXG4gICAga2V5OiBhbnksXG4gICAgcHJlZml4OiBzdHJpbmcsXG4gICAgZmxhdE1hcDogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICBoZWFkZXJzOiBTZXQ8c3RyaW5nPlxuICApID0+IHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IHByZWZpeCA/IGAke3ByZWZpeH0uJHtrZXl9YCA6IGtleTtcblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gaGFuZGxlTm9kZVZhbHVlKHZhbHVlLCBmdWxsUGF0aCwgZmxhdE1hcCwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZUxlYWZWYWx1ZSh2YWx1ZSwgZnVsbFBhdGgsIGtleSwgZmxhdE1hcCwgaGVhZGVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGV4dHJhY3QgYSBmbGF0IG1hcCBhbmQgaGVhZGVycyBmcm9tIHRoZSBoaWVyYXJjaWFsIHRyZWUuXG4gICAqL1xuICBjb25zdCBleHRyYWN0RmxhdE1hcEFuZEhlYWRlcnMgPSAoXG4gICAgdHJlZTogYW55LFxuICAgIHByZWZpeCA9ICcnXG4gICk6IFtSZWNvcmQ8c3RyaW5nLCBhbnk+LCBTZXQ8c3RyaW5nPl0gPT4ge1xuICAgIGNvbnN0IGhlYWRlcnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGZsYXRNYXA6IFJlY29yZDxzdHJpbmcsIGFueT4gPSBbXTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHRyZWUpIHtcbiAgICAgIGlmIChrZXkgaW4gdHJlZSkge1xuICAgICAgICBoYW5kbGVLZXkodHJlZVtrZXldLCBrZXksIHByZWZpeCwgZmxhdE1hcCwgaGVhZGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtmbGF0TWFwLCBoZWFkZXJzXTtcbiAgfTtcblxuICAvKipcbiAgICogZXh0cmFjdCB0aGUgaWQgb2YgdGhlIGtleSwgdGhhdCBpcyByZW1vdmluZyB0aGUgbGFzdCB0b2tlbiAod2hpY2ggaXMgdGhlIGluZGV4KS5cbiAgICogaW4gdGhpcyBtYW5uZXIsIG11bHRpcGxlIGtleXMgdGhhdCBpZGVudGljYWwgYmVzaWRlcyB0aGVpciBpbmRleCBzaGFyZSB0aGUgc2FtZSBpZC5cbiAgICovXG4gIGNvbnN0IGV4dHJhY3RJZEhlbHBlciA9IChrZXk6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICBwYXJ0cy5wb3AoKTtcblxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGdlbmVyYXRlIGEgQ1NWIGZvcm1hdHRlZCBzdHJpbmcgYmFzZWQgb24gYSBmbGF0IGtleS0+dmFsdWUgbWFwLCBoZWFkZXJzIGFuZCBpZHNcbiAgICovXG4gIGNvbnN0IGdldENzdlN0cmluZyA9IChcbiAgICBtYXA6IHtba2V5OiBzdHJpbmddOiBhbnl9LFxuICAgIGhlYWRlcnM6IFNldDxzdHJpbmc+LFxuICAgIGlkczogU2V0PHN0cmluZz5cbiAgKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCBjc3ZSb3dzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNzdlJvd3MucHVzaChbJ2lkJywgLi4uaGVhZGVyc10uam9pbignLCcpKTtcblxuICAgIGlkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGNvbnN0IHJvd0RhdGEgPSBbaWRdO1xuXG4gICAgICBoZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBtYXBbYCR7aWR9LiR7aGVhZGVyfWBdID8/ICcnO1xuICAgICAgICByb3dEYXRhLnB1c2godmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9KTtcbiAgICAgIGNzdlJvd3MucHVzaChyb3dEYXRhLmpvaW4oJywnKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3N2Um93cy5qb2luKCdcXG4nKTtcbiAgfTtcblxuICAvKipcbiAgICogd3JpdGUgdGhlIGdpdmVuIHN0cmluZyBjb250ZW50IHRvIGEgZmlsZSBhdCB0aGUgcHJvdmlkZWQgcGF0aFxuICAgKi9cbiAgY29uc3Qgd3JpdGVPdXRwdXRGaWxlID0gYXN5bmMgKGNvbnRlbnQ6IHN0cmluZywgb3V0cHV0UGF0aDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShgJHtvdXRwdXRQYXRofS5jc3ZgLCBjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFdyaXRlRmlsZUVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHdyaXRlIENTViB0byAke291dHB1dFBhdGh9OiAke2Vycm9yfWBcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBleHBvcnQgdGhlIHByb3ZpZGVkIHRyZWUgY29udGVudCB0byBhIENTViBmaWxlLCByZXByZXNlbnRlZCBpbiBhIGZsYXQgc3RydWN0dXJlXG4gICAqL1xuICBjb25zdCBleGVjdXRlID0gYXN5bmMgKHRyZWU6IGFueSwgX2NvbnRleHQ6IENvbnRleHQsIG91dHB1dFBhdGg6IHN0cmluZykgPT4ge1xuICAgIGlmICghb3V0cHV0UGF0aCkge1xuICAgICAgdGhyb3cgbmV3IENsaUlucHV0RXJyb3IoJ091dHB1dCBwYXRoIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cblxuICAgIGNvbnN0IFtleHRyYWN0cmVkRmxhdE1hcCwgZXh0cmFjdGVkSGVhZGVyc10gPVxuICAgICAgZXh0cmFjdEZsYXRNYXBBbmRIZWFkZXJzKHRyZWUpO1xuICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoXG4gICAgICBPYmplY3Qua2V5cyhleHRyYWN0cmVkRmxhdE1hcCkubWFwKGtleSA9PiBleHRyYWN0SWRIZWxwZXIoa2V5KSlcbiAgICApO1xuICAgIGNvbnN0IGNzdlN0cmluZyA9IGdldENzdlN0cmluZyhleHRyYWN0cmVkRmxhdE1hcCwgZXh0cmFjdGVkSGVhZGVycywgaWRzKTtcblxuICAgIHdyaXRlT3V0cHV0RmlsZShjc3ZTdHJpbmcsIG91dHB1dFBhdGgpO1xuICB9O1xuXG4gIHJldHVybiB7ZXhlY3V0ZX07XG59O1xuIl19