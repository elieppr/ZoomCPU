"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportCSV = void 0;
const promises_1 = require("fs/promises");
const sync_1 = require("csv-stringify/sync");
const errors_1 = require("../util/errors");
const { CliInputError } = errors_1.ERRORS;
/**
 * Extension to IF that outputs the tree in a CSV format.
 */
const ExportCSV = () => {
    const parseOutputAndField = (outputPath) => {
        if (!outputPath) {
            throw new CliInputError('Output path is required.');
        }
        const paths = outputPath.split('#');
        const output = paths.slice(0, paths.length - 1).join('');
        const criteria = paths[paths.length - 1];
        if (paths.length <= 1 || !criteria) {
            throw new CliInputError('CSV export criteria is not found in output path. Please append it after --output <path>#.');
        }
        return {
            output,
            criteria,
        };
    };
    /**
     * Grabs output and criteria from cli args, then call tree walker to collect csv data.
     */
    const execute = async (tree, context, outputPath) => {
        const columns = ['Path'];
        const matrix = [columns];
        const { output, criteria } = parseOutputAndField(outputPath);
        const aggregationIsEnabled = !!context.aggregation;
        /**
         * Walks through all tree branches and leaves, collecting the data
         */
        const treeWalker = (node, criteria, path = 'tree') => {
            /** Hmm aggregated, then checks if it's the first one. If so adds column, pushes the value. */
            if (node.aggregated) {
                if (path === 'tree') {
                    columns.push('Aggregated');
                }
                matrix.push([`${path}.${criteria}`, node.aggregated[criteria]]);
            }
            /** So it has outputs, whats then? checks if timestamp is not there, adds one. Then appends values to it. */
            if (node.outputs) {
                node.outputs.forEach((output) => {
                    const { timestamp } = output;
                    if (!columns.includes(timestamp)) {
                        columns.push(output.timestamp);
                    }
                    const lastRow = matrix[matrix.length - 1];
                    if (aggregationIsEnabled) {
                        lastRow.push(output[criteria]);
                    }
                    else {
                        /** Handle without aggregation export strategy. */
                        if (matrix.length === 1 || lastRow.length === columns.length) {
                            matrix.push([`${path}.${criteria}`, output[criteria]]);
                        }
                        else {
                            lastRow.push(output[criteria]);
                        }
                    }
                });
            }
            /** Ohh children? then call every one and execute. */
            if (node.children) {
                for (const child in node.children) {
                    treeWalker(node.children[child], criteria, `${path}.children.${child}`);
                }
            }
        };
        treeWalker(tree, criteria);
        await (0, promises_1.writeFile)(`${output}.csv`, (0, sync_1.stringify)(matrix, { columns }));
    };
    return {
        execute,
        metadata: {
            kind: 'exhaust',
        },
    };
};
exports.ExportCSV = ExportCSV;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb3J0LWNzdi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9idWlsdGlucy9leHBvcnQtY3N2LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDBDQUFzQztBQUN0Qyw2Q0FBNkM7QUFFN0MsMkNBQXNDO0FBS3RDLE1BQU0sRUFBQyxhQUFhLEVBQUMsR0FBRyxlQUFNLENBQUM7QUFFL0I7O0dBRUc7QUFDSSxNQUFNLFNBQVMsR0FBRyxHQUFHLEVBQUU7SUFDNUIsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLFVBQWtCLEVBQUUsRUFBRTtRQUNqRCxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2YsTUFBTSxJQUFJLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1NBQ3JEO1FBRUQsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNwQyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6RCxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUV6QyxJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2xDLE1BQU0sSUFBSSxhQUFhLENBQ3JCLDJGQUEyRixDQUM1RixDQUFDO1NBQ0g7UUFFRCxPQUFPO1lBQ0wsTUFBTTtZQUNOLFFBQVE7U0FDVCxDQUFDO0lBQ0osQ0FBQyxDQUFDO0lBRUY7O09BRUc7SUFDSCxNQUFNLE9BQU8sR0FBRyxLQUFLLEVBQUUsSUFBUyxFQUFFLE9BQWdCLEVBQUUsVUFBa0IsRUFBRSxFQUFFO1FBQ3hFLE1BQU0sT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN6QixNQUFNLEVBQUMsTUFBTSxFQUFFLFFBQVEsRUFBQyxHQUFHLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzNELE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7UUFFbkQ7O1dBRUc7UUFDSCxNQUFNLFVBQVUsR0FBRyxDQUFDLElBQVMsRUFBRSxRQUFnQixFQUFFLElBQUksR0FBRyxNQUFNLEVBQUUsRUFBRTtZQUNoRSw4RkFBOEY7WUFDOUYsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNuQixJQUFJLElBQUksS0FBSyxNQUFNLEVBQUU7b0JBQ25CLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7aUJBQzVCO2dCQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNqRTtZQUVELDRHQUE0RztZQUM1RyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBb0IsRUFBRSxFQUFFO29CQUM1QyxNQUFNLEVBQUMsU0FBUyxFQUFDLEdBQUcsTUFBTSxDQUFDO29CQUUzQixJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTt3QkFDaEMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7cUJBQ2hDO29CQUVELE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUUxQyxJQUFJLG9CQUFvQixFQUFFO3dCQUN4QixPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO3FCQUNoQzt5QkFBTTt3QkFDTCxrREFBa0Q7d0JBQ2xELElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxPQUFPLENBQUMsTUFBTSxFQUFFOzRCQUM1RCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLElBQUksUUFBUSxFQUFFLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDeEQ7NkJBQU07NEJBQ0wsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzt5QkFDaEM7cUJBQ0Y7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7YUFDSjtZQUVELHFEQUFxRDtZQUNyRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2pCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDakMsVUFBVSxDQUNSLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQ3BCLFFBQVEsRUFDUixHQUFHLElBQUksYUFBYSxLQUFLLEVBQUUsQ0FDNUIsQ0FBQztpQkFDSDthQUNGO1FBQ0gsQ0FBQyxDQUFDO1FBRUYsVUFBVSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUUzQixNQUFNLElBQUEsb0JBQVMsRUFBQyxHQUFHLE1BQU0sTUFBTSxFQUFFLElBQUEsZ0JBQVMsRUFBQyxNQUFNLEVBQUUsRUFBQyxPQUFPLEVBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakUsQ0FBQyxDQUFDO0lBRUYsT0FBTztRQUNMLE9BQU87UUFDUCxRQUFRLEVBQUU7WUFDUixJQUFJLEVBQUUsU0FBUztTQUNoQjtLQUNGLENBQUM7QUFDSixDQUFDLENBQUM7QUEzRlcsUUFBQSxTQUFTLGFBMkZwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7d3JpdGVGaWxlfSBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQge3N0cmluZ2lmeX0gZnJvbSAnY3N2LXN0cmluZ2lmeS9zeW5jJztcblxuaW1wb3J0IHtFUlJPUlN9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcblxuaW1wb3J0IHtDb250ZXh0fSBmcm9tICcuLi90eXBlcy9tYW5pZmVzdCc7XG5pbXBvcnQge1BsdWdpblBhcmFtc30gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlJztcblxuY29uc3Qge0NsaUlucHV0RXJyb3J9ID0gRVJST1JTO1xuXG4vKipcbiAqIEV4dGVuc2lvbiB0byBJRiB0aGF0IG91dHB1dHMgdGhlIHRyZWUgaW4gYSBDU1YgZm9ybWF0LlxuICovXG5leHBvcnQgY29uc3QgRXhwb3J0Q1NWID0gKCkgPT4ge1xuICBjb25zdCBwYXJzZU91dHB1dEFuZEZpZWxkID0gKG91dHB1dFBhdGg6IHN0cmluZykgPT4ge1xuICAgIGlmICghb3V0cHV0UGF0aCkge1xuICAgICAgdGhyb3cgbmV3IENsaUlucHV0RXJyb3IoJ091dHB1dCBwYXRoIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhdGhzID0gb3V0cHV0UGF0aC5zcGxpdCgnIycpO1xuICAgIGNvbnN0IG91dHB1dCA9IHBhdGhzLnNsaWNlKDAsIHBhdGhzLmxlbmd0aCAtIDEpLmpvaW4oJycpO1xuICAgIGNvbnN0IGNyaXRlcmlhID0gcGF0aHNbcGF0aHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAocGF0aHMubGVuZ3RoIDw9IDEgfHwgIWNyaXRlcmlhKSB7XG4gICAgICB0aHJvdyBuZXcgQ2xpSW5wdXRFcnJvcihcbiAgICAgICAgJ0NTViBleHBvcnQgY3JpdGVyaWEgaXMgbm90IGZvdW5kIGluIG91dHB1dCBwYXRoLiBQbGVhc2UgYXBwZW5kIGl0IGFmdGVyIC0tb3V0cHV0IDxwYXRoPiMuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0LFxuICAgICAgY3JpdGVyaWEsXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYnMgb3V0cHV0IGFuZCBjcml0ZXJpYSBmcm9tIGNsaSBhcmdzLCB0aGVuIGNhbGwgdHJlZSB3YWxrZXIgdG8gY29sbGVjdCBjc3YgZGF0YS5cbiAgICovXG4gIGNvbnN0IGV4ZWN1dGUgPSBhc3luYyAodHJlZTogYW55LCBjb250ZXh0OiBDb250ZXh0LCBvdXRwdXRQYXRoOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBjb2x1bW5zID0gWydQYXRoJ107XG4gICAgY29uc3QgbWF0cml4ID0gW2NvbHVtbnNdO1xuICAgIGNvbnN0IHtvdXRwdXQsIGNyaXRlcmlhfSA9IHBhcnNlT3V0cHV0QW5kRmllbGQob3V0cHV0UGF0aCk7XG4gICAgY29uc3QgYWdncmVnYXRpb25Jc0VuYWJsZWQgPSAhIWNvbnRleHQuYWdncmVnYXRpb247XG5cbiAgICAvKipcbiAgICAgKiBXYWxrcyB0aHJvdWdoIGFsbCB0cmVlIGJyYW5jaGVzIGFuZCBsZWF2ZXMsIGNvbGxlY3RpbmcgdGhlIGRhdGFcbiAgICAgKi9cbiAgICBjb25zdCB0cmVlV2Fsa2VyID0gKG5vZGU6IGFueSwgY3JpdGVyaWE6IHN0cmluZywgcGF0aCA9ICd0cmVlJykgPT4ge1xuICAgICAgLyoqIEhtbSBhZ2dyZWdhdGVkLCB0aGVuIGNoZWNrcyBpZiBpdCdzIHRoZSBmaXJzdCBvbmUuIElmIHNvIGFkZHMgY29sdW1uLCBwdXNoZXMgdGhlIHZhbHVlLiAqL1xuICAgICAgaWYgKG5vZGUuYWdncmVnYXRlZCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gJ3RyZWUnKSB7XG4gICAgICAgICAgY29sdW1ucy5wdXNoKCdBZ2dyZWdhdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXgucHVzaChbYCR7cGF0aH0uJHtjcml0ZXJpYX1gLCBub2RlLmFnZ3JlZ2F0ZWRbY3JpdGVyaWFdXSk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBTbyBpdCBoYXMgb3V0cHV0cywgd2hhdHMgdGhlbj8gY2hlY2tzIGlmIHRpbWVzdGFtcCBpcyBub3QgdGhlcmUsIGFkZHMgb25lLiBUaGVuIGFwcGVuZHMgdmFsdWVzIHRvIGl0LiAqL1xuICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xuICAgICAgICBub2RlLm91dHB1dHMuZm9yRWFjaCgob3V0cHV0OiBQbHVnaW5QYXJhbXMpID0+IHtcbiAgICAgICAgICBjb25zdCB7dGltZXN0YW1wfSA9IG91dHB1dDtcblxuICAgICAgICAgIGlmICghY29sdW1ucy5pbmNsdWRlcyh0aW1lc3RhbXApKSB7XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2gob3V0cHV0LnRpbWVzdGFtcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbGFzdFJvdyA9IG1hdHJpeFttYXRyaXgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAoYWdncmVnYXRpb25Jc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGxhc3RSb3cucHVzaChvdXRwdXRbY3JpdGVyaWFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyoqIEhhbmRsZSB3aXRob3V0IGFnZ3JlZ2F0aW9uIGV4cG9ydCBzdHJhdGVneS4gKi9cbiAgICAgICAgICAgIGlmIChtYXRyaXgubGVuZ3RoID09PSAxIHx8IGxhc3RSb3cubGVuZ3RoID09PSBjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXgucHVzaChbYCR7cGF0aH0uJHtjcml0ZXJpYX1gLCBvdXRwdXRbY3JpdGVyaWFdXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsYXN0Um93LnB1c2gob3V0cHV0W2NyaXRlcmlhXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqIE9oaCBjaGlsZHJlbj8gdGhlbiBjYWxsIGV2ZXJ5IG9uZSBhbmQgZXhlY3V0ZS4gKi9cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgaW4gbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIHRyZWVXYWxrZXIoXG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuW2NoaWxkXSxcbiAgICAgICAgICAgIGNyaXRlcmlhLFxuICAgICAgICAgICAgYCR7cGF0aH0uY2hpbGRyZW4uJHtjaGlsZH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0cmVlV2Fsa2VyKHRyZWUsIGNyaXRlcmlhKTtcblxuICAgIGF3YWl0IHdyaXRlRmlsZShgJHtvdXRwdXR9LmNzdmAsIHN0cmluZ2lmeShtYXRyaXgsIHtjb2x1bW5zfSkpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZXhlY3V0ZSxcbiAgICBtZXRhZGF0YToge1xuICAgICAga2luZDogJ2V4aGF1c3QnLFxuICAgIH0sXG4gIH07XG59O1xuIl19