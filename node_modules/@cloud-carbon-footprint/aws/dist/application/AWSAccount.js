"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const aws_sdk_1 = require("aws-sdk");
const core_1 = require("@cloud-carbon-footprint/core");
const common_1 = require("@cloud-carbon-footprint/common");
const lib_1 = require("../lib");
const AWSCredentialsProvider_1 = __importDefault(require("./AWSCredentialsProvider"));
const domain_1 = require("../domain");
const Recommendations_1 = require("../lib/Recommendations");
class AWSAccount extends core_1.CloudProviderAccount {
    constructor(id, name, regions) {
        super();
        this.id = id;
        this.name = name;
        this.regions = regions;
        this.services = {
            ebs: (options) => {
                return new lib_1.EBS(this.createServiceWrapper(options));
            },
            s3: (options) => {
                return new lib_1.S3(this.createServiceWrapper(options));
            },
            ec2: (options) => {
                return new lib_1.EC2(this.createServiceWrapper(options));
            },
            elasticache: (options) => {
                return new lib_1.ElastiCache(this.createServiceWrapper(options));
            },
            rds: (options) => {
                return new lib_1.RDS(new lib_1.RDSComputeService(this.createServiceWrapper(options)), new lib_1.RDSStorage(this.createServiceWrapper(options)));
            },
            lambda: (options) => {
                return new lib_1.Lambda(120000, 1000, this.createServiceWrapper(options));
            },
        };
        this.credentials = AWSCredentialsProvider_1.default.create(id);
    }
    async getDataForRegions(startDate, endDate, grouping) {
        const results = [];
        for (const regionId of this.regions) {
            const regionEstimates = await Promise.all(await this.getDataForRegion(regionId, startDate, endDate, grouping));
            results.push(regionEstimates);
        }
        return results.flat();
    }
    getDataForRegion(regionId, startDate, endDate, grouping) {
        const awsServices = this.getServices(regionId);
        const awsConstants = {
            minWatts: domain_1.AWS_CLOUD_CONSTANTS.MIN_WATTS_AVG,
            maxWatts: domain_1.AWS_CLOUD_CONSTANTS.MAX_WATTS_AVG,
            powerUsageEffectiveness: domain_1.AWS_CLOUD_CONSTANTS.getPUE(),
        };
        const region = new core_1.Region(regionId, awsServices, domain_1.AWS_EMISSIONS_FACTORS_METRIC_TON_PER_KWH, awsConstants);
        return this.getRegionData((0, common_1.configLoader)().AWS.NAME, region, startDate, endDate, grouping);
    }
    getServices(regionId) {
        return (0, common_1.configLoader)().AWS.CURRENT_SERVICES.map(({ key }) => {
            return this.getService(key, regionId, this.credentials);
        });
    }
    async getDataForRecommendations(recommendationTarget) {
        const serviceWrapper = this.createServiceWrapper(this.getServiceConfigurationOptions((0, common_1.configLoader)().AWS.ATHENA_REGION, this.credentials));
        return await Recommendations_1.Recommendations.getRecommendations(recommendationTarget, serviceWrapper);
    }
    async getDataFromCostAndUsageReports(startDate, endDate, grouping) {
        const costAndUsageReportsService = new lib_1.CostAndUsageReports(new core_1.ComputeEstimator(), new core_1.StorageEstimator(domain_1.AWS_CLOUD_CONSTANTS.SSDCOEFFICIENT), new core_1.StorageEstimator(domain_1.AWS_CLOUD_CONSTANTS.HDDCOEFFICIENT), new core_1.NetworkingEstimator(domain_1.AWS_CLOUD_CONSTANTS.NETWORKING_COEFFICIENT), new core_1.MemoryEstimator(domain_1.AWS_CLOUD_CONSTANTS.MEMORY_COEFFICIENT), new core_1.UnknownEstimator(domain_1.AWS_CLOUD_CONSTANTS.ESTIMATE_UNKNOWN_USAGE_BY), new core_1.EmbodiedEmissionsEstimator(domain_1.AWS_CLOUD_CONSTANTS.SERVER_EXPECTED_LIFESPAN), this.createServiceWrapper(this.getServiceConfigurationOptions((0, common_1.configLoader)().AWS.ATHENA_REGION, this.credentials)));
        return await costAndUsageReportsService.getEstimates(startDate, endDate, grouping);
    }
    static async getCostAndUsageReportsDataFromInputData(inputData) {
        const costAndUsageReportsService = new lib_1.CostAndUsageReports(new core_1.ComputeEstimator(), new core_1.StorageEstimator(domain_1.AWS_CLOUD_CONSTANTS.SSDCOEFFICIENT), new core_1.StorageEstimator(domain_1.AWS_CLOUD_CONSTANTS.HDDCOEFFICIENT), new core_1.NetworkingEstimator(domain_1.AWS_CLOUD_CONSTANTS.NETWORKING_COEFFICIENT), new core_1.MemoryEstimator(domain_1.AWS_CLOUD_CONSTANTS.MEMORY_COEFFICIENT), new core_1.UnknownEstimator(domain_1.AWS_CLOUD_CONSTANTS.ESTIMATE_UNKNOWN_USAGE_BY), new core_1.EmbodiedEmissionsEstimator(domain_1.AWS_CLOUD_CONSTANTS.SERVER_EXPECTED_LIFESPAN));
        return await costAndUsageReportsService.getEstimatesFromInputData(inputData);
    }
    getService(key, region, credentials) {
        if (this.services[key] === undefined)
            throw new Error('Unsupported service: ' + key);
        const options = this.getServiceConfigurationOptions(region, credentials);
        return this.services[key](options);
    }
    getServiceConfigurationOptions(region, credentials) {
        return {
            region: region,
            credentials: credentials,
        };
    }
    createServiceWrapper(options) {
        return new lib_1.ServiceWrapper(new aws_sdk_1.CloudWatch(options), new aws_sdk_1.CloudWatchLogs(options), new aws_sdk_1.CostExplorer({
            region: (0, common_1.configLoader)().AWS.IS_AWS_GLOBAL
                ? 'us-east-1'
                : 'cn-northwest-1',
            credentials: options.credentials,
        }), new aws_sdk_1.S3(options), new aws_sdk_1.Athena(options), new aws_sdk_1.Glue(options));
    }
}
exports.default = AWSAccount;
//# sourceMappingURL=AWSAccount.js.map