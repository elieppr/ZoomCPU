"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@cloud-carbon-footprint/common");
const core_1 = require("@cloud-carbon-footprint/core");
const index_1 = require("./index");
const domain_1 = require("../../domain");
class Recommendations {
    static async getRecommendations(recommendationTarget, serviceWrapper) {
        const recommendationData = [];
        let recommendationService = (0, common_1.configLoader)().AWS.RECOMMENDATIONS_SERVICE;
        if (!recommendationService) {
            const configLogger = new common_1.Logger('AWSRecommendations');
            configLogger.warn('No AWS recommendations service was specified in env config. Retrieving only Rightsizing recommendations by default. The default service option may become "all" services in the future.');
            recommendationService = common_1.AWS_DEFAULT_RECOMMENDATIONS_SERVICE;
        }
        if (recommendationService !== common_1.AWS_RECOMMENDATIONS_SERVICES.RightSizing) {
            const computeOptimizerRecommendations = await Recommendations.getComputeOptimizer(serviceWrapper);
            recommendationData.push(...computeOptimizerRecommendations);
        }
        if (recommendationService !== common_1.AWS_RECOMMENDATIONS_SERVICES.ComputeOptimizer) {
            const rightsizingRecommendations = await Recommendations.getRightsizing(serviceWrapper, recommendationTarget);
            recommendationData.push(...rightsizingRecommendations);
        }
        return recommendationService === common_1.AWS_RECOMMENDATIONS_SERVICES.All
            ? Recommendations.getUniquesWithHighestSavings(recommendationData)
            : recommendationData;
    }
    static async getComputeOptimizer(serviceWrapper) {
        const computeOptimizerRecommendations = new index_1.ComputeOptimizerRecommendations(new core_1.ComputeEstimator(), new core_1.MemoryEstimator(domain_1.AWS_CLOUD_CONSTANTS.MEMORY_COEFFICIENT), new core_1.StorageEstimator(domain_1.AWS_CLOUD_CONSTANTS.SSDCOEFFICIENT), new core_1.StorageEstimator(domain_1.AWS_CLOUD_CONSTANTS.HDDCOEFFICIENT), serviceWrapper);
        return await computeOptimizerRecommendations.getRecommendations((0, common_1.configLoader)().AWS.COMPUTE_OPTIMIZER_BUCKET);
    }
    static async getRightsizing(serviceWrapper, recommendationTarget) {
        const rightsizingRecommendations = new index_1.RightsizingRecommendations(new core_1.ComputeEstimator(), new core_1.MemoryEstimator(domain_1.AWS_CLOUD_CONSTANTS.MEMORY_COEFFICIENT), serviceWrapper);
        return await rightsizingRecommendations.getRecommendations(recommendationTarget);
    }
    static getUniquesWithHighestSavings(recommendationData) {
        const uniqueRecommendationData = [];
        const mappedResources = {};
        recommendationData.forEach((recommendation) => {
            if (mappedResources[recommendation.resourceId])
                mappedResources[recommendation.resourceId].push(recommendation);
            else
                mappedResources[recommendation.resourceId] = [recommendation];
        });
        for (const resource in mappedResources) {
            const resourceRecommendations = mappedResources[resource];
            if (resourceRecommendations.length > 1)
                uniqueRecommendationData.push(getHighestSavings(resourceRecommendations));
            else
                uniqueRecommendationData.push(resourceRecommendations[0]);
        }
        return uniqueRecommendationData;
    }
}
exports.default = Recommendations;
function getHighestSavings(recommendations) {
    const [recommendationOne, recommendationTwo] = recommendations;
    if (recommendationTwo.co2eSavings > recommendationOne.co2eSavings)
        return recommendationTwo;
    if (recommendationTwo.co2eSavings === recommendationOne.co2eSavings)
        return getHighestCostSavings(recommendations);
    return recommendations[0];
}
function getHighestCostSavings(recommendations) {
    const [recommendationOne, recommendationTwo] = recommendations;
    return recommendationTwo.costSavings > recommendationOne.costSavings
        ? recommendationTwo
        : recommendationOne;
}
//# sourceMappingURL=Recommendations.js.map