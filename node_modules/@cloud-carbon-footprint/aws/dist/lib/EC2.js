"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cloud-carbon-footprint/core");
const CostMapper_1 = require("./CostMapper");
const domain_1 = require("../domain");
class EC2 extends core_1.ServiceWithCPUUtilization {
    constructor(serviceWrapper) {
        super();
        this.serviceWrapper = serviceWrapper;
        this.serviceName = 'EC2';
        this.runQuery = async (start, end) => {
            const params = {
                StartTime: start,
                EndTime: end,
                MetricDataQueries: [
                    {
                        Id: 'cpuUtilizationWithEmptyValues',
                        Expression: "SEARCH('{AWS/EC2,InstanceId} MetricName=\"CPUUtilization\"', 'Average', 3600)",
                        ReturnData: false,
                    },
                    {
                        Id: 'cpuUtilization',
                        Expression: 'REMOVE_EMPTY(cpuUtilizationWithEmptyValues)',
                    },
                    {
                        Id: 'vCPUs',
                        Expression: 'SEARCH(\'{AWS/Usage,Resource,Type,Service,Class } Resource="vCPU" MetricName="ResourceCount"\', \'Average\', 3600)',
                    },
                ],
                ScanBy: 'TimestampAscending',
            };
            const responses = await this.serviceWrapper.getMetricDataResponses(params);
            const metricDataResults = responses.flatMap((response) => response.MetricDataResults);
            const rawComputeUsages = metricDataResults.flatMap(core_1.extractRawComputeUsages);
            const cloudConstants = {
                avgCpuUtilization: domain_1.AWS_CLOUD_CONSTANTS.AVG_CPU_UTILIZATION_2020,
            };
            return (0, core_1.buildComputeUsages)(rawComputeUsages, cloudConstants);
        };
    }
    async getUsage(start, end) {
        const response = await this.serviceWrapper.getQueryByInterval(30, this.runQuery, start, end);
        return response.flat();
    }
    async getCosts(start, end, region) {
        const params = {
            TimePeriod: {
                Start: start.toISOString().substr(0, 10),
                End: end.toISOString().substr(0, 10),
            },
            Filter: {
                And: [
                    {
                        Dimensions: {
                            Key: 'REGION',
                            Values: [region],
                        },
                    },
                    {
                        Dimensions: {
                            Key: 'USAGE_TYPE_GROUP',
                            Values: ['EC2: Running Hours'],
                        },
                    },
                ],
            },
            Granularity: 'DAILY',
            GroupBy: [
                {
                    Key: 'USAGE_TYPE',
                    Type: 'DIMENSION',
                },
            ],
            Metrics: ['AmortizedCost'],
        };
        return (0, CostMapper_1.getCostFromCostExplorer)(params, this.serviceWrapper);
    }
}
exports.default = EC2;
//# sourceMappingURL=EC2.js.map