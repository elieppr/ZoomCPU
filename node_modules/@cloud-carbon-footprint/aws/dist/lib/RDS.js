"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const moment_1 = __importDefault(require("moment"));
const ramda_1 = require("ramda");
class RDS {
    constructor(rdsComputeService, rdsStorageService) {
        this.rdsComputeService = rdsComputeService;
        this.rdsStorageService = rdsStorageService;
        this.serviceName = 'RDS';
    }
    async getEstimates(start, end, region, emissionsFactors, constants) {
        const rdsComputeEstimates = this.rdsComputeService.getEstimates(start, end, region, emissionsFactors, constants);
        const rdsStorageEstimates = this.rdsStorageService.getEstimates(start, end, region, emissionsFactors, constants);
        const resolvedEstimates = await Promise.all([
            rdsComputeEstimates,
            rdsStorageEstimates,
        ]);
        const combinedEstimates = resolvedEstimates.flat();
        const result = {};
        combinedEstimates.forEach((estimate) => {
            const timestamp = estimate.timestamp.getTime();
            if (result[timestamp]) {
                result[timestamp].co2e += estimate.co2e;
                result[timestamp].kilowattHours += estimate.kilowattHours;
            }
            else {
                result[timestamp] = {
                    timestamp: estimate.timestamp,
                    co2e: estimate.co2e,
                    kilowattHours: estimate.kilowattHours,
                };
            }
        });
        return Object.values(result);
    }
    async getCosts(start, end, region) {
        const rdsComputeCosts = await this.rdsComputeService.getCosts(start, end, region);
        const rdsStorageCosts = await this.rdsStorageService.getCosts(start, end, region);
        const rdsCosts = (0, ramda_1.concat)(rdsComputeCosts, rdsStorageCosts);
        const groupingFn = (cost) => {
            return (0, moment_1.default)(cost.timestamp).utc().format('YYYY-MM-DD');
        };
        const accumulatingFn = (accumulator, cost) => {
            accumulator.timestamp =
                accumulator.timestamp ||
                    new Date((0, moment_1.default)(cost.timestamp).utc().format('YYYY-MM-DD'));
            accumulator.amount += cost.amount;
            accumulator.currency = cost.currency || 'USD';
            return accumulator;
        };
        return Object.values((0, ramda_1.reduceBy)(accumulatingFn, { amount: 0, currency: undefined, timestamp: undefined }, groupingFn, rdsCosts));
    }
}
exports.default = RDS;
//# sourceMappingURL=RDS.js.map