"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cloud-carbon-footprint/core");
const ComputeUsageMapper_1 = require("./ComputeUsageMapper");
const AWSInstanceTypes_1 = require("./AWSInstanceTypes");
const CostMapper_1 = require("./CostMapper");
class RDSComputeService extends core_1.ServiceWithCPUUtilization {
    constructor(serviceWrapper) {
        super();
        this.serviceWrapper = serviceWrapper;
        this.serviceName = 'rds';
    }
    async getUsage(start, end, region) {
        const metricDataResponses = await this.getCpuUtilization(start, end);
        const costAndUsageResponses = await this.getTotalVCpusByDate(start.toISOString().substr(0, 10), end.toISOString().substr(0, 10), region);
        return (0, ComputeUsageMapper_1.getComputeUsage)(metricDataResponses, costAndUsageResponses, AWSInstanceTypes_1.RDS_INSTANCE_TYPES);
    }
    async getCpuUtilization(start, end) {
        const params = {
            StartTime: start,
            EndTime: end,
            MetricDataQueries: [
                {
                    Id: 'cpuUtilizationWithEmptyValues',
                    Expression: "SEARCH('{AWS/RDS} MetricName=\"CPUUtilization\"', 'Average', 3600)",
                    ReturnData: false,
                },
                {
                    Id: 'cpuUtilization',
                    Expression: 'REMOVE_EMPTY(cpuUtilizationWithEmptyValues)',
                },
            ],
            ScanBy: 'TimestampAscending',
        };
        return await this.serviceWrapper.getMetricDataResponses(params);
    }
    async getTotalVCpusByDate(startDate, endDate, region) {
        const params = {
            TimePeriod: {
                Start: startDate,
                End: endDate,
            },
            Filter: {
                And: [
                    {
                        Dimensions: {
                            Key: 'REGION',
                            Values: [region],
                        },
                    },
                    {
                        Dimensions: {
                            Key: 'USAGE_TYPE_GROUP',
                            Values: ['RDS: Running Hours'],
                        },
                    },
                ],
            },
            Granularity: 'DAILY',
            GroupBy: [
                {
                    Key: 'USAGE_TYPE',
                    Type: 'DIMENSION',
                },
            ],
            Metrics: ['UsageQuantity'],
        };
        return await this.serviceWrapper.getCostAndUsageResponses(params);
    }
    async getCosts(start, end, region) {
        const params = {
            TimePeriod: {
                Start: start.toISOString().substr(0, 10),
                End: end.toISOString().substr(0, 10),
            },
            Filter: {
                And: [
                    {
                        Dimensions: {
                            Key: 'REGION',
                            Values: [region],
                        },
                    },
                    {
                        Dimensions: {
                            Key: 'USAGE_TYPE_GROUP',
                            Values: ['RDS: Running Hours'],
                        },
                    },
                ],
            },
            Granularity: 'DAILY',
            GroupBy: [
                {
                    Key: 'USAGE_TYPE',
                    Type: 'DIMENSION',
                },
            ],
            Metrics: ['AmortizedCost'],
        };
        return (0, CostMapper_1.getCostFromCostExplorer)(params, this.serviceWrapper);
    }
}
exports.default = RDSComputeService;
//# sourceMappingURL=RDSCompute.js.map