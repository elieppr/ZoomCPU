"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cloud-carbon-footprint/core");
const ComputeUsageMapper_1 = require("./ComputeUsageMapper");
const AWSInstanceTypes_1 = require("./AWSInstanceTypes");
const CostMapper_1 = require("./CostMapper");
class ElastiCache extends core_1.ServiceWithCPUUtilization {
    constructor(serviceWrapper) {
        super();
        this.serviceWrapper = serviceWrapper;
        this.serviceName = 'ElastiCache';
    }
    async getUsage(start, end, region) {
        const cloudWatchParams = {
            StartTime: start,
            EndTime: end,
            MetricDataQueries: [
                {
                    Id: 'cpuUtilizationWithEmptyValues',
                    Expression: "SEARCH('{AWS/ElastiCache} MetricName=\"CPUUtilization\"', 'Average', 3600)",
                    ReturnData: false,
                },
                {
                    Id: 'cpuUtilization',
                    Expression: 'REMOVE_EMPTY(cpuUtilizationWithEmptyValues)',
                },
            ],
            ScanBy: 'TimestampAscending',
        };
        const metricDataResponses = await this.serviceWrapper.getMetricDataResponses(cloudWatchParams);
        const costExplorerParams = {
            TimePeriod: {
                Start: start.toISOString().substr(0, 10),
                End: end.toISOString().substr(0, 10),
            },
            Filter: {
                And: [
                    {
                        Dimensions: {
                            Key: 'USAGE_TYPE_GROUP',
                            Values: ['ElastiCache: Running Hours'],
                        },
                    },
                    { Dimensions: { Key: 'REGION', Values: [region] } },
                ],
            },
            Granularity: 'DAILY',
            GroupBy: [
                {
                    Key: 'USAGE_TYPE',
                    Type: 'DIMENSION',
                },
            ],
            Metrics: ['UsageQuantity'],
        };
        const costAndUsageResponses = await this.serviceWrapper.getCostAndUsageResponses(costExplorerParams);
        return (0, ComputeUsageMapper_1.getComputeUsage)(metricDataResponses, costAndUsageResponses, AWSInstanceTypes_1.CACHE_NODE_TYPES);
    }
    async getCosts(start, end, region) {
        const costExplorerParams = {
            TimePeriod: {
                Start: start.toISOString().substr(0, 10),
                End: end.toISOString().substr(0, 10),
            },
            Filter: {
                And: [
                    {
                        Dimensions: {
                            Key: 'USAGE_TYPE_GROUP',
                            Values: ['ElastiCache: Running Hours'],
                        },
                    },
                    { Dimensions: { Key: 'REGION', Values: [region] } },
                ],
            },
            Granularity: 'DAILY',
            GroupBy: [
                {
                    Key: 'USAGE_TYPE',
                    Type: 'DIMENSION',
                },
            ],
            Metrics: ['AmortizedCost'],
        };
        return (0, CostMapper_1.getCostFromCostExplorer)(costExplorerParams, this.serviceWrapper);
    }
}
exports.default = ElastiCache;
//# sourceMappingURL=ElastiCache.js.map