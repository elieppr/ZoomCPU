"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildComputeUsages = exports.extractRawComputeUsages = exports.ComputeUsageBuilder = void 0;
class ComputeUsageBuilder {
    constructor(timestamp, constants) {
        this.timestamp = timestamp;
        this.cpuUtilizations = [];
        this.vCpuHours = 0;
        this.constants = constants;
    }
    addCpuUtilization(cpuUtilization) {
        if (cpuUtilization) {
            this.cpuUtilizations.push(cpuUtilization);
        }
        return this;
    }
    setVCpuHours(vCpuHours) {
        this.vCpuHours = vCpuHours;
        return this;
    }
    build() {
        const hasMeasurements = this.cpuUtilizations.length > 0;
        const cpuUtilizationAverage = hasMeasurements
            ? this.cpuUtilizations.reduce((sum, x) => sum + x) /
                this.cpuUtilizations.length
            : this.constants.avgCpuUtilization;
        return {
            timestamp: new Date(this.timestamp),
            cpuUtilizationAverage,
            vCpuHours: this.vCpuHours,
            usesAverageCPUConstant: !hasMeasurements,
        };
    }
}
exports.ComputeUsageBuilder = ComputeUsageBuilder;
const extractRawComputeUsages = (metricData) => metricData.Timestamps.map((timestamp, i) => ({
    timestamp: new Date(timestamp).toISOString(),
    id: metricData.Id,
    value: metricData.Values[i],
}));
exports.extractRawComputeUsages = extractRawComputeUsages;
const mergeUsageByTimestamp = (acc, data, constants) => {
    const usageToUpdate = acc[data.timestamp] || new ComputeUsageBuilder(data.timestamp, constants);
    if (data.id === 'cpuUtilization') {
        acc[data.timestamp] = usageToUpdate.addCpuUtilization(data.value);
    }
    else if (data.id === 'vCPUs') {
        acc[data.timestamp] = usageToUpdate.setVCpuHours(data.value);
    }
    return acc;
};
function buildComputeUsages(rawComputeUsages, constants) {
    const groupedComputeUsages = rawComputeUsages.reduce((acc, data) => mergeUsageByTimestamp(acc, data, constants), {});
    return Object.values(groupedComputeUsages)
        .map((builder) => builder.build())
        .filter((usage) => usage.vCpuHours > 0);
}
exports.buildComputeUsages = buildComputeUsages;
//# sourceMappingURL=ComputeUsage.js.map