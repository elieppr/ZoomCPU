"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
const common_1 = require("@cloud-carbon-footprint/common");
const cost_1 = require("./cost");
const _1 = require(".");
const moment_1 = __importDefault(require("moment"));
class CloudProviderAccount {
    async getRegionData(cloudProvider, region, startDate, endDate, grouping) {
        const [regionEstimates, regionCosts] = await Promise.all([
            region.getEstimates(startDate, endDate),
            region.getCosts(startDate, endDate),
        ]);
        const estimatesGroupByService = region.services.map((service) => {
            const estimates = regionEstimates[service.serviceName];
            const estimatesByDay = (0, _1.aggregateEstimatesByDay)(estimates);
            const costs = regionCosts[service.serviceName];
            const costsByDay = (0, cost_1.aggregateCostsByDay)(costs);
            const dates = (0, ramda_1.union)(Object.keys(estimatesByDay), Object.keys(costsByDay));
            const dataByDay = dates.reduce((acc, date) => {
                acc[date] = {
                    estimate: estimatesByDay[date],
                    cost: costsByDay[date],
                };
                return acc;
            }, {});
            const estimationResults = Object.entries(dataByDay).map(([date, { estimate, cost }]) => {
                return {
                    timestamp: moment_1.default.utc(date).toDate(),
                    serviceEstimates: [
                        {
                            cloudProvider: cloudProvider,
                            accountId: this.id,
                            accountName: this.name,
                            serviceName: service.serviceName,
                            region: region.id,
                            kilowattHours: estimate?.kilowattHours || 0,
                            co2e: estimate?.co2e || 0,
                            cost: cost?.amount || 0,
                            usesAverageCPUConstant: !!estimate?.usesAverageCPUConstant,
                        },
                    ],
                    periodStartDate: startDate,
                    periodEndDate: endDate,
                    groupBy: grouping,
                };
            });
            return estimationResults;
        });
        let estimates = (0, common_1.reduceByTimestamp)(estimatesGroupByService.flat());
        estimates = estimates.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
        return estimates;
    }
}
exports.default = CloudProviderAccount;
//# sourceMappingURL=CloudProviderAccount.js.map